,comments_id,line,message,range.start_line,range.end_line,content,changes_id,revisions_id,path,filepath_before,filepath_after,method_name_commented,is_included_after,is_revised_method_comment
0,140fa212_552b55e6,2168.0,"We could also review this closing tab check. That way, the incognito tab is not closed when clicking back button, to be consistent with normal tab logic. WDYT?",,,"[{'ab': ['// Copyright 2015 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser;', '', 'import android.annotation.TargetApi;', 'import android.app.ActivityManager;', 'import android.content.ComponentName;', 'import android.content.Context;', 'import android.content.Intent;', 'import android.content.pm.ApplicationInfo;', 'import android.content.pm.ShortcutManager;', 'import android.os.Build;', 'import android.os.Bundle;', 'import android.os.SystemClock;', 'import android.text.TextUtils;', 'import android.text.format.DateUtils;', 'import android.util.Pair;', 'import android.view.KeyEvent;', 'import android.view.KeyboardShortcutGroup;', 'import android.view.Menu;', 'import android.view.View;', 'import android.view.View.OnClickListener;', 'import android.view.ViewConfiguration;', 'import android.view.ViewGroup;', 'import android.view.Window;', 'import android.view.WindowManager;', '', 'import androidx.annotation.IntDef;', 'import androidx.annotation.Nullable;', 'import androidx.annotation.VisibleForTesting;', 'import androidx.lifecycle.Lifecycle;', 'import androidx.lifecycle.LifecycleObserver;', 'import androidx.lifecycle.LifecycleRegistry;', '', 'import org.chromium.base.CallbackController;', 'import org.chromium.base.CommandLine;', 'import org.chromium.base.ContextUtils;', 'import org.chromium.base.IntentUtils;', 'import org.chromium.base.Log;', 'import org.chromium.base.MemoryPressureListener;', 'import org.chromium.base.ThreadUtils;', 'import org.chromium.base.TraceEvent;', 'import org.chromium.base.annotations.UsedByReflection;', 'import org.chromium.base.jank_tracker.JankTrackerImpl;', 'import org.chromium.base.library_loader.LibraryLoader;', 'import org.chromium.base.metrics.RecordHistogram;', 'import org.chromium.base.metrics.RecordUserAction;', 'import org.chromium.base.supplier.ObservableSupplierImpl;', 'import org.chromium.base.supplier.OneShotCallback;', 'import org.chromium.base.supplier.OneshotSupplier;', 'import org.chromium.base.supplier.OneshotSupplierImpl;', 'import org.chromium.base.supplier.Supplier;', 'import org.chromium.base.supplier.UnownedUserDataSupplier;', 'import org.chromium.base.task.PostTask;', 'import org.chromium.cc.input.BrowserControlsState;', 'import org.chromium.chrome.R;', 'import org.chromium.chrome.browser.IntentHandler.IntentHandlerDelegate;', 'import org.chromium.chrome.browser.IntentHandler.TabOpenType;', 'import org.chromium.chrome.browser.accessibility_tab_switcher.OverviewListLayout;', 'import org.chromium.chrome.browser.app.ChromeActivity;', 'import org.chromium.chrome.browser.app.metrics.LaunchCauseMetrics;', 'import org.chromium.chrome.browser.app.metrics.TabbedActivityLaunchCauseMetrics;', 'import org.chromium.chrome.browser.app.tabmodel.AsyncTabParamsManagerSingleton;', 'import org.chromium.chrome.browser.app.tabmodel.ChromeNextTabPolicySupplier;', 'import org.chromium.chrome.browser.app.tabmodel.TabModelOrchestrator;', 'import org.chromium.chrome.browser.app.tabmodel.TabWindowManagerSingleton;', 'import org.chromium.chrome.browser.app.tabmodel.TabbedModeTabModelOrchestrator;', 'import org.chromium.chrome.browser.bookmarks.BookmarkUtils;', 'import org.chromium.chrome.browser.browserservices.intents.WebappConstants;', 'import org.chromium.chrome.browser.compositor.CompositorViewHolder;', 'import org.chromium.chrome.browser.compositor.bottombar.ephemeraltab.EphemeralTabCoordinator;', 'import org.chromium.chrome.browser.compositor.layouts.Layout;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChrome;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChromePhone;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChromeTablet;', 'import org.chromium.chrome.browser.compositor.layouts.OverviewModeBehavior;', 'import org.chromium.chrome.browser.compositor.layouts.OverviewModeController;', 'import org.chromium.chrome.browser.cookies.CookiesFetcher;', 'import org.chromium.chrome.browser.crypto.CipherFactory;', 'import org.chromium.chrome.browser.dependency_injection.ChromeActivityComponent;', 'import org.chromium.chrome.browser.device.DeviceClassManager;', 'import org.chromium.chrome.browser.dom_distiller.ReaderModeManager;', 'import org.chromium.chrome.browser.download.DownloadNotificationService;', 'import org.chromium.chrome.browser.download.DownloadOpenSource;', 'import org.chromium.chrome.browser.download.DownloadUtils;', 'import org.chromium.chrome.browser.feature_engagement.TrackerFactory;', 'import org.chromium.chrome.browser.feed.FeedSurfaceTracker;', 'import org.chromium.chrome.browser.firstrun.FirstRunSignInProcessor;', 'import org.chromium.chrome.browser.flags.ActivityType;', 'import org.chromium.chrome.browser.flags.CachedFeatureFlags;', 'import org.chromium.chrome.browser.flags.ChromeFeatureList;', 'import org.chromium.chrome.browser.flags.ChromeSwitches;', 'import org.chromium.chrome.browser.fonts.FontPreloader;', 'import org.chromium.chrome.browser.gesturenav.NavigationSheet;', 'import org.chromium.chrome.browser.homepage.HomepageManager;', 'import org.chromium.chrome.browser.incognito.IncognitoNotificationManager;', 'import org.chromium.chrome.browser.incognito.IncognitoNotificationPresenceController;', 'import org.chromium.chrome.browser.incognito.IncognitoProfileDestroyer;', 'import org.chromium.chrome.browser.incognito.IncognitoStartup;', 'import org.chromium.chrome.browser.incognito.IncognitoTabLauncher;', 'import org.chromium.chrome.browser.incognito.IncognitoTabSnapshotController;', 'import org.chromium.chrome.browser.incognito.IncognitoUtils;', 'import org.chromium.chrome.browser.infobar.DataReductionPromoInfoBar;', 'import org.chromium.chrome.browser.infobar.SyncErrorInfoBar;', 'import org.chromium.chrome.browser.layouts.LayoutStateProvider;', 'import org.chromium.chrome.browser.lifecycle.ActivityLifecycleDispatcher;', 'import org.chromium.chrome.browser.locale.LocaleManager;', 'import org.chromium.chrome.browser.metrics.AndroidSessionDurationsServiceState;', 'import org.chromium.chrome.browser.metrics.LaunchMetrics;', 'import org.chromium.chrome.browser.metrics.MainIntentBehaviorMetrics;', 'import org.chromium.chrome.browser.modaldialog.ChromeTabModalPresenter;', 'import org.chromium.chrome.browser.modaldialog.TabModalLifetimeHandler;', 'import org.chromium.chrome.browser.multiwindow.MultiInstanceChromeTabbedActivity;', 'import org.chromium.chrome.browser.multiwindow.MultiInstanceManager;', 'import org.chromium.chrome.browser.multiwindow.MultiWindowUtils;', 'import org.chromium.chrome.browser.native_page.NativePageAssassin;', 'import org.chromium.chrome.browser.navigation_predictor.NavigationPredictorBridge;', 'import org.chromium.chrome.browser.night_mode.WebContentsDarkModeController;', 'import org.chromium.chrome.browser.ntp.NewTabPageLaunchOrigin;', 'import org.chromium.chrome.browser.ntp.NewTabPageUma;', 'import org.chromium.chrome.browser.ntp.NewTabPageUtils;', 'import org.chromium.chrome.browser.omnibox.OmniboxFocusReason;', 'import org.chromium.chrome.browser.paint_preview.StartupPaintPreviewHelper;', 'import org.chromium.chrome.browser.paint_preview.StartupPaintPreviewHelperSupplier;', 'import org.chromium.chrome.browser.partnercustomizations.PartnerBrowserCustomizations;', 'import org.chromium.chrome.browser.preferences.ChromePreferenceKeys;', 'import org.chromium.chrome.browser.profiles.OTRProfileID;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.profiles.ProfileManager;', 'import org.chromium.chrome.browser.reengagement.ReengagementNotificationController;', 'import org.chromium.chrome.browser.search_engines.SearchEngineChoiceNotification;', 'import org.chromium.chrome.browser.settings.SettingsLauncherImpl;', 'import org.chromium.chrome.browser.share.send_tab_to_self.SendTabToSelfAndroidBridge;', 'import org.chromium.chrome.browser.suggestions.SuggestionsMetrics;', 'import org.chromium.chrome.browser.survey.ChromeSurveyController;', 'import org.chromium.chrome.browser.sync.ui.SyncErrorMessage;', 'import org.chromium.chrome.browser.sync.ui.SyncErrorPromptUtils;', 'import org.chromium.chrome.browser.tab.RedirectHandlerTabHelper;', 'import org.chromium.chrome.browser.tab.Tab;', 'import org.chromium.chrome.browser.tab.TabAssociatedApp;', 'import org.chromium.chrome.browser.tab.TabCreationState;', 'import org.chromium.chrome.browser.tab.TabDelegateFactory;', 'import org.chromium.chrome.browser.tab.TabLaunchType;', 'import org.chromium.chrome.browser.tab.TabSelectionType;', 'import org.chromium.chrome.browser.tab.state.CriticalPersistedTabData;', 'import org.chromium.chrome.browser.tabbed_mode.TabbedAppMenuPropertiesDelegate;', 'import org.chromium.chrome.browser.tabbed_mode.TabbedRootUiCoordinator;', 'import org.chromium.chrome.browser.tabmodel.ChromeTabCreator;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHost;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHostRegistry;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHostUtils;', 'import org.chromium.chrome.browser.tabmodel.NextTabPolicy.NextTabPolicySupplier;', 'import org.chromium.chrome.browser.tabmodel.TabModel;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelector;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorBase;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorTabModelObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorTabObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelUtils;', 'import org.chromium.chrome.browser.tabmodel.TabWindowManager;', 'import org.chromium.chrome.browser.tasks.ConditionalTabStripUtils;', 'import org.chromium.chrome.browser.tasks.EngagementTimeUtil;', 'import org.chromium.chrome.browser.tasks.JourneyManager;', 'import org.chromium.chrome.browser.tasks.ReturnToChromeExperimentsUtil;', 'import org.chromium.chrome.browser.tasks.TasksUma;', 'import org.chromium.chrome.browser.tasks.tab_management.TabGroupUi;', 'import org.chromium.chrome.browser.tasks.tab_management.TabManagementDelegate;', 'import org.chromium.chrome.browser.tasks.tab_management.TabManagementModuleProvider;', 'import org.chromium.chrome.browser.tasks.tab_management.TabUiFeatureUtilities;', 'import org.chromium.chrome.browser.toolbar.ToolbarButtonInProductHelpController;', 'import org.chromium.chrome.browser.toolbar.ToolbarIntentMetadata;', 'import org.chromium.chrome.browser.toolbar.ToolbarManager;', 'import org.chromium.chrome.browser.toolbar.top.ToolbarControlContainer;', 'import org.chromium.chrome.browser.translate.TranslateIntentHandler;', 'import org.chromium.chrome.browser.ui.AppLaunchDrawBlocker;', 'import org.chromium.chrome.browser.ui.RootUiCoordinator;', 'import org.chromium.chrome.browser.ui.TabObscuringHandler;', 'import org.chromium.chrome.browser.ui.appmenu.AppMenuPropertiesDelegate;', 'import org.chromium.chrome.browser.undo_tab_close_snackbar.UndoBarController;', 'import org.chromium.chrome.browser.usage_stats.UsageStatsService;', 'import org.chromium.chrome.browser.util.ChromeAccessibilityUtil;', 'import org.chromium.chrome.browser.vr.VrModuleProvider;', 'import org.chromium.chrome.features.start_surface.StartSurface;', 'import org.chromium.chrome.features.start_surface.StartSurfaceConfiguration;', 'import org.chromium.chrome.features.start_surface.StartSurfaceState;', 'import org.chromium.chrome.features.start_surface.StartSurfaceUserData;', 'import org.chromium.components.browser_ui.settings.SettingsLauncher;', 'import org.chromium.components.browser_ui.util.BrowserControlsVisibilityDelegate;', 'import org.chromium.components.browser_ui.util.ComposedBrowserControlsVisibilityDelegate;', 'import org.chromium.components.embedder_support.util.UrlConstants;', 'import org.chromium.components.embedder_support.util.UrlUtilities;', 'import org.chromium.components.feature_engagement.EventConstants;', 'import org.chromium.components.messages.MessageDispatcherProvider;', 'import org.chromium.components.profile_metrics.BrowserProfileType;', 'import org.chromium.components.webapps.ShortcutSource;', 'import org.chromium.content_public.browser.LoadUrlParams;', 'import org.chromium.content_public.browser.NavigationHandle;', 'import org.chromium.content_public.browser.RenderFrameHost;', 'import org.chromium.content_public.browser.UiThreadTaskTraits;', 'import org.chromium.content_public.browser.WebContents;', 'import org.chromium.content_public.browser.WebContentsAccessibility;', 'import org.chromium.content_public.common.ContentSwitches;', 'import org.chromium.ui.base.PageTransition;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', 'import org.chromium.ui.widget.Toast;', '', 'import java.lang.annotation.Retention;', 'import java.lang.annotation.RetentionPolicy;', 'import java.util.HashSet;', 'import java.util.List;', 'import java.util.Locale;', '', '/**', ' * This is the main activity for ChromeMobile when not running in document mode.  All the tabs', ' * are accessible via a chrome specific tab switching UI.', ' */', 'public class ChromeTabbedActivity extends ChromeActivity<ChromeActivityComponent>', '        implements ChromeAccessibilityUtil.Observer {', '    private static final String TAG = ""ChromeTabbedActivity"";', '', '    private static final String HELP_URL_PREFIX = ""https://support.google.com/chrome/"";', '', '    protected static final String WINDOW_INDEX = ""window_index"";', '', '    private static final String IS_INCOGNITO_SELECTED = ""is_incognito_selected"";', '', '    private static final int INVALID_WINDOW_ID = TabWindowManager.INVALID_WINDOW_INDEX;', '', '    // How long to delay closing the current tab when our app is minimized.  Have to delay this', ""    // so that we don't show the contents of the next tab while minimizing."", '    private static final long CLOSE_TAB_ON_MINIMIZE_DELAY_MS = 500;', '', '    // Maximum delay for initial tab creation. This is for homepage and NTP, not previous tabs', '    // restore. This is needed because we do not know when reading PartnerBrowserCustomizations', '    // provider will be finished.', '    private static final int INITIAL_TAB_CREATION_TIMEOUT_MS = 500;', '', '    /**', '     * Sending an intent with this action to Chrome will cause it to close all tabs', '     * (iff the --enable-test-intents command line flag is set). If a URL is supplied in the', '     * intent data, this will be loaded and unaffected by the close all action.', '     */', '    private static final String ACTION_CLOSE_TABS =', '            ""com.google.android.apps.chrome.ACTION_CLOSE_TABS"";', '', '    @VisibleForTesting', '    public static final String STARTUP_UMA_HISTOGRAM_SUFFIX = "".Tabbed"";', '', '    // Name of the ChromeTabbedActivity alias that handles MAIN intents.', '    public static final String MAIN_LAUNCHER_ACTIVITY_NAME = ""com.google.android.apps.chrome.Main"";', '', '    public static final SettingsLauncher SETTINGS_LAUNCHER = new SettingsLauncherImpl();', '', '    public static final HashSet<String> TABBED_MODE_COMPONENT_NAMES = new HashSet<String>() {', '        {', '            add(ChromeTabbedActivity.class.getName());', '            add(MultiInstanceChromeTabbedActivity.class.getName());', '            add(ChromeTabbedActivity2.class.getName());', '            add(MAIN_LAUNCHER_ACTIVITY_NAME);', '        }', '    };', '', '    /**', '     * Identifies a histogram to use in {@link #maybeDispatchExplicitMainViewIntent(Intent, int)}.', '     */', '    @IntDef({DispatchedBy.ON_CREATE, DispatchedBy.ON_NEW_INTENT})', '    @Retention(RetentionPolicy.SOURCE)', '    private @interface DispatchedBy {', '        int ON_CREATE = 1;', '        int ON_NEW_INTENT = 2;', '    }', '', '    // Count histogram used to track number of tabs when we show the Overview on Return to Chrome.', '    private static final String TAB_COUNT_ON_RETURN = ""Tabs.TabCountOnStartScreenShown"";', '', '    private final MainIntentBehaviorMetrics mMainIntentMetrics;', '    private @Nullable MultiInstanceManager mMultiInstanceManager;', '', '    private UndoBarController mUndoBarPopupController;', '', '    private LayoutManagerChrome mLayoutManager;', '', '    private ViewGroup mContentContainer;', '', '    private ToolbarControlContainer mControlContainer;', '', '    private TabbedModeTabModelOrchestrator mTabModelOrchestrator;', '    private TabModelSelectorBase mTabModelSelector;', '    private TabModelSelectorTabObserver mTabModelSelectorTabObserver;', '    private TabModelSelectorTabModelObserver mTabModelObserver;', '', '    private BrowserControlsVisibilityDelegate mVrBrowserControlsVisibilityDelegate;', '    private TabModalLifetimeHandler mTabModalHandler;', '', '    private boolean mUIWithNativeInitialized;', '', '    private Boolean mIsAccessibilityTabSwitcherEnabled;', '', '    private LocaleManager mLocaleManager;', '', '    private AppIndexingUtil mAppIndexingUtil;', '', '    private Runnable mShowHistoryRunnable;', '', '    private CompositorViewHolder mCompositorViewHolder;', '    private OverviewListLayout mOverviewListLayout;', '    /**', '     * Keeps track of whether or not a specific tab was created based on the startup intent.', '     */', '    private boolean mCreatedTabOnStartup;', '', '    // Whether or not the initial tab is being created.', '    private boolean mPendingInitialTabCreation;', '', '    // Whether {@link setInitialOverviewState()} has been called within the current onStart/onStop', '    // session.', '    private boolean mHasDeterminedOverviewStateForCurrentSession;', '    /**', '     *  Keeps track of the pref for the last time since this activity was stopped.', '     */', '    private ChromeInactivityTracker mInactivityTracker;', '', ""    // This is the cached value of mIntentHandler#shouldIgnoreIntent and shouldn't be read directly."", '    // Use #shouldIgnoreIntent instead.', '    private Boolean mShouldIgnoreIntent;', '    /*', '     *  Listens to FrameMetrics and records jank metrics.', '     */', '    private JankTrackerImpl mJankTracker;', '', '    // Supplier for a dependency to inform about the type of intent used to launch Chrome.', '    private OneshotSupplierImpl<ToolbarIntentMetadata> mIntentMetadataOneshotSupplier =', '            new OneshotSupplierImpl<>();', '', '    // Time at which an intent was received and handled.', '    private long mIntentHandlingTimeMs;', '', '    /**', '     * Whether the StartSurface is shown when Chrome is launched.', '     */', '    private boolean mOverviewShownOnStart;', '', '    private NextTabPolicySupplier mNextTabPolicySupplier;', '', '    private final UnownedUserDataSupplier<StartupPaintPreviewHelper>', '            mStartupPaintPreviewHelperSupplier = new StartupPaintPreviewHelperSupplier();', '', '    private final OneshotSupplierImpl<LayoutStateProvider> mLayoutStateProviderOneshotSupplier =', '            new OneshotSupplierImpl<>();', '    // TODO(crbug.com/1108496): Removed after all usages has been migrated to LayoutStateProvider.', '    private final OneshotSupplierImpl<OverviewModeBehavior> mOverviewModeBehaviorSupplier =', '            new OneshotSupplierImpl<>();', '    private OverviewModeController mOverviewModeController;', '', '    private ObservableSupplierImpl<EphemeralTabCoordinator> mEphemeralTabCoordinatorSupplier =', '            new ObservableSupplierImpl<>();', '    private final OneshotSupplierImpl<StartSurface> mStartSurfaceSupplier =', '            new OneshotSupplierImpl<>();', '    private ObservableSupplierImpl<Tab> mStartSurfaceParentTabSupplier =', '            new ObservableSupplierImpl<>();', '', '    private CallbackController mCallbackController = new CallbackController();', '    private TabbedModeTabDelegateFactory mTabDelegateFactory;', '', '    private final AppLaunchDrawBlocker mAppLaunchDrawBlocker;', '', '    // ID assigned to each ChromeTabbedActivity instance in Android S+ where multi-instance feature', '    // is supported. This can be explicitly set in the incoming Intent or internally assigned.', '    private int mWindowId;', '', '    private final IncognitoTabHost mIncognitoTabHost = new IncognitoTabHost() {', '        @Override', '        public boolean hasIncognitoTabs() {', '            return getTabModelSelector().getModel(true).getCount() > 0;', '        }', '', '        @Override', '        public void closeAllIncognitoTabs() {', '            if (isActivityFinishingOrDestroyed()) return;', '', '            // If the tabbed activity has not yet initialized, then finish the activity to avoid', '            // timing issues with clearing the incognito tab state in the background.', '            if (!areTabModelsInitialized() || !didFinishNativeInitialization()) {', '                finish();', '                return;', '            }', '', '            getTabModelSelector().getModel(true).closeAllTabs(false, false);', '        }', '', '        @Override', '        public boolean isActiveModel() {', '            return getTabModelSelector().getModel(true).isActiveModel();', '        }', '    };', '', '    /**', '     * This class is used to warm up the chrome split ClassLoader. See SplitChromeApplication for', '     * more info', '     */', '    @UsedByReflection(""SplitChromeApplication.java"")', '    public static class Preload extends ChromeTabbedActivity {', '        private LifecycleRegistry mLifecycleRegistry;', '', '        @UsedByReflection(""SplitChromeApplication.java"")', '        public Preload() {}', '', '        @Override', '        public Lifecycle getLifecycle() {', '            if (mLifecycleRegistry == null) {', '                // LifecycleRegistry normally enforces it is called on the main thread, but this', '                // class will be preloaded in a background thread. The only method that gets called', '                // in the activity constructor is addObserver(), so just override that.', '                mLifecycleRegistry = new LifecycleRegistry(null) {', '                    @Override', '                    public void addObserver(LifecycleObserver observer) {}', '                };', '            }', '            return mLifecycleRegistry;', '        }', '    }', '', '    /**', '     * Specify the proper non-.Main-aliased Chrome Activity for the given component.', '     *', '     * @param intent The intent to set the component for.', '     * @param component The client generated component to be validated.', '     */', '    public static void setNonAliasedComponent(Intent intent, ComponentName component) {', '        assert component != null;', '        Context appContext = ContextUtils.getApplicationContext();', '        if (!TextUtils.equals(component.getPackageName(), appContext.getPackageName())) {', '            return;', '        }', '        if (component.getClassName() != null', '                && TextUtils.equals(component.getClassName(),', '                        ChromeTabbedActivity.MAIN_LAUNCHER_ACTIVITY_NAME)) {', '            // Keep in sync with the activities that the .Main alias points to in', '            // AndroidManifest.xml.', '            intent.setClass(appContext, ChromeTabbedActivity.class);', '        } else {', '            intent.setComponent(component);', '        }', '    }', '', '    /**', '     * Constructs a ChromeTabbedActivity.', '     */', '    public ChromeTabbedActivity() {', '        mMainIntentMetrics = new MainIntentBehaviorMetrics();', '', '        // AppLaunchDrawBlocker may block drawing the Activity content until the initial tab is', '        // available.', '        // clang-format off', '        mAppLaunchDrawBlocker = new AppLaunchDrawBlocker(getLifecycleDispatcher(),', '                () -> findViewById(android.R.id.content),', '                this::getIntent, this::shouldIgnoreIntent, this::isTablet,', '                this::shouldShowOverviewPageOnStart);', '        // clang-format on', '    }', '', '    @Override', '    protected void onPreCreate() {', '        super.onPreCreate();', '        mMultiInstanceManager = MultiInstanceManager.create(this, getTabModelOrchestratorSupplier(),', '                getMultiWindowModeStateDispatcher(), getLifecycleDispatcher(),', '                getModalDialogManagerSupplier(), this);', '    }', '', '    @Override', '    protected @LaunchIntentDispatcher.Action int maybeDispatchLaunchIntent(', '            Intent intent, Bundle savedInstanceState) {', '        // Detect if incoming intent is a result of Chrome recreating itself. For now, restrict this', ""        // path to reparenting to ensure the launching logic isn't disrupted."", ""        // TODO(crbug.com/1065491): Unlock this codepath for all incoming intents once it's"", '        // confirmed working and stable.', '        if (savedInstanceState != null', '                && AsyncTabParamsManagerSingleton.getInstance().hasParamsWithTabToReparent()) {', '            return LaunchIntentDispatcher.Action.CONTINUE;', '        }', '', '        if (getClass().equals(ChromeTabbedActivity.class)', '                && Intent.ACTION_MAIN.equals(intent.getAction())) {', '            // Call dispatchToTabbedActivity() for MAIN intents to activate proper multi-window', '            // TabbedActivity (i.e. if CTA2 is currently running and Chrome is started, CTA2', ""            // should be brought to front). Don't call dispatchToTabbedActivity() for non-MAIN"", '            // intents to avoid breaking cases where CTA is started explicitly (e.g. to handle', ""            // 'Move to other window' command from CTA2)."", '            return LaunchIntentDispatcher.dispatchToTabbedActivity(this, intent);', '        }', '        @LaunchIntentDispatcher.Action', '        int action = maybeDispatchExplicitMainViewIntent(intent, DispatchedBy.ON_CREATE);', '        if (action != LaunchIntentDispatcher.Action.CONTINUE) {', '            return action;', '        }', '        return super.maybeDispatchLaunchIntent(intent, savedInstanceState);', '    }', '', '    // We know of at least one app that explicitly specifies .Main activity in custom tab', ""    // intents. The app shouldn't be doing that, but until it's updated, we need to support"", '    // such use case.', '    //', '    // This method attempts to treat VIEW intents explicitly sent to .Main as custom tab', '    // intents, and dispatch them accordingly. If the intent was not dispatched, the method', '    // returns Action.CONTINUE.', '    //', '    // The method also updates the supplied boolean histogram with the dispatching result,', '    // but only if the intent is a VIEW intent sent explicitly to .Main activity.', '    private @LaunchIntentDispatcher.Action int maybeDispatchExplicitMainViewIntent(', '            Intent intent, @DispatchedBy int dispatchedBy) {', ""        // The first check ensures that this is .Main activity alias (we can't check exactly, but"", '        // this gets us sufficiently close).', '        if (getClass().equals(ChromeTabbedActivity.class)', '                && Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getComponent() != null', '                && MAIN_LAUNCHER_ACTIVITY_NAME.equals(intent.getComponent().getClassName())) {', '            @LaunchIntentDispatcher.Action', '            int action = LaunchIntentDispatcher.dispatchToCustomTabActivity(this, intent);', '            switch (dispatchedBy) {', '                case DispatchedBy.ON_CREATE:', '                    RecordHistogram.recordBooleanHistogram(', '                            ""Android.MainActivity.ExplicitMainViewIntentDispatched.OnCreate"",', '                            action != LaunchIntentDispatcher.Action.CONTINUE);', '                    break;', '                case DispatchedBy.ON_NEW_INTENT:', '', '                    RecordHistogram.recordBooleanHistogram(', '                            ""Android.MainActivity.ExplicitMainViewIntentDispatched.OnNewIntent"",', '                            action != LaunchIntentDispatcher.Action.CONTINUE);', '                    break;', '                default:', '                    assert false : ""Unknown dispatchedBy value "" + dispatchedBy;', '            }', '            if (action == LaunchIntentDispatcher.Action.CONTINUE) {', '                // Intent was not dispatched, record its source.', '                @IntentHandler.ExternalAppId', '                int externalId = IntentHandler.determineExternalIntentSource(intent);', '                RecordHistogram.recordEnumeratedHistogram(', '                        ""Android.MainActivity.UndispatchedExplicitMainViewIntentSource"", externalId,', '                        IntentHandler.ExternalAppId.NUM_ENTRIES);', '', ""                // Crash if intent came from us, but only in debug builds and only if we weren't"", ""                // explicitly told not to. Hopefully we'll get enough reports to find where"", '                // these intents come from.', '                if (externalId == IntentHandler.ExternalAppId.CHROME', '                        && 0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE)', '                        && !CommandLine.getInstance().hasSwitch(', '                                ChromeSwitches.DONT_CRASH_ON_VIEW_MAIN_INTENTS)) {', '                    String intentInfo = intent.toString();', '                    Bundle extras = intent.getExtras();', '                    if (extras != null) {', '                        intentInfo +=', '                                "", extras.keySet = ["" + TextUtils.join("", "", extras.keySet()) + ""]"";', '                    }', '                    String message = String.format((Locale) null,', '                            ""VIEW intent sent to .Main activity alias was not dispatched. PLEASE ""', '                                    + ""report the following info to crbug.com/789732: \\""%s\\"". Use ""', '                                    + ""--%s flag to disable this check."",', '                            intentInfo, ChromeSwitches.DONT_CRASH_ON_VIEW_MAIN_INTENTS);', '                    throw new IllegalStateException(message);', '                }', '            }', '            return action;', '        }', '        return LaunchIntentDispatcher.Action.CONTINUE;', '    }', '', '    @Override', '    public void initializeCompositor() {', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.initializeCompositor"");', '            super.initializeCompositor();', '', '            // LocaleManager can only function after the native library is loaded.', '            mLocaleManager = LocaleManager.getInstance();', '            mLocaleManager.setSettingsLauncher(SETTINGS_LAUNCHER);', '            mLocaleManager.showSearchEnginePromoIfNeeded(this, null);', '', '            mTabModelOrchestrator.onNativeLibraryReady(getTabContentManager());', '', '            mTabModelObserver = new TabModelSelectorTabModelObserver(mTabModelSelector) {', '                @Override', '                public void didCloseTab(int tabId, boolean incognito) {', '                    closeIfNoTabsAndHomepageEnabled(false);', '                }', '', '                @Override', '                public void tabPendingClosure(Tab tab) {', '                    closeIfNoTabsAndHomepageEnabled(true);', '                }', '', '                @Override', '                public void tabRemoved(Tab tab) {', '                    closeIfNoTabsAndHomepageEnabled(false);', '                }', '', '                private void closeIfNoTabsAndHomepageEnabled(boolean isPendingClosure) {', '                    if (getTabModelSelector().getTotalTabCount() == 0) {', '                        // If the last tab is closed, and homepage is enabled, then exit Chrome.', '                        if (HomepageManager.shouldCloseAppWithZeroTabs()) {', '                            finish();', '                        } else if (isPendingClosure) {', '                            NewTabPageUma.recordNTPImpression(', '                                    NewTabPageUma.NTP_IMPESSION_POTENTIAL_NOTAB);', '                        }', '                    }', '', '                    // TODO(960196) : remove this when the associated bug fix. This is a band-aid', '                    //  fix for TabGrid and closing tabs with TabGroupUi.', '                    //  If one of the following is true, then exit Chrome when TabGroupsAndroid is', '                    //  enabled, and tab switcher is not shown:', '                    //   1. If the very last tab is closed.', '                    //   2. If normal tab model is selected and no normal tabs.', '                    if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(ChromeTabbedActivity.this)', '                            && !mOverviewModeController.overviewVisible()) {', '                        if (getTabModelSelector().getTotalTabCount() == 0', '                                || (!getTabModelSelector().isIncognitoSelected()', '                                        && getTabModelSelector().getModel(false).getCount() == 0)) {', '                            finish();', '                        }', '                    }', '                }', '', '                @Override', '                public void didAddTab(', '                        Tab tab, @TabLaunchType int type, @TabCreationState int creationState) {', '                    if (type == TabLaunchType.FROM_LONGPRESS_BACKGROUND', '                            && !DeviceClassManager.enableAnimations()) {', '                        Toast.makeText(ChromeTabbedActivity.this, R.string.open_in_new_tab_toast,', '                                     Toast.LENGTH_SHORT)', '                                .show();', '                    }', '                }', '', '                @Override', '                public void multipleTabsPendingClosure(List<Tab> tabs, boolean isAllTabs) {', '                    if (!isAllTabs) return;', '                    NewTabPageUma.recordNTPImpression(NewTabPageUma.NTP_IMPESSION_POTENTIAL_NOTAB);', '                }', '            };', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.initializeCompositor"");', '        }', '    }', '', '    private void refreshSignIn() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.refreshSignIn"")) {', '            FirstRunSignInProcessor.start(this);', '        }', '    }', '', '    private void setupCompositorContentPreNativeForPhone() {', '        if (isTablet()) return;', '', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPreNativeForPhone"")) {', '            CompositorViewHolder compositorViewHolder = getCompositorViewHolderSupplier().get();', '', '            // TODO(1169205): Remove all GTS enabled checks after M5 is default.', '            if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(this)) {', '                TabManagementDelegate tabManagementDelegate =', '                        TabManagementModuleProvider.getDelegate();', '                if (tabManagementDelegate != null) {', '                    StartSurface startSurface = tabManagementDelegate.createStartSurface(this,', '                            mRootUiCoordinator.getScrimCoordinator(),', '                            mRootUiCoordinator.getBottomSheetController(), mStartSurfaceSupplier,', '                            mStartSurfaceParentTabSupplier, hadWarmStart(), getWindowAndroid(),', '                            compositorViewHolder, compositorViewHolder::getDynamicResourceLoader,', '                            getTabModelSelector(), getBrowserControlsManager(),', '                            getSnackbarManager(), getShareDelegateSupplier(),', '                            getToolbarManager()::getOmniboxStub, getTabContentManager(),', '                            getModalDialogManager(),', '                            /* chromeActivityNativeDelegate= */ this, getLifecycleDispatcher(),', '                            getTabCreatorManagerSupplier().get(),', '                            getMenuOrKeyboardActionController(),', '                            getMultiWindowModeStateDispatcher(), mJankTracker,', '                            getToolbarManager()::getToolbar);', '                }', '            }', '', '            // clang-format off', '            mLayoutManager = new LayoutManagerChromePhone(compositorViewHolder, mContentContainer,', '                    mStartSurfaceSupplier.get(), getTabContentManagerSupplier(),', '                    () -> {', '                        if (!getCompositorViewHolderSupplier().hasValue()) return null;', '                        return getCompositorViewHolderSupplier().get().getLayerTitleCache();', '                    },', '                    mOverviewModeBehaviorSupplier,', '                    mRootUiCoordinator::getTopUiThemeColorProvider, mJankTracker);', '            mLayoutStateProviderOneshotSupplier.set(mLayoutManager);', '            // clang-format on', '            mOverviewModeController = mLayoutManager;', '        }', '    }', '', '    private void setupCompositorContentPreNativeForTablet() {', '        if (!isTablet()) return;', '', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPreNativeForTablet"")) {', '            // clang-format off', '            mLayoutManager = new LayoutManagerChromeTablet(getCompositorViewHolderSupplier().get(),', '                    mContentContainer, getTabContentManagerSupplier(),', '                    () -> {', '                        if (!getCompositorViewHolderSupplier().hasValue()) return null;', '                        return getCompositorViewHolderSupplier().get().getLayerTitleCache();', '                    },', '                    mOverviewModeBehaviorSupplier,', '                    mRootUiCoordinator::getTopUiThemeColorProvider, mJankTracker);', '            mLayoutStateProviderOneshotSupplier.set(mLayoutManager);', '            // clang-format on', '            mOverviewModeController = mLayoutManager;', '        }', '    }', '', '    private void setupCompositorContentPostNative() {', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPostNative"")) {', '            if (!isLayoutManagerCreated()) {', '                if (isTablet()) {', '                    setupCompositorContentPreNativeForTablet();', '                } else {', '                    setupCompositorContentPreNativeForPhone();', '                }', '            }', '', '            mLayoutManager.setEnableAnimations(DeviceClassManager.enableAnimations());', '', '            // TODO(yusufo): get rid of findViewById(R.id.url_bar).', '            initializeCompositorContent(mLayoutManager, findViewById(R.id.url_bar),', '                    mContentContainer, mControlContainer);', '        }', '    }', '', '    private boolean isLayoutManagerCreated() {', '        return mLayoutManager != null;', '    }', '', '    private void initializeToolbarManager() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.initializeToolbarManager"")) {', '            mUndoBarPopupController.initialize();', '', '            OnClickListener tabSwitcherClickHandler = v -> {', '                if (ChromeFeatureList.isEnabled(ChromeFeatureList.TOOLBAR_IPH_ANDROID)) {', '                    Profile profile = mTabModelProfileSupplier.get();', '                    if (profile != null) {', '                        TrackerFactory.getTrackerForProfile(profile).notifyEvent(', '                                EventConstants.TAB_SWITCHER_BUTTON_CLICKED);', '                    }', '                }', '', '                if (getFullscreenManager().getPersistentFullscreenMode()) {', '                    return;', '                }', '', '                if (isInOverviewMode()', '                        && !ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '                    hideOverview();', '                } else {', '                    showOverview(StartSurfaceState.SHOWING_TABSWITCHER);', '                }', '            };', '            OnClickListener newTabClickHandler = v -> {', '                getTabModelSelector().getModel(false).commitAllTabClosures();', '                // This assumes that the keyboard can not be seen at the same time as the', '                // newtab button on the toolbar.', '                getCurrentTabCreator().launchNTP();', '                mLocaleManager.showSearchEnginePromoIfNeeded(ChromeTabbedActivity.this, null);', '                if (getTabModelSelector().isIncognitoSelected()) {', '                    RecordUserAction.record(""MobileToolbarStackViewNewIncognitoTab"");', '                } else {', '                    RecordUserAction.record(""MobileToolbarStackViewNewTab"");', '                }', '                RecordUserAction.record(""MobileTopToolbarNewTabButton"");', '', '                RecordUserAction.record(""MobileNewTabOpened"");', '                ReturnToChromeExperimentsUtil.onNewTabOpened();', '            };', '            OnClickListener bookmarkClickHandler = v -> addOrEditBookmark(getActivityTab());', '', '            Supplier<Boolean> showStartSurfaceSupplier = () -> {', '                // If incognito is selected, tapping the home button stays on the current incognito', '                // tab.', '                if (ReturnToChromeExperimentsUtil.shouldShowStartSurfaceAsTheHomePageOnPhone(', '                            this, isTablet())', '                        && !mTabModelSelector.isIncognitoSelected()) {', '                    StartSurfaceUserData.setKeepTab(getActivityTab(), true);', '                    showOverview(StartSurfaceState.SHOWING_HOMEPAGE);', '                    return true;', '                }', '                return false;', '            };', '', '            getToolbarManager().initializeWithNative(mLayoutManager, tabSwitcherClickHandler,', '                    newTabClickHandler, bookmarkClickHandler, null, showStartSurfaceSupplier);', '', '            if (!TabUiFeatureUtilities.supportInstantStart(isTablet(), this)) {', '                assert !(mOverviewModeController != null', '                        && mOverviewModeController.overviewVisible());', '            }', '        }', '    }', '', '    private void maybeCreateIncognitoTabSnapshotController() {', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.maybeCreateIncognitoTabSnapshotController"")) {', '            if (!CommandLine.getInstance().hasSwitch(', '                        ChromeSwitches.ENABLE_INCOGNITO_SNAPSHOTS_IN_ANDROID_RECENTS)) {', '                IncognitoTabSnapshotController.createIncognitoTabSnapshotController(', '                        this, getWindow(), mLayoutManager, mTabModelSelector);', '            }', '', '            mUIWithNativeInitialized = true;', '            onAccessibilityTabSwitcherModeChanged();', '', '            // The dataset has already been created, we need to initialize our state.', '            mTabModelSelector.notifyChanged();', '', '            // Check for incognito tabs to handle the case where Chrome was swiped away in the', '            // background.', '            if (!IncognitoTabHostUtils.doIncognitoTabsExist()) {', '                IncognitoNotificationManager.dismissIncognitoNotification();', '                DownloadNotificationService.getInstance().cancelOffTheRecordDownloads();', '            }', '        }', '    }', '', '    private void maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.""', '                     + ""maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver"")) {', '            FeedSurfaceTracker.getInstance().startup();', '', '            if (UsageStatsService.isEnabled()) {', '                UsageStatsService.getInstance().createPageViewObserver(', '                        this, getActivityTabProvider(), getTabContentManagerSupplier());', '            }', '        }', '    }', '', '    private void initJourneyManager() {', '        assert mOverviewModeController != null;', '', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.initJourneyManager"")) {', '            if (ChromeFeatureList.isEnabled(ChromeFeatureList.TAB_ENGAGEMENT_REPORTING_ANDROID)) {', '                // The lifecycle of this object is managed by the lifecycle dispatcher.', '                new JourneyManager(getTabModelSelector(), getLifecycleDispatcher(),', '                        mOverviewModeController, new EngagementTimeUtil());', '            }', '        }', '    }', '', '    @Override', '    public void onNewIntent(Intent intent) {', ""        // The intent to use in maybeDispatchExplicitMainViewIntent(). We're explicitly"", '        // adding NEW_TASK flag to make sure backing from CCT brings up the caller activity,', '        // and not Chrome', '        Intent intentForDispatching = new Intent(intent);', '        intentForDispatching.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);', '        @LaunchIntentDispatcher.Action', '        int action = maybeDispatchExplicitMainViewIntent(', '                intentForDispatching, DispatchedBy.ON_NEW_INTENT);', '        if (action != LaunchIntentDispatcher.Action.CONTINUE) {', '            // Pressing back button in CCT should bring user to the caller activity.', '            moveTaskToBack(true);', '            // Intent was dispatched to CustomTabActivity, consume it.', '            return;', '        }', '', '        mIntentHandlingTimeMs = SystemClock.uptimeMillis();', '        super.onNewIntent(intent);', '    }', '', '    @Override', '    public void startNativeInitialization() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.startNativeInitialization"")) {', ""            // This is on the critical path so don't delay."", '            if (ChromeFeatureList.isEnabled(', '                        ChromeFeatureList.DARKEN_WEBSITES_CHECKBOX_IN_THEMES_SETTING)) {', '                WebContentsDarkModeController.createInstance();', '            }', '            setupCompositorContentPostNative();', '', ""            // All this initialization can be expensive so it's split into multiple tasks."", '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::refreshSignIn));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::initializeToolbarManager));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::maybeCreateIncognitoTabSnapshotController));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::onAccessibilityTabSwitcherModeChanged));', '', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::initJourneyManager));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::finishNativeInitialization));', '            ChromeAccessibilityUtil.get().addObserver(this);', '        }', '    }', '', '    @Override', '    public void finishNativeInitialization() {', '        super.finishNativeInitialization();', '', '        // TODO(jinsukkim): Let these classes handle the registration by themselves.', '        mCompositorViewHolder = getCompositorViewHolderSupplier().get();', '        mOverviewListLayout = (OverviewListLayout) mLayoutManager.getOverviewListLayout();', '        getTabObscuringHandler().addObserver(mCompositorViewHolder);', '        getTabObscuringHandler().addObserver(mOverviewListLayout);', '', '        ChromeAccessibilityUtil.get().addObserver(mLayoutManager);', '        if (isTablet()) ChromeAccessibilityUtil.get().addObserver(mCompositorViewHolder);', '    }', '', '    @Override', '    public void onResumeWithNative() {', '        super.onResumeWithNative();', '', '        IncognitoStartup.onResumeWithNative(', '                getTabModelSelectorSupplier(), TABBED_MODE_COMPONENT_NAMES);', '', '        mLocaleManager.setSnackbarManager(getSnackbarManager());', '        mLocaleManager.startObservingPhoneChanges();', '', '        if (isWarmOnResume()) {', '            NavigationPredictorBridge.onActivityWarmResumed();', '        } else {', '            NavigationPredictorBridge.onColdStart();', '        }', '', '        // This call is not guarded by a feature flag.', '        SearchEngineChoiceNotification.handleSearchEngineChoice(', '                this, getSnackbarManager(), SETTINGS_LAUNCHER);', '', '        if (!isWarmOnResume()) {', '            SuggestionsMetrics.recordArticlesListVisible();', '        }', '    }', '', '    @Override', '    public void onPauseWithNative() {', '        mTabModelSelector.commitAllTabClosures();', '        CookiesFetcher.persistCookies();', '', '        mLocaleManager.setSnackbarManager(null);', '        mLocaleManager.stopObservingPhoneChanges();', '', '        NavigationPredictorBridge.onPause();', '', '        super.onPauseWithNative();', '    }', '', '    @Override', '    public void onStopWithNative() {', '        super.onStopWithNative();', '', '        mTabModelOrchestrator.saveState();', '        mHasDeterminedOverviewStateForCurrentSession = false;', '    }', '', '    @Override', '    public void onStartWithNative() {', '        mMainIntentMetrics.logLaunchBehavior();', '        super.onStartWithNative();', '', ""        // Don't call setInitialOverviewState if we're waiting for the tab's creation or we risk"", '        // showing a glimpse of the tab selector during start up.', '        if (!mPendingInitialTabCreation) {', '            setInitialOverviewState();', '        }', '', '        if (TabUiFeatureUtilities.isConditionalTabStripEnabled()', '                || ConditionalTabStripUtils.getOptOutIndicator()) {', '            ConditionalTabStripUtils.updateFeatureExpiration(', '                    mInactivityTracker.getLastBackgroundedTimeMs());', '        }', '', '        Bundle savedInstanceState = getSavedInstanceState();', '        if (savedInstanceState != null', '                && savedInstanceState.getBoolean(IS_INCOGNITO_SELECTED, false)) {', '            // This will be executed only once since SavedInstanceState will be reset a few lines', '            // later.', '            AndroidSessionDurationsServiceState.restoreNativeFromSerialized(savedInstanceState,', '                    getCurrentTabModel().getProfile().getPrimaryOTRProfile(', '                            /* createIfNeeded= */ true));', '        }', '', '        resetSavedInstanceState();', '        StartSurfaceConfiguration.addFeedVisibilityObserver();', '        BookmarkUtils.maybeExpireLastBookmarkLocationForReadLater(', '                mInactivityTracker.getTimeSinceLastBackgroundedMs());', '    }', '', '    @Override', '    public void onNewIntentWithNative(Intent intent) {', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.onNewIntentWithNative"");', '', '            super.onNewIntentWithNative(intent);', '            if (IntentUtils.isMainIntentFromLauncher(intent)) {', '                logMainIntentBehavior(intent);', '            }', '', '            if (CommandLine.getInstance().hasSwitch(ContentSwitches.ENABLE_TEST_INTENTS)) {', '                handleDebugIntent(intent);', '            }', '', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.onNewIntentWithNative"");', '        }', '    }', '', '    @Override', '    public @ActivityType int getActivityType() {', '        return ActivityType.TABBED;', '    }', '', '    @Override', '    public ChromeTabCreator getTabCreator(boolean incognito) {', '        return (ChromeTabCreator) super.getTabCreator(incognito);', '    }', '', '    @Override', '    public ChromeTabCreator getCurrentTabCreator() {', '        return (ChromeTabCreator) super.getCurrentTabCreator();', '    }', '', '    @Override', '    public OverviewModeBehavior getOverviewModeBehavior() {', '        return mOverviewModeController;', '    }', '', '    @Override', '    public @Nullable OneshotSupplier<OverviewModeBehavior> getOverviewModeBehaviorSupplier() {', '        return mOverviewModeBehaviorSupplier;', '    }', '', '    /**', '     * @return The toolbar button in-product help controller for this activity.', '     * TODO(pnoland, https://crbug.com/865801): remove this in favor', ""     *        of injecting the controller directly where it's needed."", '     */', '    public ToolbarButtonInProductHelpController getToolbarButtonInProductHelpController() {', '        return ((TabbedRootUiCoordinator) mRootUiCoordinator)', '                .getToolbarButtonInProductHelpController();', '    }', '', '    private void handleDebugIntent(Intent intent) {', '        if (ACTION_CLOSE_TABS.equals(intent.getAction())) {', '            getTabModelSelector().closeAllTabs();', '        } else if (MemoryPressureListener.handleDebugIntent(', '                           ChromeTabbedActivity.this, intent.getAction())) {', '            // Handled.', '        }', '    }', '', '    private void setTrackColdStartupMetrics(boolean shouldTrackColdStartupMetrics) {', '        assert getActivityTabStartupMetricsTracker() != null;', '', '        if (shouldTrackColdStartupMetrics) {', '            getActivityTabStartupMetricsTracker().trackStartupMetrics(STARTUP_UMA_HISTOGRAM_SUFFIX);', '        } else {', '            getActivityTabStartupMetricsTracker().cancelTrackingStartupMetrics();', '        }', '', '        // Paint Preview should follow the same logic as startup UMA histograms as the feature', '        // should only run on cold startup of Chrome when the user is unable to interact before', '        // entering a tab.', '        StartupPaintPreviewHelper.setShouldShowOnRestore(shouldTrackColdStartupMetrics);', '    }', '', '    private void setInitialOverviewState() {', '        if (mHasDeterminedOverviewStateForCurrentSession) return;', '', '        mHasDeterminedOverviewStateForCurrentSession = true;', '        boolean isOverviewVisible = mOverviewModeController.overviewVisible();', '', '        if (shouldRefreshAndShowOverview(isOverviewVisible)) {', '            if (getCurrentTabModel() != null) {', '                RecordHistogram.recordCountHistogram(', '                        TAB_COUNT_ON_RETURN, getCurrentTabModel().getCount());', '            }', '            if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(this) && !isTablet()) {', '                mStartSurfaceSupplier.get().getController().enableRecordingFirstMeaningfulPaint(', '                        getOnCreateTimestampMs());', '            }', '            mOverviewShownOnStart = true;', '            // Cancel recording cold startup metrics if an overview is shown as they expect a tab to', '            // be the first thing shown after startup.', '            setTrackColdStartupMetrics(false);', '            showOverview(StartSurfaceState.SHOWING_START);', '            return;', '        }', '', '        if (getActivityTab() == null && !isOverviewVisible) {', '            mOverviewShownOnStart = true;', '            // Cancel recording cold startup metrics if an overview is shown as they expect a tab to', '            // be the first thing shown after startup.', '            setTrackColdStartupMetrics(false);', '            showOverview(StartSurfaceState.SHOWING_START);', '        }', '', '        if (IntentUtils.isMainIntentFromLauncher(getIntent())', '                && mOverviewModeController.overviewVisible()) {', '            RecordUserAction.record(""MobileStartup.UserEnteredTabSwitcher"");', '        }', '    }', '', '    private boolean shouldRefreshAndShowOverview(boolean isOverviewVisible) {', '        // If StartSurfaceConfiguration.NEW_SURFACE_FROM_HOME_BUTTON is turned on, MV tiles and', '        // carousels may be hidden before Chrome is brought to the background. If overview should be', '        // shown, no matter overview was already visible or not, we should call', '        // showOverview(StartSurfaceState.SHOWING_START) to show MV tiles and carousels again.', '        return shouldShowOverviewPageOnStart()', '                && (!isOverviewVisible', '                        || StartSurfaceConfiguration.shouldShowNewSurfaceFromHomeButton());', '    }', '', '    /**', '     * Returns whether grid Tab switcher or the Start surface should be shown at startup.', '     */', '    private boolean shouldShowOverviewPageOnStart() {', '        return ReturnToChromeExperimentsUtil.shouldShowOverviewPageOnStart(', '                this, getIntent(), getTabModelSelector(), mInactivityTracker);', '    }', '', '    private void logMainIntentBehavior(Intent intent) {', '        assert IntentUtils.isMainIntentFromLauncher(intent);', '        // TODO(tedchoc): We should cache the last visible time and reuse it to avoid different', '        //                values of this depending on when it is called after the activity was', '        //                shown.', '', '        // Temporary safety check to make sure none of this code runs if the feature is', '        // disabled.', '        if (ReengagementNotificationController.isEnabled()) {', '            if (mCallbackController != null) {', '                new OneShotCallback<>(', '                        mTabModelProfileSupplier, mCallbackController.makeCancelable(profile -> {', '                            assert profile != null : ""Unexpectedly null profile from TabModel."";', '                            if (profile == null) return;', '', '                            TrackerFactory.getTrackerForProfile(profile).notifyEvent(', '                                    EventConstants.STARTED_FROM_MAIN_INTENT);', '                        }));', '            }', '        }', '', '        mMainIntentMetrics.onMainIntentWithNative(', '                mInactivityTracker.getTimeSinceLastBackgroundedMs());', '    }', '', '    /** Access the main intent metrics for test validation. */', '    @VisibleForTesting', '    public MainIntentBehaviorMetrics getMainIntentBehaviorMetricsForTesting() {', '        return mMainIntentMetrics;', '    }', '', '    @VisibleForTesting', '    public ChromeInactivityTracker getInactivityTrackerForTesting() {', '        return mInactivityTracker;', '    }', '', '    @Override', '    public void initializeState() {', '        // This method goes through 3 steps:', ""        // 1. Load the saved tab state (but don't start restoring the tabs yet)."", '        // 2. Process the Intent that this activity received and if that should result in any', '        //    new tabs, create them.  This is done after step 1 so that the new tab gets', '        //    created after previous tab state was restored.', '        // 3. If no tabs were created in any of the above steps, create an NTP, otherwise', '        //    start asynchronous tab restore (loading the previously active tab synchronously', '        //    if no new tabs created in step 2).', '', '        // Only look at the original intent if this is not a ""restoration"" and we are allowed to', '        // process intents. Any subsequent intents are carried through onNewIntent.', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.initializeState"");', '', '            super.initializeState();', '            Log.i(TAG, ""#initializeState"");', '            Intent intent = getIntent();', '', '            boolean hadCipherData =', '                    CipherFactory.getInstance().restoreFromBundle(getSavedInstanceState());', '', '            boolean noRestoreState =', '                    CommandLine.getInstance().hasSwitch(ChromeSwitches.NO_RESTORE_STATE);', '            if (noRestoreState) {', '                // Clear the state files because they are inconsistent and useless from now on.', '                mTabModelOrchestrator.clearState();', '            } else {', '                // State should be clear when we start first run and hence we do not need to load', '                // a previous state. This may change the current Model, watch out for initialization', '                // based on the model.', '                // Never attempt to restore incognito tabs when this activity was previously swiped', '                // away in Recents. http://crbug.com/626629', '                boolean ignoreIncognitoFiles = !hadCipherData;', '                mTabModelOrchestrator.loadState(ignoreIncognitoFiles);', '            }', '', '            mInactivityTracker.register(this.getLifecycleDispatcher());', '            boolean isIntentWithEffect = false;', '            boolean isMainIntentFromLauncher = false;', '            if (getSavedInstanceState() == null && intent != null) {', '                if (!shouldIgnoreIntent()) {', '                    isIntentWithEffect = mIntentHandler.onNewIntent(intent);', '                }', '', '                if (IntentUtils.isMainIntentFromLauncher(intent)) {', '                    isMainIntentFromLauncher = true;', '                    logMainIntentBehavior(intent);', '                }', '            }', '', '            mIntentMetadataOneshotSupplier.set(', '                    new ToolbarIntentMetadata(isMainIntentFromLauncher, isIntentWithEffect));', '', '            // If we have tabs to reparent and getSavedInstanceState() is non-null, then the tabs', '            // are coming from night mode tab reparenting. In this case, reparenting happens', '            // synchronously along with tab restoration so there are no tabs waiting for', '            // reparenting like there are for other tab reparenting operations.', '            boolean hasTabWaitingForReparenting =', '                    AsyncTabParamsManagerSingleton.getInstance().hasParamsWithTabToReparent()', '                    && getSavedInstanceState() == null;', '            mCreatedTabOnStartup = getCurrentTabModel().getCount() > 0', '                    || mTabModelOrchestrator.getRestoredTabCount() > 0 || isIntentWithEffect', '                    || hasTabWaitingForReparenting;', '', '            // We always need to try to restore tabs. The set of tabs might be empty, but at least', '            // it will trigger the notification that tab restore is complete which is needed by', '            // other parts of Chrome such as sync.', '            boolean activeTabBeingRestored = !isIntentWithEffect', '                    || (shouldShowOverviewPageOnStart()', '                            && !mTabModelSelector.isIncognitoSelected());', '', '            mTabModelOrchestrator.restoreTabs(activeTabBeingRestored);', '', '            // Only create an initial tab if no tabs were restored and no intent was handled.', '            // Also, check whether the active tab was supposed to be restored and that the total', '            // tab count is now non zero.  If this is not the case, tab restore failed and we need', '            // to create a new tab as well.', '            if (!mCreatedTabOnStartup', '                    || (!hasTabWaitingForReparenting && activeTabBeingRestored', '                            && getTabModelSelector().getTotalTabCount() == 0)) {', '                // If homepage URI is not determined, due to PartnerBrowserCustomizations provider', '                // async reading, then create a tab at the async reading finished. If it takes', '                // too long, just create NTP.', '', '                mPendingInitialTabCreation = true;', '                PartnerBrowserCustomizations.getInstance().setOnInitializeAsyncFinished(() -> {', '                    if (!isActivityFinishingOrDestroyed()) {', '                        createInitialTab();', '                    }', '                }, INITIAL_TAB_CREATION_TIMEOUT_MS);', '            }', '', '            // If initial tab creation is pending, this will instead be handled when we create the', '            // initial tab in #createInitialTab.', '            if (!mPendingInitialTabCreation) {', '                mAppLaunchDrawBlocker.onActiveTabAvailable(isTabRegularNtp(getActivityTab()));', '            }', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.initializeState"");', '        }', '    }', '', '    private boolean hasStartWithNativeBeenCalled() {', '        int activity_state = getLifecycleDispatcher().getCurrentActivityState();', '        return activity_state == ActivityLifecycleDispatcher.ActivityState.STARTED_WITH_NATIVE', '                || activity_state == ActivityLifecycleDispatcher.ActivityState.RESUMED_WITH_NATIVE;', '    }', '', '    /**', '     * Create an initial tab for cold start without restored tabs.', '     */', '    private void createInitialTab() {', '        Log.i(TAG, ""#createInitialTab executed."");', '        mPendingInitialTabCreation = false;', '', '        // If the start surface or grid tab switcher will be shown on start, do not create a new', '        // tab.', '        if (!shouldShowOverviewPageOnStart()) {', '            String url = HomepageManager.getHomepageUri();', '            if (TextUtils.isEmpty(url)) {', '                url = UrlConstants.NTP_URL;', '            } else {', '                // Migrate legacy NTP URLs (chrome://newtab) to the newer format', '                // (chrome-native://newtab)', '                if (UrlUtilities.isNTPUrl(url)) {', '                    url = UrlConstants.NTP_URL;', '                }', '            }', '', '            getTabCreator(false).launchUrl(url, TabLaunchType.FROM_STARTUP);', '        }', '', ""        // If we didn't call setInitialOverviewState() in onStartWithNative() because"", '        // mPendingInitialTabCreation was true then do so now.', '        if (hasStartWithNativeBeenCalled()) {', '            setInitialOverviewState();', '        }', '', '        mAppLaunchDrawBlocker.onActiveTabAvailable(isTabRegularNtp(getActivityTab()));', '    }', '', '    @Override', '    public void onAccessibilityModeChanged(boolean enabled) {', '        onAccessibilityTabSwitcherModeChanged();', '    }', '', '    private void onAccessibilityTabSwitcherModeChanged() {', '        if (!mUIWithNativeInitialized) return;', '', '        boolean accessibilityTabSwitcherEnabled =', '                DeviceClassManager.enableAccessibilityLayout(this);', '        if (mOverviewModeController != null && mOverviewModeController.overviewVisible()', '                && (mIsAccessibilityTabSwitcherEnabled == null', '                        || mIsAccessibilityTabSwitcherEnabled', '                                != DeviceClassManager.enableAccessibilityLayout(this))) {', '            /**', '             * If Start surface homepage is showing and launching NTP will show the Start surface', '             * again, skips the calls of hideOverview() and launchNTP(). We need to check', '             * {@link ReturnToChromeExperimentsUtil#shouldShowStartSurfaceHomeAsNTP(Context,', '             * boolean, boolean)} to see whether Start surface can be shown when accessibility is', '             * enabled.', '             */', '            if (mStartSurfaceSupplier.get() == null', '                    || mStartSurfaceSupplier.get().getController().getStartSurfaceState()', '                            != StartSurfaceState.SHOWN_HOMEPAGE', '                    || !ReturnToChromeExperimentsUtil.shouldShowStartSurfaceHomeAsNTP(', '                            this, getCurrentTabModel().isIncognito(), isTablet())) {', '                mOverviewModeController.hideOverview(true);', '                if (getTabModelSelector().getCurrentModel().getCount() == 0) {', '                    getCurrentTabCreator().launchNTP();', '                }', '            }', '        }', '        mIsAccessibilityTabSwitcherEnabled = accessibilityTabSwitcherEnabled;', '', '        if (ChromeAccessibilityUtil.get().isAccessibilityEnabled()) {', '            RecordHistogram.recordBooleanHistogram(', '                    ""Accessibility.Android.TabSwitcherPreferenceEnabled"",', '                    mIsAccessibilityTabSwitcherEnabled);', '        }', '    }', '', '    /**', '     * Internal class which performs the intent handling operations delegated by IntentHandler.', '     */', '    private class InternalIntentDelegate implements IntentHandler.IntentHandlerDelegate {', '        /**', '         * Processes a url view intent.', '         *', '         * @param url The url from the intent.', '         */', '        @Override', '        public void processUrlViewIntent(LoadUrlParams loadUrlParams, @TabOpenType int tabOpenType,', '                String externalAppId, int tabIdToBringToFront, Intent intent) {', '            if (isActivityFinishingOrDestroyed()) {', '                return;', '            }', '            if (isFromChrome(intent, externalAppId)) {', '                RecordUserAction.record(""MobileTabbedModeViewIntentFromChrome"");', '            } else {', '                RecordUserAction.record(""MobileTabbedModeViewIntentFromApp"");', '            }', '', '            final String url = loadUrlParams.getUrl();', '            boolean fromLauncherShortcut = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_INVOKED_FROM_SHORTCUT, false);', '            boolean fromAppWidget = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_INVOKED_FROM_APP_WIDGET, false);', '            boolean focus = false;', '', '            TabModel tabModel = getCurrentTabModel();', '            switch (tabOpenType) {', '                case TabOpenType.REUSE_URL_MATCHING_TAB_ELSE_NEW_TAB:', '                    mTabModelOrchestrator.tryToRestoreTabStateForUrl(url);', '                    int tabToBeClobberedIndex = TabModelUtils.getTabIndexByUrl(tabModel, url);', '                    Tab tabToBeClobbered = tabModel.getTabAt(tabToBeClobberedIndex);', '                    if (tabToBeClobbered != null) {', '                        TabModelUtils.setIndex(tabModel, tabToBeClobberedIndex);', '                        tabToBeClobbered.reload();', '                    } else {', '                        launchIntent(loadUrlParams, externalAppId, true, intent);', '                    }', '                    int shortcutSource = intent.getIntExtra(', '                            WebappConstants.EXTRA_SOURCE, ShortcutSource.UNKNOWN);', '                    LaunchMetrics.recordHomeScreenLaunchIntoTab(url, shortcutSource);', '                    if (fromAppWidget && url.startsWith(UrlConstants.CHROME_DINO_URL)) {', '                        RecordUserAction.record(""QuickActionSearchWidget.StartDinoGame"");', '                    }', '                    break;', '                case TabOpenType.BRING_TAB_TO_FRONT:', '                    mTabModelOrchestrator.tryToRestoreTabStateForId(tabIdToBringToFront);', '', '                    int tabIndex = TabModelUtils.getTabIndexById(tabModel, tabIdToBringToFront);', '                    if (tabIndex == TabModel.INVALID_TAB_INDEX) {', '                        TabModel otherModel =', '                                getTabModelSelector().getModel(!tabModel.isIncognito());', '                        tabIndex = TabModelUtils.getTabIndexById(otherModel, tabIdToBringToFront);', '                        if (tabIndex != TabModel.INVALID_TAB_INDEX) {', '                            getTabModelSelector().selectModel(otherModel.isIncognito());', '                            TabModelUtils.setIndex(otherModel, tabIndex);', '                        } else {', '                            Log.e(TAG, ""Failed to bring tab to front because it doesn\'t exist."");', '                            return;', '                        }', '                    } else {', '                        TabModelUtils.setIndex(tabModel, tabIndex);', '                    }', '                    break;', '                case TabOpenType.CLOBBER_CURRENT_TAB:', '                    // The browser triggered the intent. This happens when clicking links which', '                    // can be handled by other applications (e.g. www.youtube.com links).', '                    Tab currentTab = getActivityTab();', '                    if (currentTab != null) {', '                        RedirectHandlerTabHelper.updateIntentInTab(currentTab, intent);', '                        currentTab.loadUrl(loadUrlParams);', '                    } else {', '                        launchIntent(loadUrlParams, externalAppId, true, intent);', '                    }', '                    break;', '                case TabOpenType.REUSE_APP_ID_MATCHING_TAB_ELSE_NEW_TAB:', '                    launchIntent(loadUrlParams, externalAppId, false, intent);', '                    break;', '                case TabOpenType.REUSE_TAB_MATCHING_ID_ELSE_NEW_TAB:', '                    int tabId = IntentUtils.safeGetIntExtra(', '                            intent, TabOpenType.REUSE_TAB_MATCHING_ID_STRING, Tab.INVALID_TAB_ID);', '                    if (tabId != Tab.INVALID_TAB_ID) {', '                        mTabModelOrchestrator.tryToRestoreTabStateForId(tabId);', '                        int matchingTabIndex = TabModelUtils.getTabIndexById(tabModel, tabId);', '                        boolean loaded = false;', '                        if (matchingTabIndex != TabModel.INVALID_TAB_INDEX) {', '                            Tab tab = tabModel.getTabAt(matchingTabIndex);', '                            if (tab.getUrl().getSpec().equals(url)', '                                    || tab.getUrl().getSpec().equals(IntentUtils.safeGetStringExtra(', '                                            intent, TabOpenType.REUSE_TAB_ORIGINAL_URL_STRING))) {', '                                tabModel.setIndex(matchingTabIndex, TabSelectionType.FROM_USER);', '                                tab.loadUrl(loadUrlParams);', '                                loaded = true;', '                            }', '                        }', '                        if (!loaded) {', '                            launchIntent(loadUrlParams, externalAppId, false, intent);', '                        }', '                    }', '                    break;', '                case TabOpenType.OPEN_NEW_TAB:', '                    if (fromLauncherShortcut) {', '                        recordLauncherShortcutAction(false);', '                        reportNewTabShortcutUsed(false);', '                    }', '', '                    launchIntent(loadUrlParams, externalAppId, true, intent);', '                    break;', '                case TabOpenType.OPEN_NEW_INCOGNITO_TAB:', '                    if (!TextUtils.equals(externalAppId, getPackageName())) {', '                        assert false : ""Only Chrome is allowed to open incognito tabs"";', '                        Log.e(TAG, ""Only Chrome is allowed to open incognito tabs"");', '                        return;', '                    }', '', '                    if (!IncognitoUtils.isIncognitoModeEnabled()) {', '                        // The incognito launcher shortcut is manipulated in #onDeferredStartup(),', ""                        // so it's possible for a user to invoke the shortcut before it's disabled."", '                        // Quick actions search widget is installed on the home screen and may', '                        // need to be updated before the incognito button is removed.', '                        // Opening an incognito tab while incognito mode is disabled from somewhere', '                        // besides the launcher shortcut of from quick action search widget is an', '                        // error.', '                        if (fromAppWidget || fromLauncherShortcut) {', '                            // We are using the message introduced for quick action search widget', '                            // for both the widget and the launcher shortcut here.', '                            Toast.makeText(ChromeTabbedActivity.this,', '                                         R.string.quick_action_search_widget_message_no_incognito,', '                                         Toast.LENGTH_LONG)', '                                    .show();', '                        } else {', '                            assert false : ""Tried to open incognito tab while incognito disabled"";', '                            Log.e(TAG, ""Tried to open incognito tab while incognito disabled"");', '                        }', '', '                        return;', '                    }', '', '                    if (url == null || url.equals(UrlConstants.NTP_URL)) {', '                        if (fromLauncherShortcut) {', '                            getTabCreator(true).launchUrl(', '                                    UrlConstants.NTP_URL, TabLaunchType.FROM_LAUNCHER_SHORTCUT);', '                            recordLauncherShortcutAction(true);', '                            reportNewTabShortcutUsed(true);', '                        } else if (fromAppWidget) {', '                            RecordUserAction.record(""QuickActionSearchWidget.StartIncognito"");', '                            getTabCreator(true).launchUrl(', '                                    UrlConstants.NTP_URL, TabLaunchType.FROM_APP_WIDGET);', '                        } else if (IncognitoTabLauncher.didCreateIntent(intent)) {', '                            Tab tab = getTabCreator(true).launchUrl(UrlConstants.NTP_URL,', '                                    TabLaunchType.FROM_LAUNCH_NEW_INCOGNITO_TAB);', '                            if (IncognitoTabLauncher.shouldFocusOmnibox(intent)) {', '                                // Since the Tab is created in the foreground, its View will gain', '                                // focus, and since the Tab and the URL bar are not yet in the same', ""                                // View hierarchy, setting the URL bar's focus here won't clear the"", ""                                // Tab's focus. When the Tab is added to the hierarchy, we want the"", ""                                // URL bar to retain focus, so we clear the Tab's focus here."", '                                tab.getView().clearFocus();', '                                focus = true;', '                            }', '', '                            IncognitoTabLauncher.recordUse();', '                        } else {', '                            // Used by the Account management screen to open a new incognito tab.', '                            // Account management screen collects its metrics separately.', '                            getTabCreator(true).launchUrl(UrlConstants.NTP_URL,', '                                    TabLaunchType.FROM_CHROME_UI, intent, mIntentHandlingTimeMs);', '                        }', '                    } else {', '                        @TabLaunchType', '                        Integer launchType = IntentHandler.getTabLaunchType(intent);', '                        if (launchType == null) launchType = TabLaunchType.FROM_LINK;', '                        getTabCreator(true).launchUrl(', '                                url, launchType, intent, mIntentHandlingTimeMs);', '                    }', '                    break;', '                default:', '                    assert false : ""Unknown TabOpenType: "" + tabOpenType;', '                    break;', '            }', '', '            getToolbarManager().setUrlBarFocusOnceNativeInitialized(focus,', '                    focus ? OmniboxFocusReason.LAUNCH_NEW_INCOGNITO_TAB', '                          : OmniboxFocusReason.UNFOCUS);', '', '            if (tabModel.getCount() > 0 && isInOverviewMode() && !isTablet()', '                    && !shouldShowOverviewPageOnStart()) {', '                mOverviewModeController.hideOverview(true);', '            }', '        }', '', '        @Override', '        public long getIntentHandlingTimeMs() {', '            return mIntentHandlingTimeMs;', '        }', '', '        @Override', '        public void processWebSearchIntent(String query) {', '            assert false;', '        }', '', '        @Override', '        public void processTranslateTabIntent(', '                @Nullable String targetLanguageCode, @Nullable String expectedUrl) {', '            TranslateIntentHandler.translateTab(getActivityTab(), targetLanguageCode, expectedUrl);', '        }', '', '        private boolean isFromChrome(Intent intent, String externalAppId) {', '            // To determine if the processed intent is from Chrome, check for any of the following:', '            // 1.) The authentication token that will be added to trusted intents.', '            // 2.) The app ID matches Chrome.  This value can be spoofed by other applications, but', '            //     in cases where we were not able to add the authentication token this is our only', '            //     indication the intent was from Chrome.', '            return IntentHandler.wasIntentSenderChrome(intent)', '                    || TextUtils.equals(externalAppId, getPackageName());', '        }', '    }', '', '    @Override', '    public void performPreInflationStartup() {', '        // Create JankTracker before invoking super, because the parent class will invoke', '        // createRootUiCoordinator(...), which in our case requires the JankTracker to already have', '        // been created.', '        mJankTracker = new JankTrackerImpl(this);', '', '        super.performPreInflationStartup();', '', '        // Decide whether to record startup UMA histograms. This is done  early in the main', '        // Activity.onCreate() to avoid recording navigation delays when they require user input to', '        // proceed. For example, FRE (First Run Experience) happens before the activity is created,', '        // and triggers initialization of the native library.', '        //', '        // An uninitialized native library is an indication of an application start that is followed', '        // by navigation immediately without user input.', '        if (!LibraryLoader.getInstance().isInitialized()) {', '            setTrackColdStartupMetrics(true);', '        }', '', '        supportRequestWindowFeature(Window.FEATURE_ACTION_MODE_OVERLAY);', '', '        IncognitoTabHostRegistry.getInstance().register(mIncognitoTabHost);', '', '        mStartupPaintPreviewHelperSupplier.attach(getWindowAndroid().getUnownedUserDataHost());', '    }', '', '    @Override', '    protected RootUiCoordinator createRootUiCoordinator() {', '        return new TabbedRootUiCoordinator(this, this::onOmniboxFocusChanged,', '                getShareDelegateSupplier(), getActivityTabProvider(), mTabModelProfileSupplier,', '                mBookmarkBridgeSupplier, this::getContextualSearchManager,', '                getTabModelSelectorSupplier(), mStartSurfaceSupplier,', '                mIntentMetadataOneshotSupplier, mLayoutStateProviderOneshotSupplier,', '                mStartSurfaceParentTabSupplier, getBrowserControlsManager(), getWindowAndroid(),', '                mJankTracker, getLifecycleDispatcher(), getLayoutManagerSupplier(),', '                /* menuOrKeyboardActionController= */ this, this::getActivityThemeColor,', '                getModalDialogManagerSupplier(), /* appMenuBlocker= */ this, this::supportsAppMenu,', '                this::supportsFindInPage, getTabCreatorManagerSupplier(), getFullscreenManager(),', '                getCompositorViewHolderSupplier(), getTabContentManagerSupplier(),', '                getOverviewModeBehaviorSupplier(), this::getSnackbarManager, getActivityType(),', '                this::isInOverviewMode, this::isWarmOnResume,', '                /* appMenuDelegate= */ this, /* statusBarColorProvider= */ this,', '                mEphemeralTabCoordinatorSupplier, getIntentRequestTracker(),', '                getControlContainerHeightResource(), this::getInsetObserverView,', '                this::backShouldCloseTab);', '    }', '', '    @Override', '    protected int getControlContainerLayoutId() {', '        return R.layout.control_container;', '    }', '', '    @Override', '    public int getControlContainerHeightResource() {', '        return R.dimen.control_container_height;', '    }', '', '    @Override', '    protected int getToolbarLayoutId() {', '        return isTablet() ? R.layout.toolbar_tablet : R.layout.toolbar_phone;', '    }', '', '    @Override', '    protected int getToolbarShadowResource() {', '        final boolean themeRefactorEnabled =', '                CachedFeatureFlags.isEnabled(ChromeFeatureList.THEME_REFACTOR_ANDROID);', '        return themeRefactorEnabled ? R.drawable.toolbar_hairline', '                                    : R.drawable.modern_toolbar_shadow;', '    }', '', '    @Override', '    protected int getToolbarShadowLayoutHeight() {', '        final int res = CachedFeatureFlags.isEnabled(ChromeFeatureList.THEME_REFACTOR_ANDROID)', '                ? R.dimen.toolbar_hairline_height', '                : R.dimen.toolbar_shadow_height;', '        return getResources().getDimensionPixelSize(res);', '    }', '', '    @Override', '    public void performPostInflationStartup() {', '        super.performPostInflationStartup();', '', '        FontPreloader.getInstance().onPostInflationStartupTabbedActivity();', '', '        TabModelSelector tabModelSelector = getTabModelSelector();', '        IncognitoProfileDestroyer.observeTabModelSelector(tabModelSelector);', '        IncognitoNotificationPresenceController.observeTabModelSelector(tabModelSelector);', '', '        // Critical path for startup. Create the minimum objects needed', '        // to allow a blank screen draw (without depending on any native code)', '        // and then yield ASAP.', '        if (isFinishing()) return;', '', ""        // Don't show the keyboard until user clicks in."", '        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN', '                | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);', '', '        mContentContainer = (ViewGroup) findViewById(android.R.id.content);', '        mControlContainer = (ToolbarControlContainer) findViewById(R.id.control_container);', '', '        Supplier<Boolean> dialogVisibilitySupplier = null;', '        if (TabUiFeatureUtilities.isTabGroupsAndroidEnabled(this)) {', '            dialogVisibilitySupplier = () -> {', '                assert mStartSurfaceSupplier.get() != null;', '                assert getToolbarManager().getTabGroupUi() != null;', '                // Return true if dialog from either tab switcher or tab strip is visible.', '', '                ToolbarManager toolbarManager = getToolbarManager();', '                TabGroupUi tabGroupUi = toolbarManager.getTabGroupUi();', '                boolean isDialogVisible = tabGroupUi.isTabGridDialogVisible();', '', '                Supplier<Boolean> tabSwitcherDialogVisibilitySupplier =', '                        mStartSurfaceSupplier.get().getTabGridDialogVisibilitySupplier();', '', '                if (tabSwitcherDialogVisibilitySupplier != null) {', '                    isDialogVisible = isDialogVisible || tabSwitcherDialogVisibilitySupplier.get();', '                }', '                return isDialogVisible;', '            };', '        }', '', '        mUndoBarPopupController = new UndoBarController(this, mTabModelSelector,', '                this::getSnackbarManager, mOverviewModeBehaviorSupplier, dialogVisibilitySupplier);', '', '        mInactivityTracker = new ChromeInactivityTracker(', '                ChromePreferenceKeys.TABBED_ACTIVITY_LAST_BACKGROUNDED_TIME_MS_PREF);', '', '        assert getActivityTabStartupMetricsTracker() != null;', '        if (StartupPaintPreviewHelper.isEnabled()) {', '            StartupPaintPreviewHelper paintPreviewHelper = new StartupPaintPreviewHelper(', '                    getWindowAndroid(), getOnCreateTimestampMs(), getBrowserControlsManager(),', '                    getTabModelSelector(), shouldShowOverviewPageOnStart(), () -> {', '                        return getToolbarManager() == null', '                                ? null', '                                : getToolbarManager().getProgressBarCoordinator();', '                    });', '            mStartupPaintPreviewHelperSupplier.set(paintPreviewHelper);', '            getActivityTabStartupMetricsTracker().registerPaintPreviewObserver(paintPreviewHelper);', '        }', '    }', '', '    private boolean shouldIgnoreIntent() {', '        if (mShouldIgnoreIntent == null) {', '            // We call this only once because mIntentHandler#shouldIgnoreIntent has side effects.', '            mShouldIgnoreIntent =', '                    mIntentHandler.shouldIgnoreIntent(getIntent(), /*startedActivity=*/true);', '        }', '        return mShouldIgnoreIntent;', '    }', '', '    @Override', '    protected final void dispatchOnInflationComplete() {', '        super.dispatchOnInflationComplete();', '', '        // When the feature flag {@link ChromeFeatureList.INSTANT_START} turns on phones (not', '        // tablet), a view-only start page created on Java will be shown before native is', '        // initialized. The {@link prepareToShowStartPagePreNative()} is only called in a cold', '        // start.', '        if (ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()', '                && TabUiFeatureUtilities.supportInstantStart(isTablet(), this) && !hadWarmStart()) {', '            prepareToShowStartPagePreNative();', '        }', '    }', '', '    /**', '     * Prepares to show the start page before native is initialized. For example, create', '     * an LayoutManagerChrome object, add overview mode observer and so on.', '     */', '    private void prepareToShowStartPagePreNative() {', '        assert TabUiFeatureUtilities.supportInstantStart(isTablet() && !hadWarmStart(), this);', '        try (TraceEvent e =', '                        TraceEvent.scoped(""ChromeTabbedActivity.prepareToShowStartPagePreNative"")) {', '            setupCompositorContentPreNativeForPhone();', '            getCompositorViewHolderSupplier().get().setLayoutManager(mLayoutManager);', '', '            if (shouldShowOverviewPageOnStart()) {', '                mLayoutManager.setTabModelSelector(mTabModelSelector);', '                mIsAccessibilityTabSwitcherEnabled =', '                        DeviceClassManager.enableAccessibilityLayout(this);', '                assert !mHasDeterminedOverviewStateForCurrentSession;', '                setInitialOverviewState();', '            }', '        }', '    }', '', '    @Override', '    protected TabModelOrchestrator createTabModelOrchestrator() {', '        boolean tabMergingEnabled =', '                mMultiInstanceManager != null && mMultiInstanceManager.isTabModelMergingEnabled();', '        mTabModelOrchestrator = new TabbedModeTabModelOrchestrator(tabMergingEnabled);', '        return mTabModelOrchestrator;', '    }', '', '    @Override', '    protected void createTabModels() {', '        assert mTabModelSelector == null;', '        assert mWindowId != INVALID_WINDOW_ID;', '', '        Bundle savedInstanceState = getSavedInstanceState();', '', '        // We determine the model as soon as possible so every systems get initialized coherently.', '        boolean startIncognito = savedInstanceState != null', '                && savedInstanceState.getBoolean(IS_INCOGNITO_SELECTED, false);', '', '        mNextTabPolicySupplier = new ChromeNextTabPolicySupplier(mOverviewModeBehaviorSupplier);', '', '        boolean tabModelWasCreated = mTabModelOrchestrator.createTabModels(', '                this, this, mNextTabPolicySupplier, mWindowId);', '        if (!tabModelWasCreated) {', '            finish();', '            return;', '        }', '', '        if (mMultiInstanceManager != null) {', '            int assignedIndex = TabWindowManagerSingleton.getInstance().getIndexForWindow(this);', '            // The given index and the one computed by TabWindowManager should be one and the same.', '            assert !MultiWindowUtils.isMultiInstanceApi31Enabled() || assignedIndex == mWindowId;', '            mMultiInstanceManager.initialize(assignedIndex, getTaskId());', '        }', '', '        mTabModelSelector = mTabModelOrchestrator.getTabModelSelector();', '        mTabModelSelector.addObserver(new TabModelSelectorObserver() {', '            @Override', '            public void onTabStateInitialized() {', '                if (!mCreatedTabOnStartup) return;', '', '                TabModel model = mTabModelSelector.getModel(false);', '                TasksUma.recordTasksUma(model);', '            }', '        });', '', '        mTabModelSelectorTabObserver = new TabModelSelectorTabObserver(mTabModelSelector) {', '            @Override', '            public void onDidFinishNavigation(Tab tab, NavigationHandle navigation) {', '                if (!navigation.hasCommitted() || !navigation.isInPrimaryMainFrame()) {', '                    return;', '                }', '                DataReductionPromoInfoBar.maybeLaunchPromoInfoBar(ChromeTabbedActivity.this,', '                        tab.getWebContents(), navigation.getUrl(), tab.isShowingErrorPage(),', '                        navigation.isFragmentNavigation(), navigation.httpStatusCode());', '                if (SyncErrorPromptUtils.isMessageUiEnabled()) {', '                    SyncErrorMessage.maybeShowMessageUi(', '                            getWindowAndroid(), ChromeTabbedActivity.this);', '                } else {', '                    SyncErrorInfoBar.maybeLaunchSyncErrorInfoBar(tab.getWebContents());', '                }', '                SendTabToSelfAndroidBridge.updateActiveWebContents(tab.getWebContents());', '            }', '        };', '        mAppIndexingUtil = new AppIndexingUtil(mTabModelSelector);', '', '        if (startIncognito) mTabModelSelector.selectModel(true);', '    }', '', '    @Override', '    protected LaunchCauseMetrics createLaunchCauseMetrics() {', '        return new TabbedActivityLaunchCauseMetrics(this);', '    }', '', '    @Override', '    public AppMenuPropertiesDelegate createAppMenuPropertiesDelegate() {', '        return new TabbedAppMenuPropertiesDelegate(this, getActivityTabProvider(),', '                getMultiWindowModeStateDispatcher(), getTabModelSelector(), getToolbarManager(),', '                getWindow().getDecorView(), this, mOverviewModeBehaviorSupplier,', '                ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()', '                        ? mStartSurfaceSupplier', '                        : null,', '                mBookmarkBridgeSupplier,', '                ()', '                        -> getTabCreator(/*incognito=*/false)', '                                   .launchUrl(NewTabPageUtils.encodeNtpUrl(', '                                                      NewTabPageLaunchOrigin.WEB_FEED),', '                                           TabLaunchType.FROM_CHROME_UI),', '                getModalDialogManager(), getSnackbarManager());', '    }', '', '    private TabDelegateFactory getTabDelegateFactory() {', '        if (mTabDelegateFactory == null) {', '            mTabDelegateFactory = new TabbedModeTabDelegateFactory(this,', '                    getAppBrowserControlsVisibilityDelegate(), getShareDelegateSupplier(),', '                    mEphemeralTabCoordinatorSupplier,', '                    ((TabbedRootUiCoordinator) mRootUiCoordinator)::onContextMenuCopyLink,', '                    mRootUiCoordinator.getBottomSheetController(),', '                    /* ChromeActivityNativeDelegate */ this, /* isCustomTab= */ false,', '                    getBrowserControlsManager(), getFullscreenManager(),', '                    /* TabCreatorManager */ this, getTabModelSelectorSupplier(),', '                    getCompositorViewHolderSupplier(), getModalDialogManagerSupplier(),', '                    this::getSnackbarManager, getBrowserControlsManager(), getActivityTabProvider(),', '                    getLifecycleDispatcher(), getWindowAndroid(), this::getLastUserInteractionTime,', '                    this::hadWarmStart, mJankTracker, getToolbarManager()::getToolbar);', '        }', '        return mTabDelegateFactory;', '    }', '', '    @Override', '    protected Pair<ChromeTabCreator, ChromeTabCreator> createTabCreators() {', '        ChromeTabCreator.OverviewNTPCreator overviewNTPCreator = null;', '', '        if (ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '            overviewNTPCreator = new ChromeTabCreator.OverviewNTPCreator() {', '                @Override', '                public boolean handleCreateNTPIfNeeded(boolean isNTP, boolean incognito,', '                        Tab parentTab, @NewTabPageLaunchOrigin int launchOrigin) {', '                    boolean shouldShowStart =', '                            showStartSurfaceHomeForNTP(isNTP, incognito, parentTab, launchOrigin);', '                    if (shouldShowStart) {', '                        mStartSurfaceParentTabSupplier.set(parentTab);', '                    }', '                    return shouldShowStart;', '                }', '', '                @Override', '                public void preTabInitialization(Tab tab, String url) {', '                    StartSurfaceConfiguration.maySetUserDataForEmptyTab(tab, url);', '                }', '            };', '        }', '        return Pair.create(', '                new ChromeTabCreator(this, getWindowAndroid(), getStartupTabPreloader(),', '                        this::getTabDelegateFactory, false, overviewNTPCreator,', '                        AsyncTabParamsManagerSingleton.getInstance(), getTabModelSelectorSupplier(),', '                        getCompositorViewHolderSupplier()),', '                new ChromeTabCreator(this, getWindowAndroid(), getStartupTabPreloader(),', '                        this::getTabDelegateFactory, true, overviewNTPCreator,', '                        AsyncTabParamsManagerSingleton.getInstance(), getTabModelSelectorSupplier(),', '                        getCompositorViewHolderSupplier()));', '    }', '', '    @Override', '    protected void initDeferredStartupForActivity() {', '        super.initDeferredStartupForActivity();', '        DeferredStartupHandler.getInstance().addDeferredTask(() -> {', '            ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);', '            RecordHistogram.recordSparseHistogram(', '                    ""MemoryAndroid.DeviceMemoryClass"", am.getMemoryClass());', '', '            LauncherShortcutActivity.updateIncognitoShortcut(ChromeTabbedActivity.this);', '', '            ChromeSurveyController.initialize(mTabModelSelector, getLifecycleDispatcher(),', '                    ChromeTabbedActivity.this, MessageDispatcherProvider.from(getWindowAndroid()));', '', '            if (mStartSurfaceSupplier.get() != null) {', '                mStartSurfaceSupplier.get().onOverviewShownAtLaunch(', '                        mOverviewShownOnStart, getOnCreateTimestampMs());', '            }', '        });', '    }', '', '    @Override', '    protected void recordIntentToCreationTime(long timeMs) {', '        super.recordIntentToCreationTime(timeMs);', '        RecordHistogram.recordCustomTimesHistogram(""MobileStartup.IntentToCreationTime.TabbedMode"",', '                timeMs, 1, DateUtils.SECOND_IN_MILLIS * 30, 50);', '    }', '', '    @Override', '    protected boolean isStartedUpCorrectly(Intent intent) {', '        mWindowId = 0;', '        Bundle savedInstanceState = getSavedInstanceState();', '        int windowId = getExtraWindowIdFromIntent(intent);', '        if (savedInstanceState != null && savedInstanceState.containsKey(WINDOW_INDEX)) {', '            // Activity is recreated after destruction. |windowId| must not be valid in this case.', '            assert windowId == INVALID_WINDOW_ID;', '            mWindowId = savedInstanceState.getInt(WINDOW_INDEX, 0);', '        } else if (mMultiInstanceManager != null) {', ""            // |allocInstanceId| doesn't do any disk I/O that would add a long-running task"", '            // to pre-inflation startup.', '            boolean preferNew = getExtraPreferNewFromIntent(intent);', '            mWindowId = mMultiInstanceManager.allocInstanceId(windowId, getTaskId(), preferNew);', '        }', '        if (mWindowId == INVALID_WINDOW_ID) {', '            Log.i(TAG, ""Window ID not allocated. Finishing the activity"");', '            Toast.makeText(this, R.string.max_number_of_windows, Toast.LENGTH_LONG).show();', '            return false;', '        }', '', '        if (mMultiInstanceManager != null', '                && !mMultiInstanceManager.isStartedUpCorrectly(getTaskId())) {', '            return false;', '        }', '', '        return super.isStartedUpCorrectly(intent);', '    }', '', '    private static int getExtraWindowIdFromIntent(Intent intent) {', '        int windowId = IntentUtils.safeGetIntExtra(', '                intent, IntentHandler.EXTRA_WINDOW_ID, INVALID_WINDOW_ID);', '        return IntentUtils.isTrustedIntentFromSelf(intent) ? windowId : INVALID_WINDOW_ID;', '    }', '', '    private static boolean getExtraPreferNewFromIntent(Intent intent) {', '        return IntentUtils.safeGetBooleanExtra(intent, IntentHandler.EXTRA_PREFER_NEW, false);', '    }', '', '    @Override', '    public void terminateIncognitoSession() {', '        getTabModelSelector().getModel(true).closeAllTabs();', '    }', '', '    @Override', '    public boolean onMenuOrKeyboardAction(final int id, boolean fromMenu) {', '        final Tab currentTab = getActivityTab();', '        boolean currentTabIsNtp = isTabNtp(currentTab);', '        if (id == R.id.new_tab_menu_id) {', '            getTabModelSelector().getModel(false).commitAllTabClosures();', '            RecordUserAction.record(""MobileMenuNewTab"");', '            RecordUserAction.record(""MobileNewTabOpened"");', '            ReturnToChromeExperimentsUtil.onNewTabOpened();', '            reportNewTabShortcutUsed(false);', '            if (fromMenu) RecordUserAction.record(""MobileMenuNewTab.AppMenu"");', '', '            getTabCreator(false).launchNTP();', '', '            mLocaleManager.showSearchEnginePromoIfNeeded(this, null);', '        } else if (id == R.id.new_incognito_tab_menu_id) {', '            if (IncognitoUtils.isIncognitoModeEnabled()) {', '                getTabModelSelector().getModel(false).commitAllTabClosures();', '                // This action must be recorded before opening the incognito tab since UMA actions', '                // are dropped when an incognito tab is open.', '                RecordUserAction.record(""MobileMenuNewIncognitoTab"");', '                RecordUserAction.record(""MobileNewTabOpened"");', '                ReturnToChromeExperimentsUtil.onNewTabOpened();', '                reportNewTabShortcutUsed(true);', '                if (fromMenu) RecordUserAction.record(""MobileMenuNewIncognitoTab.AppMenu"");', '                getTabCreator(true).launchNTP();', '            }', '        } else if (id == R.id.all_bookmarks_menu_id) {', ""            // Note that 'currentTab' could be null in overview mode when start surface is"", '            // enabled.', '            getCompositorViewHolderSupplier().get().hideKeyboard(() -> {', '                BookmarkUtils.showBookmarkManager(', '                        ChromeTabbedActivity.this, getCurrentTabModel().isIncognito());', '            });', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_BOOKMARKS_MANAGER);', '            }', '', '            @BrowserProfileType', '            int type = getCurrentTabModel().isIncognito() ? BrowserProfileType.INCOGNITO', '                                                          : BrowserProfileType.REGULAR;', '            RecordHistogram.recordEnumeratedHistogram(', '                    ""Bookmarks.OpenBookmarkManager.PerProfileType"", type,', '                    BrowserProfileType.MAX_VALUE + 1);', '', '            RecordUserAction.record(""MobileMenuAllBookmarks"");', '        } else if (id == R.id.recent_tabs_menu_id) {', '            LoadUrlParams params =', '                    new LoadUrlParams(UrlConstants.RECENT_TABS_URL, PageTransition.AUTO_BOOKMARK);', '            boolean isInOverviewMode = isInOverviewMode();', '            if (isInOverviewMode && !isTablet()', '                    && ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '                // When tapping the ""Recent tabs"" menu item from the overview page (Start surface or', '                // GTS), we will create the tab with the launch type FROM_START_SURFACE. Thus, if', '                // the back button is tapped on this ""Recent tabs"" page, it can go back to the', '                // overview page.', '                ReturnToChromeExperimentsUtil.handleLoadUrlFromStartSurface(', '                        params, getCurrentTabModel().isIncognito(), null);', '            } else if (currentTab != null) {', '                currentTab.loadUrl(params);', '            } else {', '                getTabCreator(getCurrentTabModel().isIncognito())', '                        .createNewTab(params, TabLaunchType.FROM_CHROME_UI, null);', '            }', '            if (isInOverviewMode) {', '                mOverviewModeController.hideOverview(true);', '            }', '', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_RECENT_TABS_MANAGER);', '            }', '            RecordUserAction.record(""MobileMenuRecentTabs"");', '            ReturnToChromeExperimentsUtil.onRecentTabsOpened();', '        } else if (id == R.id.close_tab) {', '            getCurrentTabModel().closeTab(currentTab, true, false, true);', '            RecordUserAction.record(""MobileTabClosed"");', '        } else if (id == R.id.close_all_tabs_menu_id) {', '            // Close both incognito and normal tabs', '            getTabModelSelector().closeAllTabs();', '            RecordUserAction.record(""MobileMenuCloseAllTabs"");', '        } else if (id == R.id.close_all_incognito_tabs_menu_id) {', '            // Close only incognito tabs', '            getTabModelSelector().getModel(true).closeAllTabs();', '            RecordUserAction.record(""MobileMenuCloseAllIncognitoTabs"");', '        } else if (id == R.id.focus_url_bar) {', '            boolean isUrlBarVisible = !mOverviewModeController.overviewVisible()', '                    && (!isTablet() || getCurrentTabModel().getCount() != 0);', '            if (isUrlBarVisible) {', '                getToolbarManager().setUrlBarFocus(', '                        true, OmniboxFocusReason.MENU_OR_KEYBOARD_ACTION);', '            }', '        } else if (id == R.id.downloads_menu_id) {', '            OTRProfileID otrProfileID = null;', '            if (currentTab != null && currentTab.getWebContents() != null) {', '                Profile profile = Profile.fromWebContents(currentTab.getWebContents());', '                otrProfileID = profile != null ? profile.getOTRProfileID() : null;', '            }', '            DownloadUtils.showDownloadManager(', '                    this, currentTab, otrProfileID, DownloadOpenSource.MENU);', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_DOWNLOADS_MANAGER);', '            }', '            RecordUserAction.record(""MobileMenuDownloadManager"");', '        } else if (id == R.id.open_recently_closed_tab) {', '            TabModel currentModel = mTabModelSelector.getCurrentModel();', '            if (!currentModel.isIncognito()) currentModel.openMostRecentlyClosedTab();', '            RecordUserAction.record(""MobileTabClosedUndoShortCut"");', '        } else if (id == R.id.enter_vr_id) {', '            VrModuleProvider.getDelegate().enterVrIfNecessary();', '        } else {', '            return super.onMenuOrKeyboardAction(id, fromMenu);', '        }', '        return true;', '    }', '', '    private boolean isTabNtp(Tab tab) {', '        return tab != null && UrlUtilities.isNTPUrl(tab.getUrl());', '    }', '', '    private boolean isTabRegularNtp(Tab tab) {', '        return isTabNtp(tab) && !tab.isIncognito();', '    }', '', '    private void onOmniboxFocusChanged(boolean hasFocus) {', '        mTabModalHandler.onOmniboxFocusChanged(hasFocus);', '    }', '', '    private void recordLauncherShortcutAction(boolean isIncognito) {', '        if (isIncognito) {', '            RecordUserAction.record(""Android.LauncherShortcut.NewIncognitoTab"");', '        } else {', '            RecordUserAction.record(""Android.LauncherShortcut.NewTab"");', '        }', '    }', '', '    @Override', '    public boolean handleBackPressed() {', '        if (!mUIWithNativeInitialized) return false;', '', '        if (getManualFillingComponent().handleBackPress()) return true;', '', '        if (exitFullscreenIfShowing()) {', '            return true;', '        }', '', '        // TODO(1091411): Find a better mechanism for back-press handling for features.', '        if (mRootUiCoordinator.getBottomSheetController().handleBackPress()) return true;', '', '        if (mTabModalHandler.handleBackPress()) return true;', '', '        final Tab currentTab = getActivityTab();', '        if (currentTab == null) {', '            moveTaskToBack(true);', '            return true;', '        }', '', '        // If we are in the tab switcher mode (not in the Start surface homepage) and not a tablet,', '        // then leave tab switcher mode on back.', '        if (mOverviewModeController.overviewVisible() && !isTablet()', '                && (mStartSurfaceSupplier.get() == null', '                        || mStartSurfaceSupplier.get().getController().getStartSurfaceState()', '                                == StartSurfaceState.SHOWN_TABSWITCHER)) {', '            mOverviewModeController.hideOverview(true);', '            return true;', '        }', '', '        final WebContents webContents = currentTab.getWebContents();', '        if (webContents != null) {', '            RenderFrameHost focusedFrame = webContents.getFocusedFrame();', '            if (focusedFrame != null && focusedFrame.signalCloseWatcherIfActive()) return true;', '        }', '', '        if (getToolbarManager().back()) return true;', '', '        // If the current tab url is HELP_URL, then the back button should close the tab to', '        // get back to the previous state. The reason for startsWith check is that the', '        // actual redirected URL is a different system language based help url.', '        final @TabLaunchType int type = currentTab.getLaunchType();', '        final boolean helpUrl = currentTab.getUrl().getSpec().startsWith(HELP_URL_PREFIX);', '        if (type == TabLaunchType.FROM_CHROME_UI && helpUrl) {', '            getCurrentTabModel().closeTab(currentTab);', '            return true;', '        }', '', ""        // If we aren't in the overview mode, we handle the Tab with launchType"", '        // TabLaunchType.FROM_START_SURFACE or has ""OpenedFromStart"" property.', '        if (!mOverviewModeController.overviewVisible()', '                && (type == TabLaunchType.FROM_START_SURFACE', '                        || StartSurfaceUserData.isOpenedFromStart(currentTab))) {', '            if (StartSurfaceUserData.getKeepTab(currentTab)', '                    || StartSurfaceUserData.isOpenedFromStart(currentTab)) {', '                // If the current tab is created from the start surface with the keepTab property,']}, {'a': ['                // shows the Start surface non-incognito homepage to prevent a loop between the', '                // current tab and previous overview mode. Once in the Start surface, it will close', '                // Chrome if back button is tapped again.'], 'b': ['                // shows the Start surface Homepage to prevent a loop between the current tab and', '                // previous overview mode. Once in the Start surface, it will close Chrome if back', '                // button is tapped again.']}, {'ab': ['                if (currentTab.isIncognito()) {', '                    if (!currentTab.isClosing()) {', '                        getCurrentTabModel().closeTab(currentTab);', '                    }']}, {'a': ['                    mTabModelSelector.selectModel(/*incognito=*/false);'], 'b': ['                    mTabModelSelector.selectModel(false);']}, {'ab': ['                }', '                showOverview(StartSurfaceState.SHOWING_HOMEPAGE);', '            } else {', '                // Otherwise, clicking the back button should close the tab and go back to the', '                // previous overview mode.', '                showOverview(StartSurfaceState.SHOWING_PREVIOUS);', '                if (!currentTab.isClosing()) {', '                    getCurrentTabModel().closeTab(currentTab);', '                }', '            }', '            return true;', '        }', '', '        final boolean shouldCloseTab = backShouldCloseTab(currentTab);', '', '        // Minimize the app if either:', '        // - we decided not to close the tab', '        // - we decided to close the tab, but it was opened by an external app, so we will go', '        //   exit Chrome on top of closing the tab', '        final boolean minimizeApp =', '                !shouldCloseTab || TabAssociatedApp.isOpenedFromExternalApp(currentTab);', '        if (minimizeApp) {', '            if (shouldCloseTab) {', '                sendToBackground(currentTab);', '                return true;', '            } else {', '                sendToBackground(null);', '                return true;', '            }', '        } else if (shouldCloseTab) {', '            currentTab.getWebContents().dispatchBeforeUnload(false);', '            return true;', '        }', '', '        assert false : ""The back button should have already been handled by this point"";', '        return false;', '    }', '', '    /**', '     * [true]: Reached the bottom of the back stack on a tab the user did not explicitly', '     * create (i.e. it was created by an external app or opening a link in background, etc).', '     * [false]: Reached the bottom of the back stack on a tab that the user explicitly', '     * created (e.g. selecting ""new tab"" from menu).', '     *', '     * @return Whether pressing the back button on the provided Tab should close the Tab.', '     */', '    @Override', '    public boolean backShouldCloseTab(Tab tab) {', '        if (!tab.isInitialized()) {', '            return false;', '        }', '        @TabLaunchType', '        int type = tab.getLaunchType();', '', '        return type == TabLaunchType.FROM_LINK || type == TabLaunchType.FROM_EXTERNAL_APP', '                || type == TabLaunchType.FROM_LONGPRESS_FOREGROUND', '                || type == TabLaunchType.FROM_LONGPRESS_BACKGROUND', '                || (type == TabLaunchType.FROM_RESTORE', '                        && CriticalPersistedTabData.from(tab).getParentId() != Tab.INVALID_TAB_ID);', '    }', '', '    /**', '     * Sends this Activity to the background.', '     *', '     * @param tabToClose Tab that will be closed once the app is not visible.', '     */', '    private void sendToBackground(@Nullable final Tab tabToClose) {', '        Log.i(TAG, ""sendToBackground(): "" + tabToClose);', '        moveTaskToBack(true);', '        if (tabToClose != null) {', ""            // In the case of closing a tab upon minimization, don't allow the close action to"", ""            // happen until after our app is minimized to make sure we don't get a brief glimpse of"", '            // the newly active tab before we exit Chrome.', '            //', ""            // If the runnable doesn't run before the Activity dies, Chrome won't crash but the tab"", ""            // won't be closed (crbug.com/587565)."", '            mHandler.postDelayed(() -> {', '                boolean hasNextTab =', '                        getCurrentTabModel().getNextTabIfClosed(tabToClose.getId()) != null;', '                getCurrentTabModel().closeTab(tabToClose, false, true, false);', '', '                // If there is no next tab to open, enter overview mode.', '                if (!hasNextTab) showOverview(StartSurfaceState.SHOWING_START);', '            }, CLOSE_TAB_ON_MINIMIZE_DELAY_MS);', '        }', '    }', '', '    @Override', '    public boolean moveTaskToBack(boolean nonRoot) {', '        try {', '            return super.moveTaskToBack(nonRoot);', '        } catch (NullPointerException e) {', '            // Work around framework bug described in https://crbug.com/817567.', '            finish();', '            return true;', '        }', '    }', '', '    /**', '     * Launch a URL from an intent.', '     *', '     * @param url           The url from the intent.', '     * @param referer       Optional referer URL to be used.', '     * @param headers       Optional headers to be sent when opening the URL.', '     * @param externalAppId External app id.', '     * @param forceNewTab   Whether to force the URL to be launched in a new tab or to fall', '     *                      back to the default behavior for making that determination.', '     * @param isRendererInitiated Whether the intent is originally from browser renderer process.', '     * @param initiatorOrigin Origin that initiates the intent.', '     * @param intent        The original intent.', '     */', '    private Tab launchIntent(', '            LoadUrlParams loadUrlParams, String externalAppId, boolean forceNewTab, Intent intent) {', '        if (mUIWithNativeInitialized && !UrlUtilities.isNTPUrl(loadUrlParams.getUrl())) {', '            mOverviewModeController.hideOverview(false);', '            getToolbarManager().finishAnimations();', '        }', '        if (IntentHandler.wasIntentSenderChrome(intent)) {', '            // If the intent was launched by chrome, open the new tab in the appropriate model.', '            boolean isIncognito = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_OPEN_NEW_INCOGNITO_TAB, false);', '            @TabLaunchType', '            Integer launchType = IntentHandler.getTabLaunchType(intent);', '            if (launchType == null) {', '                if (IntentUtils.safeGetBooleanExtra(', '                            intent, IntentHandler.EXTRA_INVOKED_FROM_SHORTCUT, false)) {', '                    launchType = TabLaunchType.FROM_LAUNCHER_SHORTCUT;', '                } else if (IntentUtils.safeGetBooleanExtra(', '                                   intent, IntentHandler.EXTRA_INVOKED_FROM_APP_WIDGET, false)) {', '                    launchType = TabLaunchType.FROM_APP_WIDGET;', '                } else if (IncognitoTabLauncher.didCreateIntent(intent)) {', '                    launchType = TabLaunchType.FROM_LAUNCH_NEW_INCOGNITO_TAB;', '                } else {', '                    // Using FROM_LINK ensures the tab is parented to the current tab, which allows', '                    // the back button to close these tabs and restore selection to the previous', '                    // tab.', '                    launchType = TabLaunchType.FROM_LINK;', '                }', '            }', '            return getTabCreator(isIncognito).createNewTab(loadUrlParams, launchType, null, intent);', '        }', '', '        // Check if the tab is being created from a Reader Mode navigation.', '        if (ReaderModeManager.isEnabled() && ReaderModeManager.isReaderModeCreatedIntent(intent)) {', '            Bundle extras = intent.getExtras();', '            int readerParentId = IntentUtils.safeGetInt(', '                    extras, ReaderModeManager.EXTRA_READER_MODE_PARENT, Tab.INVALID_TAB_ID);', '            extras.remove(ReaderModeManager.EXTRA_READER_MODE_PARENT);', '            // Set the parent tab to the tab that Reader Mode started from.', '            if (readerParentId != Tab.INVALID_TAB_ID && mTabModelSelector != null) {', '                return getCurrentTabCreator().createNewTab(', '                        new LoadUrlParams(loadUrlParams.getUrl(), PageTransition.LINK),', '                        TabLaunchType.FROM_LINK, mTabModelSelector.getTabById(readerParentId));', '            }', '        }', '', '        return getTabCreator(false).launchUrlFromExternalApp(', '                loadUrlParams, externalAppId, forceNewTab, intent);', '    }', '', '    private void showOverview(@StartSurfaceState int state) {', '        showOverview(state, NewTabPageLaunchOrigin.UNKNOWN);', '    }', '', '    // TODO(crbug.com/1115757): After crrev.com/c/2315823, Overview state and Startsurface state are', '    // two different things, we actual can split this into two methods: showOverview() and', ""    // showStartSurface(state). Let's do some auditing and clean up before perform the actual split."", '    private void showOverview(', '            @StartSurfaceState int state, @NewTabPageLaunchOrigin int launchOrigin) {', '        assert (state == StartSurfaceState.SHOWING_TABSWITCHER', '                || state == StartSurfaceState.SHOWING_HOMEPAGE', '                || state == StartSurfaceState.SHOWING_PREVIOUS', '                || state == StartSurfaceState.SHOWING_START);', '        if (mIsAccessibilityTabSwitcherEnabled != null && mIsAccessibilityTabSwitcherEnabled', '                && mOverviewModeController != null) {', '            // TODO(1200727): This is a temporary fix that should be removed once grid tab switcher', '            //                is completely launched. The ""start surface"" is now created regardless', '            //                of the state of accessibility, so we check that mode first and try', '            //                showing the overview list before going to the start surface.', '            mOverviewModeController.showOverview(false);', '        } else if (mStartSurfaceSupplier.get() != null) {', '            if (ReturnToChromeExperimentsUtil.shouldHideStartSurfaceWithAccessibilityOn(this)', '                    || !HomepageManager.isHomepageEnabled()) {', '                state = StartSurfaceState.SHOWING_TABSWITCHER;', '            }', '            mStartSurfaceSupplier.get().getController().setOverviewState(state, launchOrigin);', '        }', '', '        if (mOverviewModeController == null) return;', '', '        if (mOverviewModeController.overviewVisible()) {', '            if (didFinishNativeInitialization()) {', '                getCompositorViewHolderSupplier().get().hideKeyboard(() -> {});', '            }', '            return;', '        }', '', '        Tab currentTab = getActivityTab();', ""        // If we don't have a current tab, show the overview mode."", '        if (currentTab == null) {', '            mOverviewModeController.showOverview(false);', '        } else {', '            getCompositorViewHolderSupplier().get().hideKeyboard(', '                    () -> mOverviewModeController.showOverview(true));', '            updateAccessibilityState(false);', '            TasksUma.recordTabLaunchType(getCurrentTabModel());', '        }', '    }', '', '    private void hideOverview() {', '        assert (mOverviewModeController.overviewVisible());', '        if (getCurrentTabModel().getCount() != 0) {', ""            // Don't hide overview if current tab stack is empty()"", '            mOverviewModeController.hideOverview(true);', '            updateAccessibilityState(true);', '        }', '    }', '', '    /**', '     * @return Whether opening a new tab is handled by the Start surface. It may show the Start', '     * surface, or open a new tab with the omnibox get focused, depending on the value of', '     * {@link StartSurfaceConfiguration.OMNIBOX_FOCUSED_ON_NEW_TAB}.', '     */', '    private boolean showStartSurfaceHomeForNTP(boolean isNTP, boolean incognito, Tab parentTab,', '            @NewTabPageLaunchOrigin int launchOrigin) {', '        if (!isNTP', '                || !ReturnToChromeExperimentsUtil.shouldShowStartSurfaceHomeAsNTP(', '                        this, incognito, isTablet())) {', '            return false;', '        }', '', '        getTabModelSelector().selectModel(incognito);', '        if (StartSurfaceConfiguration.OMNIBOX_FOCUSED_ON_NEW_TAB.getValue()', '                && launchOrigin != NewTabPageLaunchOrigin.WEB_FEED) {', '            Runnable emptyTabCloseCallback = isInOverviewMode() ? () -> {', '                showOverview(StartSurfaceState.SHOWING_PREVIOUS, launchOrigin);', '            } : null;', '            ReturnToChromeExperimentsUtil.handleLoadUrlFromStartSurfaceAsNewTab(null,', '                    PageTransition.AUTO_TOPLEVEL, incognito, parentTab, getCurrentTabModel(),', '                    emptyTabCloseCallback);', '        } else if (TabUiFeatureUtilities.supportInstantStart(isTablet(), this)', '                || (getTabModelSelector().isTabStateInitialized() && isLayoutManagerCreated())) {', '            showOverview(StartSurfaceState.SHOWING_HOMEPAGE, launchOrigin);', '        }', '        return true;', '    }', '', '    private void updateAccessibilityState(boolean enabled) {', '        Tab currentTab = getActivityTab();', '        WebContents webContents = currentTab != null ? currentTab.getWebContents() : null;', '        if (webContents != null) {', '            WebContentsAccessibility.fromWebContents(webContents).setState(enabled);', '        }', '    }', '', '    @Override', '    public void onSaveInstanceState(Bundle outState) {', '        super.onSaveInstanceState(outState);', '        CipherFactory.getInstance().saveToBundle(outState);', '        outState.putInt(', '                WINDOW_INDEX, TabWindowManagerSingleton.getInstance().getIndexForWindow(this));', '        Boolean is_incognito = getCurrentTabModel().isIncognito();', '        outState.putBoolean(IS_INCOGNITO_SELECTED, is_incognito);', ""        // If it's Incognito and native is initialized and profile exists, serialize duration"", '        // service state.', '        if (is_incognito && ProfileManager.isInitialized()) {', '            AndroidSessionDurationsServiceState.serializeFromNative(', '                    outState, getCurrentTabModel().getProfile());', '        }', '    }', '', '    @Override', '    public void onDestroyInternal() {', '        if (mCallbackController != null) {', '            mCallbackController.destroy();', '            mCallbackController = null;', '        }', '', '        if (mTabModelSelectorTabObserver != null) {', '            mTabModelSelectorTabObserver.destroy();', '            mTabModelSelectorTabObserver = null;', '        }', '', '        if (mTabModelObserver != null) mTabModelObserver.destroy();', '', '        if (mUndoBarPopupController != null) {', '            mUndoBarPopupController.destroy();', '            mUndoBarPopupController = null;', '        }', '', '        if (mAppIndexingUtil != null) {', '            mAppIndexingUtil.destroy();', '            mAppIndexingUtil = null;', '        }', '', '        if (mStartSurfaceSupplier.get() != null) {', '            mStartSurfaceSupplier.get().destroy();', '        }', '', '        if (mStartupPaintPreviewHelperSupplier != null) {', '            mStartupPaintPreviewHelperSupplier.destroy();', '        }', '', '        if (mJankTracker != null) {', '            mJankTracker.destroy();', '            mJankTracker = null;', '        }', '', '        IncognitoTabHostRegistry.getInstance().unregister(mIncognitoTabHost);', '', '        TabObscuringHandler tabObscuringHandler = getTabObscuringHandler();', '        if (tabObscuringHandler != null) {', '            getTabObscuringHandler().removeObserver(mCompositorViewHolder);', '            getTabObscuringHandler().removeObserver(mOverviewListLayout);', '        }', '', '        if (isTablet()) ChromeAccessibilityUtil.get().removeObserver(mCompositorViewHolder);', '        ChromeAccessibilityUtil.get().removeObserver(this);', '        ChromeAccessibilityUtil.get().removeObserver(mLayoutManager);', '', '        if (mTabDelegateFactory != null) mTabDelegateFactory.destroy();', '', '        mAppLaunchDrawBlocker.destroy();', '', '        super.onDestroyInternal();', '    }', '', '    @Override', '    protected void destroyTabModels() {', '        if (mTabModelOrchestrator != null) {', '            mTabModelOrchestrator.destroy();', '        }', '    }', '', '    @Override', '    public void onTrimMemory(int level) {', '        super.onTrimMemory(level);', '        if (ChromeApplicationImpl.isSevereMemorySignal(level)) {', '            NativePageAssassin.getInstance().freezeAllHiddenPages();', '        }', '    }', '', '    @Override', '    public boolean dispatchKeyEvent(KeyEvent event) {', '        Boolean result = KeyboardShortcuts.dispatchKeyEvent(event, mUIWithNativeInitialized,', '                getFullscreenManager(), /* menuOrKeyboardActionController= */ this);', '        return result != null ? result : super.dispatchKeyEvent(event);', '    }', '', '    @Override', '    public boolean onKeyDown(int keyCode, KeyEvent event) {', '        if (!mUIWithNativeInitialized) {', '            return super.onKeyDown(keyCode, event);', '        }', '        // Detecting a long press of the back button via onLongPress is broken in Android N.', '        // To work around this, use a postDelayed, which is supported in all versions.', '        if (keyCode == KeyEvent.KEYCODE_BACK && !isTablet()', '                && !getFullscreenManager().getPersistentFullscreenMode()) {', '            if (mShowHistoryRunnable == null) mShowHistoryRunnable = this::showFullHistorySheet;', '            mHandler.postDelayed(mShowHistoryRunnable, ViewConfiguration.getLongPressTimeout());', '            return super.onKeyDown(keyCode, event);', '        }', '        boolean isCurrentTabVisible = !mOverviewModeController.overviewVisible()', '                && (!isTablet() || getCurrentTabModel().getCount() != 0);', '        return KeyboardShortcuts.onKeyDown(event, isCurrentTabVisible, true, getTabModelSelector(),', '                       /* menuOrKeyboardActionController= */ this, getToolbarManager())', '                || super.onKeyDown(keyCode, event);', '    }', '', '    private void showFullHistorySheet() {', '        ((TabbedRootUiCoordinator) mRootUiCoordinator).showFullHistorySheet();', '    }', '', '    @Override', '    public boolean onKeyUp(int keyCode, KeyEvent event) {', '        if (keyCode == KeyEvent.KEYCODE_BACK && !isTablet()) {', '            mHandler.removeCallbacks(mShowHistoryRunnable);', '            mShowHistoryRunnable = null;', '            if (event.getEventTime() - event.getDownTime()', '                            >= ViewConfiguration.getLongPressTimeout()', '                    && NavigationSheet.isInstanceShowing(', '                            mRootUiCoordinator.getBottomSheetController())) {', '                // If tab history popup is showing, do not process the keyUp event', '                // which will dismiss it immediately.', '                return true;', '            }', '        }', '        return super.onKeyUp(keyCode, event);', '    }', '', '    @VisibleForTesting', '    public boolean hasPendingNavigationRunnableForTesting() {', '        ThreadUtils.assertOnUiThread();', '        return mShowHistoryRunnable != null;', '    }', '', '    @Override', '    public void onProvideKeyboardShortcuts(', '            List<KeyboardShortcutGroup> data, Menu menu, int deviceId) {', '        data.addAll(KeyboardShortcuts.createShortcutGroup(this));', '    }', '', '    @VisibleForTesting', '    public View getTabsView() {', '        return getCompositorViewHolderSupplier().get();', '    }', '', '    @VisibleForTesting', '    public LayoutManagerChrome getLayoutManager() {', '        return (LayoutManagerChrome) getCompositorViewHolderSupplier().get().getLayoutManager();', '    }', '', '    @VisibleForTesting', '    public Layout getOverviewListLayout() {', '        return getLayoutManager().getOverviewListLayout();', '    }', '', '    @VisibleForTesting', '    public StartSurface getStartSurface() {', '        return mStartSurfaceSupplier.get();', '    }', '', '    private ComposedBrowserControlsVisibilityDelegate getAppBrowserControlsVisibilityDelegate() {', '        // TODO(jinsukkim): Move this to RootUiCoordinator.', '        return ((TabbedRootUiCoordinator) mRootUiCoordinator)', '                .getAppBrowserControlsVisibilityDelegate();', '    }', '', '    @Override', '    protected ModalDialogManager createModalDialogManager() {', '        ModalDialogManager manager = super.createModalDialogManager();', '        // TODO(crbug.com/1157310): Transition this::method refs to dedicated suppliers.', '        mTabModalHandler = new TabModalLifetimeHandler(this, getLifecycleDispatcher(), manager,', '                this::getAppBrowserControlsVisibilityDelegate, this::getTabObscuringHandler,', '                this::getToolbarManager, this::getContextualSearchManager,', '                getTabModelSelectorSupplier(), this::getBrowserControlsManager,', '                this::getFullscreenManager);', '        return manager;', '    }', '', '    // App Menu related code -----------------------------------------------------------------------', '', '    @Override', '    public boolean canShowAppMenu() {', '        // The popup menu relies on the model created during the full UI initialization, so do not', '        // attempt to show the menu until the UI creation has finished.', '        if (!mUIWithNativeInitialized) return false;', '', ""        // If the current active tab is showing a tab modal dialog, an app menu shouldn't be shown"", '        // in any cases, e.g. when a hardware menu button is clicked.', '        Tab tab = getActivityTab();', '        if (tab != null && ChromeTabModalPresenter.isDialogShowing(tab)) return false;', '', '        return super.canShowAppMenu();', '    }', '', '    @Override', '    public boolean isInOverviewMode() {', '        return mOverviewModeController != null && mOverviewModeController.overviewVisible();', '    }', '', '    @Override', '    protected IntentHandlerDelegate createIntentHandlerDelegate() {', '        return new InternalIntentDelegate();', '    }', '', '    @Override', '    public void onSceneChange(Layout layout) {', '        super.onSceneChange(layout);', '        if (!layout.shouldDisplayContentOverlay()) mTabModelSelector.onTabsViewShown();', '    }', '', '    /**', '     * Writes the tab state to disk.', '     */', '    @VisibleForTesting', '    public void saveState() {', '        mTabModelOrchestrator.saveState();', '    }', '', '    @Override', '    public void onEnterVr() {', '        super.onEnterVr();', '        mControlContainer.setVisibility(View.INVISIBLE);', '        if (mVrBrowserControlsVisibilityDelegate == null) {', '            mVrBrowserControlsVisibilityDelegate =', '                    new BrowserControlsVisibilityDelegate(BrowserControlsState.BOTH);', '            getAppBrowserControlsVisibilityDelegate().addDelegate(', '                    mVrBrowserControlsVisibilityDelegate);', '        }', '        mVrBrowserControlsVisibilityDelegate.set(BrowserControlsState.HIDDEN);', '    }', '', '    @Override', '    public void onExitVr() {', '        super.onExitVr();', '        mControlContainer.setVisibility(View.VISIBLE);', '        if (mVrBrowserControlsVisibilityDelegate != null) {', '            mVrBrowserControlsVisibilityDelegate.set(BrowserControlsState.BOTH);', '        }', '    }', '', '    @Override', '    protected void applyThemeOverlays() {', '        super.applyThemeOverlays();', '', '        if (TabManagementModuleProvider.getDelegate() != null) {', '            TabManagementModuleProvider.getDelegate().applyThemeOverlays(this);', '        }', '    }', '', '    @Override', '    protected boolean supportsDynamicColors() {', '        return CachedFeatureFlags.isEnabled(ChromeFeatureList.DYNAMIC_COLOR_ANDROID);', '    }', '', '    /**', '     * Reports that a new tab launcher shortcut was selected or an action equivalent to a shortcut', '     * was performed.', '     * @param isIncognito Whether the shortcut or action created a new incognito tab.', '     */', '    @TargetApi(Build.VERSION_CODES.N_MR1)', '    private void reportNewTabShortcutUsed(boolean isIncognito) {', '        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N_MR1) return;', '', '        ShortcutManager shortcutManager = getSystemService(ShortcutManager.class);', '        shortcutManager.reportShortcutUsed(', '                isIncognito ? ""new-incognito-tab-shortcut"" : ""new-tab-shortcut"");', '    }', '', '    @VisibleForTesting', '    public MultiInstanceManager getMultiInstanceMangerForTesting() {', '        return mMultiInstanceManager;', '    }', '', '    @VisibleForTesting', '    public ChromeNextTabPolicySupplier getNextTabPolicySupplier() {', '        return (ChromeNextTabPolicySupplier) mNextTabPolicySupplier;', '    }', '}', '']}]",chromium%2Fsrc~main~Ib63fff1d02f6696a61891dd6449012e0c7a5d027,8731f872fe833f2c64a8604ff02ad616355d9fed,chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java,140fa212_552b55e6_before.java,140fa212_552b55e6_after.java,ChromeTabbedActivity::handleBackPressed,True,True
1,7fa9753f_9d8ef123,2168.0,I think it is fine to close the Tab.,,,"[{'ab': ['// Copyright 2015 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser;', '', 'import android.annotation.TargetApi;', 'import android.app.ActivityManager;', 'import android.content.ComponentName;', 'import android.content.Context;', 'import android.content.Intent;', 'import android.content.pm.ApplicationInfo;', 'import android.content.pm.ShortcutManager;', 'import android.os.Build;', 'import android.os.Bundle;', 'import android.os.SystemClock;', 'import android.text.TextUtils;', 'import android.text.format.DateUtils;', 'import android.util.Pair;', 'import android.view.KeyEvent;', 'import android.view.KeyboardShortcutGroup;', 'import android.view.Menu;', 'import android.view.View;', 'import android.view.View.OnClickListener;', 'import android.view.ViewConfiguration;', 'import android.view.ViewGroup;', 'import android.view.Window;', 'import android.view.WindowManager;', '', 'import androidx.annotation.IntDef;', 'import androidx.annotation.Nullable;', 'import androidx.annotation.VisibleForTesting;', 'import androidx.lifecycle.Lifecycle;', 'import androidx.lifecycle.LifecycleObserver;', 'import androidx.lifecycle.LifecycleRegistry;', '', 'import org.chromium.base.CallbackController;', 'import org.chromium.base.CommandLine;', 'import org.chromium.base.ContextUtils;', 'import org.chromium.base.IntentUtils;', 'import org.chromium.base.Log;', 'import org.chromium.base.MemoryPressureListener;', 'import org.chromium.base.ThreadUtils;', 'import org.chromium.base.TraceEvent;', 'import org.chromium.base.annotations.UsedByReflection;', 'import org.chromium.base.jank_tracker.JankTrackerImpl;', 'import org.chromium.base.library_loader.LibraryLoader;', 'import org.chromium.base.metrics.RecordHistogram;', 'import org.chromium.base.metrics.RecordUserAction;', 'import org.chromium.base.supplier.ObservableSupplierImpl;', 'import org.chromium.base.supplier.OneShotCallback;', 'import org.chromium.base.supplier.OneshotSupplier;', 'import org.chromium.base.supplier.OneshotSupplierImpl;', 'import org.chromium.base.supplier.Supplier;', 'import org.chromium.base.supplier.UnownedUserDataSupplier;', 'import org.chromium.base.task.PostTask;', 'import org.chromium.cc.input.BrowserControlsState;', 'import org.chromium.chrome.R;', 'import org.chromium.chrome.browser.IntentHandler.IntentHandlerDelegate;', 'import org.chromium.chrome.browser.IntentHandler.TabOpenType;', 'import org.chromium.chrome.browser.accessibility_tab_switcher.OverviewListLayout;', 'import org.chromium.chrome.browser.app.ChromeActivity;', 'import org.chromium.chrome.browser.app.metrics.LaunchCauseMetrics;', 'import org.chromium.chrome.browser.app.metrics.TabbedActivityLaunchCauseMetrics;', 'import org.chromium.chrome.browser.app.tabmodel.AsyncTabParamsManagerSingleton;', 'import org.chromium.chrome.browser.app.tabmodel.ChromeNextTabPolicySupplier;', 'import org.chromium.chrome.browser.app.tabmodel.TabModelOrchestrator;', 'import org.chromium.chrome.browser.app.tabmodel.TabWindowManagerSingleton;', 'import org.chromium.chrome.browser.app.tabmodel.TabbedModeTabModelOrchestrator;', 'import org.chromium.chrome.browser.bookmarks.BookmarkUtils;', 'import org.chromium.chrome.browser.browserservices.intents.WebappConstants;', 'import org.chromium.chrome.browser.compositor.CompositorViewHolder;', 'import org.chromium.chrome.browser.compositor.bottombar.ephemeraltab.EphemeralTabCoordinator;', 'import org.chromium.chrome.browser.compositor.layouts.Layout;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChrome;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChromePhone;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChromeTablet;', 'import org.chromium.chrome.browser.compositor.layouts.OverviewModeBehavior;', 'import org.chromium.chrome.browser.compositor.layouts.OverviewModeController;', 'import org.chromium.chrome.browser.cookies.CookiesFetcher;', 'import org.chromium.chrome.browser.crypto.CipherFactory;', 'import org.chromium.chrome.browser.dependency_injection.ChromeActivityComponent;', 'import org.chromium.chrome.browser.device.DeviceClassManager;', 'import org.chromium.chrome.browser.dom_distiller.ReaderModeManager;', 'import org.chromium.chrome.browser.download.DownloadNotificationService;', 'import org.chromium.chrome.browser.download.DownloadOpenSource;', 'import org.chromium.chrome.browser.download.DownloadUtils;', 'import org.chromium.chrome.browser.feature_engagement.TrackerFactory;', 'import org.chromium.chrome.browser.feed.FeedSurfaceTracker;', 'import org.chromium.chrome.browser.firstrun.FirstRunSignInProcessor;', 'import org.chromium.chrome.browser.flags.ActivityType;', 'import org.chromium.chrome.browser.flags.CachedFeatureFlags;', 'import org.chromium.chrome.browser.flags.ChromeFeatureList;', 'import org.chromium.chrome.browser.flags.ChromeSwitches;', 'import org.chromium.chrome.browser.fonts.FontPreloader;', 'import org.chromium.chrome.browser.gesturenav.NavigationSheet;', 'import org.chromium.chrome.browser.homepage.HomepageManager;', 'import org.chromium.chrome.browser.incognito.IncognitoNotificationManager;', 'import org.chromium.chrome.browser.incognito.IncognitoNotificationPresenceController;', 'import org.chromium.chrome.browser.incognito.IncognitoProfileDestroyer;', 'import org.chromium.chrome.browser.incognito.IncognitoStartup;', 'import org.chromium.chrome.browser.incognito.IncognitoTabLauncher;', 'import org.chromium.chrome.browser.incognito.IncognitoTabSnapshotController;', 'import org.chromium.chrome.browser.incognito.IncognitoUtils;', 'import org.chromium.chrome.browser.infobar.DataReductionPromoInfoBar;', 'import org.chromium.chrome.browser.infobar.SyncErrorInfoBar;', 'import org.chromium.chrome.browser.layouts.LayoutStateProvider;', 'import org.chromium.chrome.browser.lifecycle.ActivityLifecycleDispatcher;', 'import org.chromium.chrome.browser.locale.LocaleManager;', 'import org.chromium.chrome.browser.metrics.AndroidSessionDurationsServiceState;', 'import org.chromium.chrome.browser.metrics.LaunchMetrics;', 'import org.chromium.chrome.browser.metrics.MainIntentBehaviorMetrics;', 'import org.chromium.chrome.browser.modaldialog.ChromeTabModalPresenter;', 'import org.chromium.chrome.browser.modaldialog.TabModalLifetimeHandler;', 'import org.chromium.chrome.browser.multiwindow.MultiInstanceChromeTabbedActivity;', 'import org.chromium.chrome.browser.multiwindow.MultiInstanceManager;', 'import org.chromium.chrome.browser.multiwindow.MultiWindowUtils;', 'import org.chromium.chrome.browser.native_page.NativePageAssassin;', 'import org.chromium.chrome.browser.navigation_predictor.NavigationPredictorBridge;', 'import org.chromium.chrome.browser.night_mode.WebContentsDarkModeController;', 'import org.chromium.chrome.browser.ntp.NewTabPageLaunchOrigin;', 'import org.chromium.chrome.browser.ntp.NewTabPageUma;', 'import org.chromium.chrome.browser.ntp.NewTabPageUtils;', 'import org.chromium.chrome.browser.omnibox.OmniboxFocusReason;', 'import org.chromium.chrome.browser.paint_preview.StartupPaintPreviewHelper;', 'import org.chromium.chrome.browser.paint_preview.StartupPaintPreviewHelperSupplier;', 'import org.chromium.chrome.browser.partnercustomizations.PartnerBrowserCustomizations;', 'import org.chromium.chrome.browser.preferences.ChromePreferenceKeys;', 'import org.chromium.chrome.browser.profiles.OTRProfileID;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.profiles.ProfileManager;', 'import org.chromium.chrome.browser.reengagement.ReengagementNotificationController;', 'import org.chromium.chrome.browser.search_engines.SearchEngineChoiceNotification;', 'import org.chromium.chrome.browser.settings.SettingsLauncherImpl;', 'import org.chromium.chrome.browser.share.send_tab_to_self.SendTabToSelfAndroidBridge;', 'import org.chromium.chrome.browser.suggestions.SuggestionsMetrics;', 'import org.chromium.chrome.browser.survey.ChromeSurveyController;', 'import org.chromium.chrome.browser.sync.ui.SyncErrorMessage;', 'import org.chromium.chrome.browser.sync.ui.SyncErrorPromptUtils;', 'import org.chromium.chrome.browser.tab.RedirectHandlerTabHelper;', 'import org.chromium.chrome.browser.tab.Tab;', 'import org.chromium.chrome.browser.tab.TabAssociatedApp;', 'import org.chromium.chrome.browser.tab.TabCreationState;', 'import org.chromium.chrome.browser.tab.TabDelegateFactory;', 'import org.chromium.chrome.browser.tab.TabLaunchType;', 'import org.chromium.chrome.browser.tab.TabSelectionType;', 'import org.chromium.chrome.browser.tab.state.CriticalPersistedTabData;', 'import org.chromium.chrome.browser.tabbed_mode.TabbedAppMenuPropertiesDelegate;', 'import org.chromium.chrome.browser.tabbed_mode.TabbedRootUiCoordinator;', 'import org.chromium.chrome.browser.tabmodel.ChromeTabCreator;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHost;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHostRegistry;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHostUtils;', 'import org.chromium.chrome.browser.tabmodel.NextTabPolicy.NextTabPolicySupplier;', 'import org.chromium.chrome.browser.tabmodel.TabModel;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelector;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorBase;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorTabModelObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorTabObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelUtils;', 'import org.chromium.chrome.browser.tabmodel.TabWindowManager;', 'import org.chromium.chrome.browser.tasks.ConditionalTabStripUtils;', 'import org.chromium.chrome.browser.tasks.EngagementTimeUtil;', 'import org.chromium.chrome.browser.tasks.JourneyManager;', 'import org.chromium.chrome.browser.tasks.ReturnToChromeExperimentsUtil;', 'import org.chromium.chrome.browser.tasks.TasksUma;', 'import org.chromium.chrome.browser.tasks.tab_management.TabGroupUi;', 'import org.chromium.chrome.browser.tasks.tab_management.TabManagementDelegate;', 'import org.chromium.chrome.browser.tasks.tab_management.TabManagementModuleProvider;', 'import org.chromium.chrome.browser.tasks.tab_management.TabUiFeatureUtilities;', 'import org.chromium.chrome.browser.toolbar.ToolbarButtonInProductHelpController;', 'import org.chromium.chrome.browser.toolbar.ToolbarIntentMetadata;', 'import org.chromium.chrome.browser.toolbar.ToolbarManager;', 'import org.chromium.chrome.browser.toolbar.top.ToolbarControlContainer;', 'import org.chromium.chrome.browser.translate.TranslateIntentHandler;', 'import org.chromium.chrome.browser.ui.AppLaunchDrawBlocker;', 'import org.chromium.chrome.browser.ui.RootUiCoordinator;', 'import org.chromium.chrome.browser.ui.TabObscuringHandler;', 'import org.chromium.chrome.browser.ui.appmenu.AppMenuPropertiesDelegate;', 'import org.chromium.chrome.browser.undo_tab_close_snackbar.UndoBarController;', 'import org.chromium.chrome.browser.usage_stats.UsageStatsService;', 'import org.chromium.chrome.browser.util.ChromeAccessibilityUtil;', 'import org.chromium.chrome.browser.vr.VrModuleProvider;', 'import org.chromium.chrome.features.start_surface.StartSurface;', 'import org.chromium.chrome.features.start_surface.StartSurfaceConfiguration;', 'import org.chromium.chrome.features.start_surface.StartSurfaceState;', 'import org.chromium.chrome.features.start_surface.StartSurfaceUserData;', 'import org.chromium.components.browser_ui.settings.SettingsLauncher;', 'import org.chromium.components.browser_ui.util.BrowserControlsVisibilityDelegate;', 'import org.chromium.components.browser_ui.util.ComposedBrowserControlsVisibilityDelegate;', 'import org.chromium.components.embedder_support.util.UrlConstants;', 'import org.chromium.components.embedder_support.util.UrlUtilities;', 'import org.chromium.components.feature_engagement.EventConstants;', 'import org.chromium.components.messages.MessageDispatcherProvider;', 'import org.chromium.components.profile_metrics.BrowserProfileType;', 'import org.chromium.components.webapps.ShortcutSource;', 'import org.chromium.content_public.browser.LoadUrlParams;', 'import org.chromium.content_public.browser.NavigationHandle;', 'import org.chromium.content_public.browser.RenderFrameHost;', 'import org.chromium.content_public.browser.UiThreadTaskTraits;', 'import org.chromium.content_public.browser.WebContents;', 'import org.chromium.content_public.browser.WebContentsAccessibility;', 'import org.chromium.content_public.common.ContentSwitches;', 'import org.chromium.ui.base.PageTransition;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', 'import org.chromium.ui.widget.Toast;', '', 'import java.lang.annotation.Retention;', 'import java.lang.annotation.RetentionPolicy;', 'import java.util.HashSet;', 'import java.util.List;', 'import java.util.Locale;', '', '/**', ' * This is the main activity for ChromeMobile when not running in document mode.  All the tabs', ' * are accessible via a chrome specific tab switching UI.', ' */', 'public class ChromeTabbedActivity extends ChromeActivity<ChromeActivityComponent>', '        implements ChromeAccessibilityUtil.Observer {', '    private static final String TAG = ""ChromeTabbedActivity"";', '', '    private static final String HELP_URL_PREFIX = ""https://support.google.com/chrome/"";', '', '    protected static final String WINDOW_INDEX = ""window_index"";', '', '    private static final String IS_INCOGNITO_SELECTED = ""is_incognito_selected"";', '', '    private static final int INVALID_WINDOW_ID = TabWindowManager.INVALID_WINDOW_INDEX;', '', '    // How long to delay closing the current tab when our app is minimized.  Have to delay this', ""    // so that we don't show the contents of the next tab while minimizing."", '    private static final long CLOSE_TAB_ON_MINIMIZE_DELAY_MS = 500;', '', '    // Maximum delay for initial tab creation. This is for homepage and NTP, not previous tabs', '    // restore. This is needed because we do not know when reading PartnerBrowserCustomizations', '    // provider will be finished.', '    private static final int INITIAL_TAB_CREATION_TIMEOUT_MS = 500;', '', '    /**', '     * Sending an intent with this action to Chrome will cause it to close all tabs', '     * (iff the --enable-test-intents command line flag is set). If a URL is supplied in the', '     * intent data, this will be loaded and unaffected by the close all action.', '     */', '    private static final String ACTION_CLOSE_TABS =', '            ""com.google.android.apps.chrome.ACTION_CLOSE_TABS"";', '', '    @VisibleForTesting', '    public static final String STARTUP_UMA_HISTOGRAM_SUFFIX = "".Tabbed"";', '', '    // Name of the ChromeTabbedActivity alias that handles MAIN intents.', '    public static final String MAIN_LAUNCHER_ACTIVITY_NAME = ""com.google.android.apps.chrome.Main"";', '', '    public static final SettingsLauncher SETTINGS_LAUNCHER = new SettingsLauncherImpl();', '', '    public static final HashSet<String> TABBED_MODE_COMPONENT_NAMES = new HashSet<String>() {', '        {', '            add(ChromeTabbedActivity.class.getName());', '            add(MultiInstanceChromeTabbedActivity.class.getName());', '            add(ChromeTabbedActivity2.class.getName());', '            add(MAIN_LAUNCHER_ACTIVITY_NAME);', '        }', '    };', '', '    /**', '     * Identifies a histogram to use in {@link #maybeDispatchExplicitMainViewIntent(Intent, int)}.', '     */', '    @IntDef({DispatchedBy.ON_CREATE, DispatchedBy.ON_NEW_INTENT})', '    @Retention(RetentionPolicy.SOURCE)', '    private @interface DispatchedBy {', '        int ON_CREATE = 1;', '        int ON_NEW_INTENT = 2;', '    }', '', '    // Count histogram used to track number of tabs when we show the Overview on Return to Chrome.', '    private static final String TAB_COUNT_ON_RETURN = ""Tabs.TabCountOnStartScreenShown"";', '', '    private final MainIntentBehaviorMetrics mMainIntentMetrics;', '    private @Nullable MultiInstanceManager mMultiInstanceManager;', '', '    private UndoBarController mUndoBarPopupController;', '', '    private LayoutManagerChrome mLayoutManager;', '', '    private ViewGroup mContentContainer;', '', '    private ToolbarControlContainer mControlContainer;', '', '    private TabbedModeTabModelOrchestrator mTabModelOrchestrator;', '    private TabModelSelectorBase mTabModelSelector;', '    private TabModelSelectorTabObserver mTabModelSelectorTabObserver;', '    private TabModelSelectorTabModelObserver mTabModelObserver;', '', '    private BrowserControlsVisibilityDelegate mVrBrowserControlsVisibilityDelegate;', '    private TabModalLifetimeHandler mTabModalHandler;', '', '    private boolean mUIWithNativeInitialized;', '', '    private Boolean mIsAccessibilityTabSwitcherEnabled;', '', '    private LocaleManager mLocaleManager;', '', '    private AppIndexingUtil mAppIndexingUtil;', '', '    private Runnable mShowHistoryRunnable;', '', '    private CompositorViewHolder mCompositorViewHolder;', '    private OverviewListLayout mOverviewListLayout;', '    /**', '     * Keeps track of whether or not a specific tab was created based on the startup intent.', '     */', '    private boolean mCreatedTabOnStartup;', '', '    // Whether or not the initial tab is being created.', '    private boolean mPendingInitialTabCreation;', '', '    // Whether {@link setInitialOverviewState()} has been called within the current onStart/onStop', '    // session.', '    private boolean mHasDeterminedOverviewStateForCurrentSession;', '    /**', '     *  Keeps track of the pref for the last time since this activity was stopped.', '     */', '    private ChromeInactivityTracker mInactivityTracker;', '', ""    // This is the cached value of mIntentHandler#shouldIgnoreIntent and shouldn't be read directly."", '    // Use #shouldIgnoreIntent instead.', '    private Boolean mShouldIgnoreIntent;', '    /*', '     *  Listens to FrameMetrics and records jank metrics.', '     */', '    private JankTrackerImpl mJankTracker;', '', '    // Supplier for a dependency to inform about the type of intent used to launch Chrome.', '    private OneshotSupplierImpl<ToolbarIntentMetadata> mIntentMetadataOneshotSupplier =', '            new OneshotSupplierImpl<>();', '', '    // Time at which an intent was received and handled.', '    private long mIntentHandlingTimeMs;', '', '    /**', '     * Whether the StartSurface is shown when Chrome is launched.', '     */', '    private boolean mOverviewShownOnStart;', '', '    private NextTabPolicySupplier mNextTabPolicySupplier;', '', '    private final UnownedUserDataSupplier<StartupPaintPreviewHelper>', '            mStartupPaintPreviewHelperSupplier = new StartupPaintPreviewHelperSupplier();', '', '    private final OneshotSupplierImpl<LayoutStateProvider> mLayoutStateProviderOneshotSupplier =', '            new OneshotSupplierImpl<>();', '    // TODO(crbug.com/1108496): Removed after all usages has been migrated to LayoutStateProvider.', '    private final OneshotSupplierImpl<OverviewModeBehavior> mOverviewModeBehaviorSupplier =', '            new OneshotSupplierImpl<>();', '    private OverviewModeController mOverviewModeController;', '', '    private ObservableSupplierImpl<EphemeralTabCoordinator> mEphemeralTabCoordinatorSupplier =', '            new ObservableSupplierImpl<>();', '    private final OneshotSupplierImpl<StartSurface> mStartSurfaceSupplier =', '            new OneshotSupplierImpl<>();', '    private ObservableSupplierImpl<Tab> mStartSurfaceParentTabSupplier =', '            new ObservableSupplierImpl<>();', '', '    private CallbackController mCallbackController = new CallbackController();', '    private TabbedModeTabDelegateFactory mTabDelegateFactory;', '', '    private final AppLaunchDrawBlocker mAppLaunchDrawBlocker;', '', '    // ID assigned to each ChromeTabbedActivity instance in Android S+ where multi-instance feature', '    // is supported. This can be explicitly set in the incoming Intent or internally assigned.', '    private int mWindowId;', '', '    private final IncognitoTabHost mIncognitoTabHost = new IncognitoTabHost() {', '        @Override', '        public boolean hasIncognitoTabs() {', '            return getTabModelSelector().getModel(true).getCount() > 0;', '        }', '', '        @Override', '        public void closeAllIncognitoTabs() {', '            if (isActivityFinishingOrDestroyed()) return;', '', '            // If the tabbed activity has not yet initialized, then finish the activity to avoid', '            // timing issues with clearing the incognito tab state in the background.', '            if (!areTabModelsInitialized() || !didFinishNativeInitialization()) {', '                finish();', '                return;', '            }', '', '            getTabModelSelector().getModel(true).closeAllTabs(false, false);', '        }', '', '        @Override', '        public boolean isActiveModel() {', '            return getTabModelSelector().getModel(true).isActiveModel();', '        }', '    };', '', '    /**', '     * This class is used to warm up the chrome split ClassLoader. See SplitChromeApplication for', '     * more info', '     */', '    @UsedByReflection(""SplitChromeApplication.java"")', '    public static class Preload extends ChromeTabbedActivity {', '        private LifecycleRegistry mLifecycleRegistry;', '', '        @UsedByReflection(""SplitChromeApplication.java"")', '        public Preload() {}', '', '        @Override', '        public Lifecycle getLifecycle() {', '            if (mLifecycleRegistry == null) {', '                // LifecycleRegistry normally enforces it is called on the main thread, but this', '                // class will be preloaded in a background thread. The only method that gets called', '                // in the activity constructor is addObserver(), so just override that.', '                mLifecycleRegistry = new LifecycleRegistry(null) {', '                    @Override', '                    public void addObserver(LifecycleObserver observer) {}', '                };', '            }', '            return mLifecycleRegistry;', '        }', '    }', '', '    /**', '     * Specify the proper non-.Main-aliased Chrome Activity for the given component.', '     *', '     * @param intent The intent to set the component for.', '     * @param component The client generated component to be validated.', '     */', '    public static void setNonAliasedComponent(Intent intent, ComponentName component) {', '        assert component != null;', '        Context appContext = ContextUtils.getApplicationContext();', '        if (!TextUtils.equals(component.getPackageName(), appContext.getPackageName())) {', '            return;', '        }', '        if (component.getClassName() != null', '                && TextUtils.equals(component.getClassName(),', '                        ChromeTabbedActivity.MAIN_LAUNCHER_ACTIVITY_NAME)) {', '            // Keep in sync with the activities that the .Main alias points to in', '            // AndroidManifest.xml.', '            intent.setClass(appContext, ChromeTabbedActivity.class);', '        } else {', '            intent.setComponent(component);', '        }', '    }', '', '    /**', '     * Constructs a ChromeTabbedActivity.', '     */', '    public ChromeTabbedActivity() {', '        mMainIntentMetrics = new MainIntentBehaviorMetrics();', '', '        // AppLaunchDrawBlocker may block drawing the Activity content until the initial tab is', '        // available.', '        // clang-format off', '        mAppLaunchDrawBlocker = new AppLaunchDrawBlocker(getLifecycleDispatcher(),', '                () -> findViewById(android.R.id.content),', '                this::getIntent, this::shouldIgnoreIntent, this::isTablet,', '                this::shouldShowOverviewPageOnStart);', '        // clang-format on', '    }', '', '    @Override', '    protected void onPreCreate() {', '        super.onPreCreate();', '        mMultiInstanceManager = MultiInstanceManager.create(this, getTabModelOrchestratorSupplier(),', '                getMultiWindowModeStateDispatcher(), getLifecycleDispatcher(),', '                getModalDialogManagerSupplier(), this);', '    }', '', '    @Override', '    protected @LaunchIntentDispatcher.Action int maybeDispatchLaunchIntent(', '            Intent intent, Bundle savedInstanceState) {', '        // Detect if incoming intent is a result of Chrome recreating itself. For now, restrict this', ""        // path to reparenting to ensure the launching logic isn't disrupted."", ""        // TODO(crbug.com/1065491): Unlock this codepath for all incoming intents once it's"", '        // confirmed working and stable.', '        if (savedInstanceState != null', '                && AsyncTabParamsManagerSingleton.getInstance().hasParamsWithTabToReparent()) {', '            return LaunchIntentDispatcher.Action.CONTINUE;', '        }', '', '        if (getClass().equals(ChromeTabbedActivity.class)', '                && Intent.ACTION_MAIN.equals(intent.getAction())) {', '            // Call dispatchToTabbedActivity() for MAIN intents to activate proper multi-window', '            // TabbedActivity (i.e. if CTA2 is currently running and Chrome is started, CTA2', ""            // should be brought to front). Don't call dispatchToTabbedActivity() for non-MAIN"", '            // intents to avoid breaking cases where CTA is started explicitly (e.g. to handle', ""            // 'Move to other window' command from CTA2)."", '            return LaunchIntentDispatcher.dispatchToTabbedActivity(this, intent);', '        }', '        @LaunchIntentDispatcher.Action', '        int action = maybeDispatchExplicitMainViewIntent(intent, DispatchedBy.ON_CREATE);', '        if (action != LaunchIntentDispatcher.Action.CONTINUE) {', '            return action;', '        }', '        return super.maybeDispatchLaunchIntent(intent, savedInstanceState);', '    }', '', '    // We know of at least one app that explicitly specifies .Main activity in custom tab', ""    // intents. The app shouldn't be doing that, but until it's updated, we need to support"", '    // such use case.', '    //', '    // This method attempts to treat VIEW intents explicitly sent to .Main as custom tab', '    // intents, and dispatch them accordingly. If the intent was not dispatched, the method', '    // returns Action.CONTINUE.', '    //', '    // The method also updates the supplied boolean histogram with the dispatching result,', '    // but only if the intent is a VIEW intent sent explicitly to .Main activity.', '    private @LaunchIntentDispatcher.Action int maybeDispatchExplicitMainViewIntent(', '            Intent intent, @DispatchedBy int dispatchedBy) {', ""        // The first check ensures that this is .Main activity alias (we can't check exactly, but"", '        // this gets us sufficiently close).', '        if (getClass().equals(ChromeTabbedActivity.class)', '                && Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getComponent() != null', '                && MAIN_LAUNCHER_ACTIVITY_NAME.equals(intent.getComponent().getClassName())) {', '            @LaunchIntentDispatcher.Action', '            int action = LaunchIntentDispatcher.dispatchToCustomTabActivity(this, intent);', '            switch (dispatchedBy) {', '                case DispatchedBy.ON_CREATE:', '                    RecordHistogram.recordBooleanHistogram(', '                            ""Android.MainActivity.ExplicitMainViewIntentDispatched.OnCreate"",', '                            action != LaunchIntentDispatcher.Action.CONTINUE);', '                    break;', '                case DispatchedBy.ON_NEW_INTENT:', '', '                    RecordHistogram.recordBooleanHistogram(', '                            ""Android.MainActivity.ExplicitMainViewIntentDispatched.OnNewIntent"",', '                            action != LaunchIntentDispatcher.Action.CONTINUE);', '                    break;', '                default:', '                    assert false : ""Unknown dispatchedBy value "" + dispatchedBy;', '            }', '            if (action == LaunchIntentDispatcher.Action.CONTINUE) {', '                // Intent was not dispatched, record its source.', '                @IntentHandler.ExternalAppId', '                int externalId = IntentHandler.determineExternalIntentSource(intent);', '                RecordHistogram.recordEnumeratedHistogram(', '                        ""Android.MainActivity.UndispatchedExplicitMainViewIntentSource"", externalId,', '                        IntentHandler.ExternalAppId.NUM_ENTRIES);', '', ""                // Crash if intent came from us, but only in debug builds and only if we weren't"", ""                // explicitly told not to. Hopefully we'll get enough reports to find where"", '                // these intents come from.', '                if (externalId == IntentHandler.ExternalAppId.CHROME', '                        && 0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE)', '                        && !CommandLine.getInstance().hasSwitch(', '                                ChromeSwitches.DONT_CRASH_ON_VIEW_MAIN_INTENTS)) {', '                    String intentInfo = intent.toString();', '                    Bundle extras = intent.getExtras();', '                    if (extras != null) {', '                        intentInfo +=', '                                "", extras.keySet = ["" + TextUtils.join("", "", extras.keySet()) + ""]"";', '                    }', '                    String message = String.format((Locale) null,', '                            ""VIEW intent sent to .Main activity alias was not dispatched. PLEASE ""', '                                    + ""report the following info to crbug.com/789732: \\""%s\\"". Use ""', '                                    + ""--%s flag to disable this check."",', '                            intentInfo, ChromeSwitches.DONT_CRASH_ON_VIEW_MAIN_INTENTS);', '                    throw new IllegalStateException(message);', '                }', '            }', '            return action;', '        }', '        return LaunchIntentDispatcher.Action.CONTINUE;', '    }', '', '    @Override', '    public void initializeCompositor() {', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.initializeCompositor"");', '            super.initializeCompositor();', '', '            // LocaleManager can only function after the native library is loaded.', '            mLocaleManager = LocaleManager.getInstance();', '            mLocaleManager.setSettingsLauncher(SETTINGS_LAUNCHER);', '            mLocaleManager.showSearchEnginePromoIfNeeded(this, null);', '', '            mTabModelOrchestrator.onNativeLibraryReady(getTabContentManager());', '', '            mTabModelObserver = new TabModelSelectorTabModelObserver(mTabModelSelector) {', '                @Override', '                public void didCloseTab(int tabId, boolean incognito) {', '                    closeIfNoTabsAndHomepageEnabled(false);', '                }', '', '                @Override', '                public void tabPendingClosure(Tab tab) {', '                    closeIfNoTabsAndHomepageEnabled(true);', '                }', '', '                @Override', '                public void tabRemoved(Tab tab) {', '                    closeIfNoTabsAndHomepageEnabled(false);', '                }', '', '                private void closeIfNoTabsAndHomepageEnabled(boolean isPendingClosure) {', '                    if (getTabModelSelector().getTotalTabCount() == 0) {', '                        // If the last tab is closed, and homepage is enabled, then exit Chrome.', '                        if (HomepageManager.shouldCloseAppWithZeroTabs()) {', '                            finish();', '                        } else if (isPendingClosure) {', '                            NewTabPageUma.recordNTPImpression(', '                                    NewTabPageUma.NTP_IMPESSION_POTENTIAL_NOTAB);', '                        }', '                    }', '', '                    // TODO(960196) : remove this when the associated bug fix. This is a band-aid', '                    //  fix for TabGrid and closing tabs with TabGroupUi.', '                    //  If one of the following is true, then exit Chrome when TabGroupsAndroid is', '                    //  enabled, and tab switcher is not shown:', '                    //   1. If the very last tab is closed.', '                    //   2. If normal tab model is selected and no normal tabs.', '                    if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(ChromeTabbedActivity.this)', '                            && !mOverviewModeController.overviewVisible()) {', '                        if (getTabModelSelector().getTotalTabCount() == 0', '                                || (!getTabModelSelector().isIncognitoSelected()', '                                        && getTabModelSelector().getModel(false).getCount() == 0)) {', '                            finish();', '                        }', '                    }', '                }', '', '                @Override', '                public void didAddTab(', '                        Tab tab, @TabLaunchType int type, @TabCreationState int creationState) {', '                    if (type == TabLaunchType.FROM_LONGPRESS_BACKGROUND', '                            && !DeviceClassManager.enableAnimations()) {', '                        Toast.makeText(ChromeTabbedActivity.this, R.string.open_in_new_tab_toast,', '                                     Toast.LENGTH_SHORT)', '                                .show();', '                    }', '                }', '', '                @Override', '                public void multipleTabsPendingClosure(List<Tab> tabs, boolean isAllTabs) {', '                    if (!isAllTabs) return;', '                    NewTabPageUma.recordNTPImpression(NewTabPageUma.NTP_IMPESSION_POTENTIAL_NOTAB);', '                }', '            };', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.initializeCompositor"");', '        }', '    }', '', '    private void refreshSignIn() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.refreshSignIn"")) {', '            FirstRunSignInProcessor.start(this);', '        }', '    }', '', '    private void setupCompositorContentPreNativeForPhone() {', '        if (isTablet()) return;', '', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPreNativeForPhone"")) {', '            CompositorViewHolder compositorViewHolder = getCompositorViewHolderSupplier().get();', '', '            // TODO(1169205): Remove all GTS enabled checks after M5 is default.', '            if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(this)) {', '                TabManagementDelegate tabManagementDelegate =', '                        TabManagementModuleProvider.getDelegate();', '                if (tabManagementDelegate != null) {', '                    StartSurface startSurface = tabManagementDelegate.createStartSurface(this,', '                            mRootUiCoordinator.getScrimCoordinator(),', '                            mRootUiCoordinator.getBottomSheetController(), mStartSurfaceSupplier,', '                            mStartSurfaceParentTabSupplier, hadWarmStart(), getWindowAndroid(),', '                            compositorViewHolder, compositorViewHolder::getDynamicResourceLoader,', '                            getTabModelSelector(), getBrowserControlsManager(),', '                            getSnackbarManager(), getShareDelegateSupplier(),', '                            getToolbarManager()::getOmniboxStub, getTabContentManager(),', '                            getModalDialogManager(),', '                            /* chromeActivityNativeDelegate= */ this, getLifecycleDispatcher(),', '                            getTabCreatorManagerSupplier().get(),', '                            getMenuOrKeyboardActionController(),', '                            getMultiWindowModeStateDispatcher(), mJankTracker,', '                            getToolbarManager()::getToolbar);', '                }', '            }', '', '            // clang-format off', '            mLayoutManager = new LayoutManagerChromePhone(compositorViewHolder, mContentContainer,', '                    mStartSurfaceSupplier.get(), getTabContentManagerSupplier(),', '                    () -> {', '                        if (!getCompositorViewHolderSupplier().hasValue()) return null;', '                        return getCompositorViewHolderSupplier().get().getLayerTitleCache();', '                    },', '                    mOverviewModeBehaviorSupplier,', '                    mRootUiCoordinator::getTopUiThemeColorProvider, mJankTracker);', '            mLayoutStateProviderOneshotSupplier.set(mLayoutManager);', '            // clang-format on', '            mOverviewModeController = mLayoutManager;', '        }', '    }', '', '    private void setupCompositorContentPreNativeForTablet() {', '        if (!isTablet()) return;', '', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPreNativeForTablet"")) {', '            // clang-format off', '            mLayoutManager = new LayoutManagerChromeTablet(getCompositorViewHolderSupplier().get(),', '                    mContentContainer, getTabContentManagerSupplier(),', '                    () -> {', '                        if (!getCompositorViewHolderSupplier().hasValue()) return null;', '                        return getCompositorViewHolderSupplier().get().getLayerTitleCache();', '                    },', '                    mOverviewModeBehaviorSupplier,', '                    mRootUiCoordinator::getTopUiThemeColorProvider, mJankTracker);', '            mLayoutStateProviderOneshotSupplier.set(mLayoutManager);', '            // clang-format on', '            mOverviewModeController = mLayoutManager;', '        }', '    }', '', '    private void setupCompositorContentPostNative() {', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPostNative"")) {', '            if (!isLayoutManagerCreated()) {', '                if (isTablet()) {', '                    setupCompositorContentPreNativeForTablet();', '                } else {', '                    setupCompositorContentPreNativeForPhone();', '                }', '            }', '', '            mLayoutManager.setEnableAnimations(DeviceClassManager.enableAnimations());', '', '            // TODO(yusufo): get rid of findViewById(R.id.url_bar).', '            initializeCompositorContent(mLayoutManager, findViewById(R.id.url_bar),', '                    mContentContainer, mControlContainer);', '        }', '    }', '', '    private boolean isLayoutManagerCreated() {', '        return mLayoutManager != null;', '    }', '', '    private void initializeToolbarManager() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.initializeToolbarManager"")) {', '            mUndoBarPopupController.initialize();', '', '            OnClickListener tabSwitcherClickHandler = v -> {', '                if (ChromeFeatureList.isEnabled(ChromeFeatureList.TOOLBAR_IPH_ANDROID)) {', '                    Profile profile = mTabModelProfileSupplier.get();', '                    if (profile != null) {', '                        TrackerFactory.getTrackerForProfile(profile).notifyEvent(', '                                EventConstants.TAB_SWITCHER_BUTTON_CLICKED);', '                    }', '                }', '', '                if (getFullscreenManager().getPersistentFullscreenMode()) {', '                    return;', '                }', '', '                if (isInOverviewMode()', '                        && !ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '                    hideOverview();', '                } else {', '                    showOverview(StartSurfaceState.SHOWING_TABSWITCHER);', '                }', '            };', '            OnClickListener newTabClickHandler = v -> {', '                getTabModelSelector().getModel(false).commitAllTabClosures();', '                // This assumes that the keyboard can not be seen at the same time as the', '                // newtab button on the toolbar.', '                getCurrentTabCreator().launchNTP();', '                mLocaleManager.showSearchEnginePromoIfNeeded(ChromeTabbedActivity.this, null);', '                if (getTabModelSelector().isIncognitoSelected()) {', '                    RecordUserAction.record(""MobileToolbarStackViewNewIncognitoTab"");', '                } else {', '                    RecordUserAction.record(""MobileToolbarStackViewNewTab"");', '                }', '                RecordUserAction.record(""MobileTopToolbarNewTabButton"");', '', '                RecordUserAction.record(""MobileNewTabOpened"");', '                ReturnToChromeExperimentsUtil.onNewTabOpened();', '            };', '            OnClickListener bookmarkClickHandler = v -> addOrEditBookmark(getActivityTab());', '', '            Supplier<Boolean> showStartSurfaceSupplier = () -> {', '                // If incognito is selected, tapping the home button stays on the current incognito', '                // tab.', '                if (ReturnToChromeExperimentsUtil.shouldShowStartSurfaceAsTheHomePageOnPhone(', '                            this, isTablet())', '                        && !mTabModelSelector.isIncognitoSelected()) {', '                    StartSurfaceUserData.setKeepTab(getActivityTab(), true);', '                    showOverview(StartSurfaceState.SHOWING_HOMEPAGE);', '                    return true;', '                }', '                return false;', '            };', '', '            getToolbarManager().initializeWithNative(mLayoutManager, tabSwitcherClickHandler,', '                    newTabClickHandler, bookmarkClickHandler, null, showStartSurfaceSupplier);', '', '            if (!TabUiFeatureUtilities.supportInstantStart(isTablet(), this)) {', '                assert !(mOverviewModeController != null', '                        && mOverviewModeController.overviewVisible());', '            }', '        }', '    }', '', '    private void maybeCreateIncognitoTabSnapshotController() {', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.maybeCreateIncognitoTabSnapshotController"")) {', '            if (!CommandLine.getInstance().hasSwitch(', '                        ChromeSwitches.ENABLE_INCOGNITO_SNAPSHOTS_IN_ANDROID_RECENTS)) {', '                IncognitoTabSnapshotController.createIncognitoTabSnapshotController(', '                        this, getWindow(), mLayoutManager, mTabModelSelector);', '            }', '', '            mUIWithNativeInitialized = true;', '            onAccessibilityTabSwitcherModeChanged();', '', '            // The dataset has already been created, we need to initialize our state.', '            mTabModelSelector.notifyChanged();', '', '            // Check for incognito tabs to handle the case where Chrome was swiped away in the', '            // background.', '            if (!IncognitoTabHostUtils.doIncognitoTabsExist()) {', '                IncognitoNotificationManager.dismissIncognitoNotification();', '                DownloadNotificationService.getInstance().cancelOffTheRecordDownloads();', '            }', '        }', '    }', '', '    private void maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.""', '                     + ""maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver"")) {', '            FeedSurfaceTracker.getInstance().startup();', '', '            if (UsageStatsService.isEnabled()) {', '                UsageStatsService.getInstance().createPageViewObserver(', '                        this, getActivityTabProvider(), getTabContentManagerSupplier());', '            }', '        }', '    }', '', '    private void initJourneyManager() {', '        assert mOverviewModeController != null;', '', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.initJourneyManager"")) {', '            if (ChromeFeatureList.isEnabled(ChromeFeatureList.TAB_ENGAGEMENT_REPORTING_ANDROID)) {', '                // The lifecycle of this object is managed by the lifecycle dispatcher.', '                new JourneyManager(getTabModelSelector(), getLifecycleDispatcher(),', '                        mOverviewModeController, new EngagementTimeUtil());', '            }', '        }', '    }', '', '    @Override', '    public void onNewIntent(Intent intent) {', ""        // The intent to use in maybeDispatchExplicitMainViewIntent(). We're explicitly"", '        // adding NEW_TASK flag to make sure backing from CCT brings up the caller activity,', '        // and not Chrome', '        Intent intentForDispatching = new Intent(intent);', '        intentForDispatching.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);', '        @LaunchIntentDispatcher.Action', '        int action = maybeDispatchExplicitMainViewIntent(', '                intentForDispatching, DispatchedBy.ON_NEW_INTENT);', '        if (action != LaunchIntentDispatcher.Action.CONTINUE) {', '            // Pressing back button in CCT should bring user to the caller activity.', '            moveTaskToBack(true);', '            // Intent was dispatched to CustomTabActivity, consume it.', '            return;', '        }', '', '        mIntentHandlingTimeMs = SystemClock.uptimeMillis();', '        super.onNewIntent(intent);', '    }', '', '    @Override', '    public void startNativeInitialization() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.startNativeInitialization"")) {', ""            // This is on the critical path so don't delay."", '            if (ChromeFeatureList.isEnabled(', '                        ChromeFeatureList.DARKEN_WEBSITES_CHECKBOX_IN_THEMES_SETTING)) {', '                WebContentsDarkModeController.createInstance();', '            }', '            setupCompositorContentPostNative();', '', ""            // All this initialization can be expensive so it's split into multiple tasks."", '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::refreshSignIn));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::initializeToolbarManager));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::maybeCreateIncognitoTabSnapshotController));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::onAccessibilityTabSwitcherModeChanged));', '', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::initJourneyManager));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::finishNativeInitialization));', '            ChromeAccessibilityUtil.get().addObserver(this);', '        }', '    }', '', '    @Override', '    public void finishNativeInitialization() {', '        super.finishNativeInitialization();', '', '        // TODO(jinsukkim): Let these classes handle the registration by themselves.', '        mCompositorViewHolder = getCompositorViewHolderSupplier().get();', '        mOverviewListLayout = (OverviewListLayout) mLayoutManager.getOverviewListLayout();', '        getTabObscuringHandler().addObserver(mCompositorViewHolder);', '        getTabObscuringHandler().addObserver(mOverviewListLayout);', '', '        ChromeAccessibilityUtil.get().addObserver(mLayoutManager);', '        if (isTablet()) ChromeAccessibilityUtil.get().addObserver(mCompositorViewHolder);', '    }', '', '    @Override', '    public void onResumeWithNative() {', '        super.onResumeWithNative();', '', '        IncognitoStartup.onResumeWithNative(', '                getTabModelSelectorSupplier(), TABBED_MODE_COMPONENT_NAMES);', '', '        mLocaleManager.setSnackbarManager(getSnackbarManager());', '        mLocaleManager.startObservingPhoneChanges();', '', '        if (isWarmOnResume()) {', '            NavigationPredictorBridge.onActivityWarmResumed();', '        } else {', '            NavigationPredictorBridge.onColdStart();', '        }', '', '        // This call is not guarded by a feature flag.', '        SearchEngineChoiceNotification.handleSearchEngineChoice(', '                this, getSnackbarManager(), SETTINGS_LAUNCHER);', '', '        if (!isWarmOnResume()) {', '            SuggestionsMetrics.recordArticlesListVisible();', '        }', '    }', '', '    @Override', '    public void onPauseWithNative() {', '        mTabModelSelector.commitAllTabClosures();', '        CookiesFetcher.persistCookies();', '', '        mLocaleManager.setSnackbarManager(null);', '        mLocaleManager.stopObservingPhoneChanges();', '', '        NavigationPredictorBridge.onPause();', '', '        super.onPauseWithNative();', '    }', '', '    @Override', '    public void onStopWithNative() {', '        super.onStopWithNative();', '', '        mTabModelOrchestrator.saveState();', '        mHasDeterminedOverviewStateForCurrentSession = false;', '    }', '', '    @Override', '    public void onStartWithNative() {', '        mMainIntentMetrics.logLaunchBehavior();', '        super.onStartWithNative();', '', ""        // Don't call setInitialOverviewState if we're waiting for the tab's creation or we risk"", '        // showing a glimpse of the tab selector during start up.', '        if (!mPendingInitialTabCreation) {', '            setInitialOverviewState();', '        }', '', '        if (TabUiFeatureUtilities.isConditionalTabStripEnabled()', '                || ConditionalTabStripUtils.getOptOutIndicator()) {', '            ConditionalTabStripUtils.updateFeatureExpiration(', '                    mInactivityTracker.getLastBackgroundedTimeMs());', '        }', '', '        Bundle savedInstanceState = getSavedInstanceState();', '        if (savedInstanceState != null', '                && savedInstanceState.getBoolean(IS_INCOGNITO_SELECTED, false)) {', '            // This will be executed only once since SavedInstanceState will be reset a few lines', '            // later.', '            AndroidSessionDurationsServiceState.restoreNativeFromSerialized(savedInstanceState,', '                    getCurrentTabModel().getProfile().getPrimaryOTRProfile(', '                            /* createIfNeeded= */ true));', '        }', '', '        resetSavedInstanceState();', '        StartSurfaceConfiguration.addFeedVisibilityObserver();', '        BookmarkUtils.maybeExpireLastBookmarkLocationForReadLater(', '                mInactivityTracker.getTimeSinceLastBackgroundedMs());', '    }', '', '    @Override', '    public void onNewIntentWithNative(Intent intent) {', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.onNewIntentWithNative"");', '', '            super.onNewIntentWithNative(intent);', '            if (IntentUtils.isMainIntentFromLauncher(intent)) {', '                logMainIntentBehavior(intent);', '            }', '', '            if (CommandLine.getInstance().hasSwitch(ContentSwitches.ENABLE_TEST_INTENTS)) {', '                handleDebugIntent(intent);', '            }', '', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.onNewIntentWithNative"");', '        }', '    }', '', '    @Override', '    public @ActivityType int getActivityType() {', '        return ActivityType.TABBED;', '    }', '', '    @Override', '    public ChromeTabCreator getTabCreator(boolean incognito) {', '        return (ChromeTabCreator) super.getTabCreator(incognito);', '    }', '', '    @Override', '    public ChromeTabCreator getCurrentTabCreator() {', '        return (ChromeTabCreator) super.getCurrentTabCreator();', '    }', '', '    @Override', '    public OverviewModeBehavior getOverviewModeBehavior() {', '        return mOverviewModeController;', '    }', '', '    @Override', '    public @Nullable OneshotSupplier<OverviewModeBehavior> getOverviewModeBehaviorSupplier() {', '        return mOverviewModeBehaviorSupplier;', '    }', '', '    /**', '     * @return The toolbar button in-product help controller for this activity.', '     * TODO(pnoland, https://crbug.com/865801): remove this in favor', ""     *        of injecting the controller directly where it's needed."", '     */', '    public ToolbarButtonInProductHelpController getToolbarButtonInProductHelpController() {', '        return ((TabbedRootUiCoordinator) mRootUiCoordinator)', '                .getToolbarButtonInProductHelpController();', '    }', '', '    private void handleDebugIntent(Intent intent) {', '        if (ACTION_CLOSE_TABS.equals(intent.getAction())) {', '            getTabModelSelector().closeAllTabs();', '        } else if (MemoryPressureListener.handleDebugIntent(', '                           ChromeTabbedActivity.this, intent.getAction())) {', '            // Handled.', '        }', '    }', '', '    private void setTrackColdStartupMetrics(boolean shouldTrackColdStartupMetrics) {', '        assert getActivityTabStartupMetricsTracker() != null;', '', '        if (shouldTrackColdStartupMetrics) {', '            getActivityTabStartupMetricsTracker().trackStartupMetrics(STARTUP_UMA_HISTOGRAM_SUFFIX);', '        } else {', '            getActivityTabStartupMetricsTracker().cancelTrackingStartupMetrics();', '        }', '', '        // Paint Preview should follow the same logic as startup UMA histograms as the feature', '        // should only run on cold startup of Chrome when the user is unable to interact before', '        // entering a tab.', '        StartupPaintPreviewHelper.setShouldShowOnRestore(shouldTrackColdStartupMetrics);', '    }', '', '    private void setInitialOverviewState() {', '        if (mHasDeterminedOverviewStateForCurrentSession) return;', '', '        mHasDeterminedOverviewStateForCurrentSession = true;', '        boolean isOverviewVisible = mOverviewModeController.overviewVisible();', '', '        if (shouldRefreshAndShowOverview(isOverviewVisible)) {', '            if (getCurrentTabModel() != null) {', '                RecordHistogram.recordCountHistogram(', '                        TAB_COUNT_ON_RETURN, getCurrentTabModel().getCount());', '            }', '            if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(this) && !isTablet()) {', '                mStartSurfaceSupplier.get().getController().enableRecordingFirstMeaningfulPaint(', '                        getOnCreateTimestampMs());', '            }', '            mOverviewShownOnStart = true;', '            // Cancel recording cold startup metrics if an overview is shown as they expect a tab to', '            // be the first thing shown after startup.', '            setTrackColdStartupMetrics(false);', '            showOverview(StartSurfaceState.SHOWING_START);', '            return;', '        }', '', '        if (getActivityTab() == null && !isOverviewVisible) {', '            mOverviewShownOnStart = true;', '            // Cancel recording cold startup metrics if an overview is shown as they expect a tab to', '            // be the first thing shown after startup.', '            setTrackColdStartupMetrics(false);', '            showOverview(StartSurfaceState.SHOWING_START);', '        }', '', '        if (IntentUtils.isMainIntentFromLauncher(getIntent())', '                && mOverviewModeController.overviewVisible()) {', '            RecordUserAction.record(""MobileStartup.UserEnteredTabSwitcher"");', '        }', '    }', '', '    private boolean shouldRefreshAndShowOverview(boolean isOverviewVisible) {', '        // If StartSurfaceConfiguration.NEW_SURFACE_FROM_HOME_BUTTON is turned on, MV tiles and', '        // carousels may be hidden before Chrome is brought to the background. If overview should be', '        // shown, no matter overview was already visible or not, we should call', '        // showOverview(StartSurfaceState.SHOWING_START) to show MV tiles and carousels again.', '        return shouldShowOverviewPageOnStart()', '                && (!isOverviewVisible', '                        || StartSurfaceConfiguration.shouldShowNewSurfaceFromHomeButton());', '    }', '', '    /**', '     * Returns whether grid Tab switcher or the Start surface should be shown at startup.', '     */', '    private boolean shouldShowOverviewPageOnStart() {', '        return ReturnToChromeExperimentsUtil.shouldShowOverviewPageOnStart(', '                this, getIntent(), getTabModelSelector(), mInactivityTracker);', '    }', '', '    private void logMainIntentBehavior(Intent intent) {', '        assert IntentUtils.isMainIntentFromLauncher(intent);', '        // TODO(tedchoc): We should cache the last visible time and reuse it to avoid different', '        //                values of this depending on when it is called after the activity was', '        //                shown.', '', '        // Temporary safety check to make sure none of this code runs if the feature is', '        // disabled.', '        if (ReengagementNotificationController.isEnabled()) {', '            if (mCallbackController != null) {', '                new OneShotCallback<>(', '                        mTabModelProfileSupplier, mCallbackController.makeCancelable(profile -> {', '                            assert profile != null : ""Unexpectedly null profile from TabModel."";', '                            if (profile == null) return;', '', '                            TrackerFactory.getTrackerForProfile(profile).notifyEvent(', '                                    EventConstants.STARTED_FROM_MAIN_INTENT);', '                        }));', '            }', '        }', '', '        mMainIntentMetrics.onMainIntentWithNative(', '                mInactivityTracker.getTimeSinceLastBackgroundedMs());', '    }', '', '    /** Access the main intent metrics for test validation. */', '    @VisibleForTesting', '    public MainIntentBehaviorMetrics getMainIntentBehaviorMetricsForTesting() {', '        return mMainIntentMetrics;', '    }', '', '    @VisibleForTesting', '    public ChromeInactivityTracker getInactivityTrackerForTesting() {', '        return mInactivityTracker;', '    }', '', '    @Override', '    public void initializeState() {', '        // This method goes through 3 steps:', ""        // 1. Load the saved tab state (but don't start restoring the tabs yet)."", '        // 2. Process the Intent that this activity received and if that should result in any', '        //    new tabs, create them.  This is done after step 1 so that the new tab gets', '        //    created after previous tab state was restored.', '        // 3. If no tabs were created in any of the above steps, create an NTP, otherwise', '        //    start asynchronous tab restore (loading the previously active tab synchronously', '        //    if no new tabs created in step 2).', '', '        // Only look at the original intent if this is not a ""restoration"" and we are allowed to', '        // process intents. Any subsequent intents are carried through onNewIntent.', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.initializeState"");', '', '            super.initializeState();', '            Log.i(TAG, ""#initializeState"");', '            Intent intent = getIntent();', '', '            boolean hadCipherData =', '                    CipherFactory.getInstance().restoreFromBundle(getSavedInstanceState());', '', '            boolean noRestoreState =', '                    CommandLine.getInstance().hasSwitch(ChromeSwitches.NO_RESTORE_STATE);', '            if (noRestoreState) {', '                // Clear the state files because they are inconsistent and useless from now on.', '                mTabModelOrchestrator.clearState();', '            } else {', '                // State should be clear when we start first run and hence we do not need to load', '                // a previous state. This may change the current Model, watch out for initialization', '                // based on the model.', '                // Never attempt to restore incognito tabs when this activity was previously swiped', '                // away in Recents. http://crbug.com/626629', '                boolean ignoreIncognitoFiles = !hadCipherData;', '                mTabModelOrchestrator.loadState(ignoreIncognitoFiles);', '            }', '', '            mInactivityTracker.register(this.getLifecycleDispatcher());', '            boolean isIntentWithEffect = false;', '            boolean isMainIntentFromLauncher = false;', '            if (getSavedInstanceState() == null && intent != null) {', '                if (!shouldIgnoreIntent()) {', '                    isIntentWithEffect = mIntentHandler.onNewIntent(intent);', '                }', '', '                if (IntentUtils.isMainIntentFromLauncher(intent)) {', '                    isMainIntentFromLauncher = true;', '                    logMainIntentBehavior(intent);', '                }', '            }', '', '            mIntentMetadataOneshotSupplier.set(', '                    new ToolbarIntentMetadata(isMainIntentFromLauncher, isIntentWithEffect));', '', '            // If we have tabs to reparent and getSavedInstanceState() is non-null, then the tabs', '            // are coming from night mode tab reparenting. In this case, reparenting happens', '            // synchronously along with tab restoration so there are no tabs waiting for', '            // reparenting like there are for other tab reparenting operations.', '            boolean hasTabWaitingForReparenting =', '                    AsyncTabParamsManagerSingleton.getInstance().hasParamsWithTabToReparent()', '                    && getSavedInstanceState() == null;', '            mCreatedTabOnStartup = getCurrentTabModel().getCount() > 0', '                    || mTabModelOrchestrator.getRestoredTabCount() > 0 || isIntentWithEffect', '                    || hasTabWaitingForReparenting;', '', '            // We always need to try to restore tabs. The set of tabs might be empty, but at least', '            // it will trigger the notification that tab restore is complete which is needed by', '            // other parts of Chrome such as sync.', '            boolean activeTabBeingRestored = !isIntentWithEffect', '                    || (shouldShowOverviewPageOnStart()', '                            && !mTabModelSelector.isIncognitoSelected());', '', '            mTabModelOrchestrator.restoreTabs(activeTabBeingRestored);', '', '            // Only create an initial tab if no tabs were restored and no intent was handled.', '            // Also, check whether the active tab was supposed to be restored and that the total', '            // tab count is now non zero.  If this is not the case, tab restore failed and we need', '            // to create a new tab as well.', '            if (!mCreatedTabOnStartup', '                    || (!hasTabWaitingForReparenting && activeTabBeingRestored', '                            && getTabModelSelector().getTotalTabCount() == 0)) {', '                // If homepage URI is not determined, due to PartnerBrowserCustomizations provider', '                // async reading, then create a tab at the async reading finished. If it takes', '                // too long, just create NTP.', '', '                mPendingInitialTabCreation = true;', '                PartnerBrowserCustomizations.getInstance().setOnInitializeAsyncFinished(() -> {', '                    if (!isActivityFinishingOrDestroyed()) {', '                        createInitialTab();', '                    }', '                }, INITIAL_TAB_CREATION_TIMEOUT_MS);', '            }', '', '            // If initial tab creation is pending, this will instead be handled when we create the', '            // initial tab in #createInitialTab.', '            if (!mPendingInitialTabCreation) {', '                mAppLaunchDrawBlocker.onActiveTabAvailable(isTabRegularNtp(getActivityTab()));', '            }', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.initializeState"");', '        }', '    }', '', '    private boolean hasStartWithNativeBeenCalled() {', '        int activity_state = getLifecycleDispatcher().getCurrentActivityState();', '        return activity_state == ActivityLifecycleDispatcher.ActivityState.STARTED_WITH_NATIVE', '                || activity_state == ActivityLifecycleDispatcher.ActivityState.RESUMED_WITH_NATIVE;', '    }', '', '    /**', '     * Create an initial tab for cold start without restored tabs.', '     */', '    private void createInitialTab() {', '        Log.i(TAG, ""#createInitialTab executed."");', '        mPendingInitialTabCreation = false;', '', '        // If the start surface or grid tab switcher will be shown on start, do not create a new', '        // tab.', '        if (!shouldShowOverviewPageOnStart()) {', '            String url = HomepageManager.getHomepageUri();', '            if (TextUtils.isEmpty(url)) {', '                url = UrlConstants.NTP_URL;', '            } else {', '                // Migrate legacy NTP URLs (chrome://newtab) to the newer format', '                // (chrome-native://newtab)', '                if (UrlUtilities.isNTPUrl(url)) {', '                    url = UrlConstants.NTP_URL;', '                }', '            }', '', '            getTabCreator(false).launchUrl(url, TabLaunchType.FROM_STARTUP);', '        }', '', ""        // If we didn't call setInitialOverviewState() in onStartWithNative() because"", '        // mPendingInitialTabCreation was true then do so now.', '        if (hasStartWithNativeBeenCalled()) {', '            setInitialOverviewState();', '        }', '', '        mAppLaunchDrawBlocker.onActiveTabAvailable(isTabRegularNtp(getActivityTab()));', '    }', '', '    @Override', '    public void onAccessibilityModeChanged(boolean enabled) {', '        onAccessibilityTabSwitcherModeChanged();', '    }', '', '    private void onAccessibilityTabSwitcherModeChanged() {', '        if (!mUIWithNativeInitialized) return;', '', '        boolean accessibilityTabSwitcherEnabled =', '                DeviceClassManager.enableAccessibilityLayout(this);', '        if (mOverviewModeController != null && mOverviewModeController.overviewVisible()', '                && (mIsAccessibilityTabSwitcherEnabled == null', '                        || mIsAccessibilityTabSwitcherEnabled', '                                != DeviceClassManager.enableAccessibilityLayout(this))) {', '            /**', '             * If Start surface homepage is showing and launching NTP will show the Start surface', '             * again, skips the calls of hideOverview() and launchNTP(). We need to check', '             * {@link ReturnToChromeExperimentsUtil#shouldShowStartSurfaceHomeAsNTP(Context,', '             * boolean, boolean)} to see whether Start surface can be shown when accessibility is', '             * enabled.', '             */', '            if (mStartSurfaceSupplier.get() == null', '                    || mStartSurfaceSupplier.get().getController().getStartSurfaceState()', '                            != StartSurfaceState.SHOWN_HOMEPAGE', '                    || !ReturnToChromeExperimentsUtil.shouldShowStartSurfaceHomeAsNTP(', '                            this, getCurrentTabModel().isIncognito(), isTablet())) {', '                mOverviewModeController.hideOverview(true);', '                if (getTabModelSelector().getCurrentModel().getCount() == 0) {', '                    getCurrentTabCreator().launchNTP();', '                }', '            }', '        }', '        mIsAccessibilityTabSwitcherEnabled = accessibilityTabSwitcherEnabled;', '', '        if (ChromeAccessibilityUtil.get().isAccessibilityEnabled()) {', '            RecordHistogram.recordBooleanHistogram(', '                    ""Accessibility.Android.TabSwitcherPreferenceEnabled"",', '                    mIsAccessibilityTabSwitcherEnabled);', '        }', '    }', '', '    /**', '     * Internal class which performs the intent handling operations delegated by IntentHandler.', '     */', '    private class InternalIntentDelegate implements IntentHandler.IntentHandlerDelegate {', '        /**', '         * Processes a url view intent.', '         *', '         * @param url The url from the intent.', '         */', '        @Override', '        public void processUrlViewIntent(LoadUrlParams loadUrlParams, @TabOpenType int tabOpenType,', '                String externalAppId, int tabIdToBringToFront, Intent intent) {', '            if (isActivityFinishingOrDestroyed()) {', '                return;', '            }', '            if (isFromChrome(intent, externalAppId)) {', '                RecordUserAction.record(""MobileTabbedModeViewIntentFromChrome"");', '            } else {', '                RecordUserAction.record(""MobileTabbedModeViewIntentFromApp"");', '            }', '', '            final String url = loadUrlParams.getUrl();', '            boolean fromLauncherShortcut = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_INVOKED_FROM_SHORTCUT, false);', '            boolean fromAppWidget = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_INVOKED_FROM_APP_WIDGET, false);', '            boolean focus = false;', '', '            TabModel tabModel = getCurrentTabModel();', '            switch (tabOpenType) {', '                case TabOpenType.REUSE_URL_MATCHING_TAB_ELSE_NEW_TAB:', '                    mTabModelOrchestrator.tryToRestoreTabStateForUrl(url);', '                    int tabToBeClobberedIndex = TabModelUtils.getTabIndexByUrl(tabModel, url);', '                    Tab tabToBeClobbered = tabModel.getTabAt(tabToBeClobberedIndex);', '                    if (tabToBeClobbered != null) {', '                        TabModelUtils.setIndex(tabModel, tabToBeClobberedIndex);', '                        tabToBeClobbered.reload();', '                    } else {', '                        launchIntent(loadUrlParams, externalAppId, true, intent);', '                    }', '                    int shortcutSource = intent.getIntExtra(', '                            WebappConstants.EXTRA_SOURCE, ShortcutSource.UNKNOWN);', '                    LaunchMetrics.recordHomeScreenLaunchIntoTab(url, shortcutSource);', '                    if (fromAppWidget && url.startsWith(UrlConstants.CHROME_DINO_URL)) {', '                        RecordUserAction.record(""QuickActionSearchWidget.StartDinoGame"");', '                    }', '                    break;', '                case TabOpenType.BRING_TAB_TO_FRONT:', '                    mTabModelOrchestrator.tryToRestoreTabStateForId(tabIdToBringToFront);', '', '                    int tabIndex = TabModelUtils.getTabIndexById(tabModel, tabIdToBringToFront);', '                    if (tabIndex == TabModel.INVALID_TAB_INDEX) {', '                        TabModel otherModel =', '                                getTabModelSelector().getModel(!tabModel.isIncognito());', '                        tabIndex = TabModelUtils.getTabIndexById(otherModel, tabIdToBringToFront);', '                        if (tabIndex != TabModel.INVALID_TAB_INDEX) {', '                            getTabModelSelector().selectModel(otherModel.isIncognito());', '                            TabModelUtils.setIndex(otherModel, tabIndex);', '                        } else {', '                            Log.e(TAG, ""Failed to bring tab to front because it doesn\'t exist."");', '                            return;', '                        }', '                    } else {', '                        TabModelUtils.setIndex(tabModel, tabIndex);', '                    }', '                    break;', '                case TabOpenType.CLOBBER_CURRENT_TAB:', '                    // The browser triggered the intent. This happens when clicking links which', '                    // can be handled by other applications (e.g. www.youtube.com links).', '                    Tab currentTab = getActivityTab();', '                    if (currentTab != null) {', '                        RedirectHandlerTabHelper.updateIntentInTab(currentTab, intent);', '                        currentTab.loadUrl(loadUrlParams);', '                    } else {', '                        launchIntent(loadUrlParams, externalAppId, true, intent);', '                    }', '                    break;', '                case TabOpenType.REUSE_APP_ID_MATCHING_TAB_ELSE_NEW_TAB:', '                    launchIntent(loadUrlParams, externalAppId, false, intent);', '                    break;', '                case TabOpenType.REUSE_TAB_MATCHING_ID_ELSE_NEW_TAB:', '                    int tabId = IntentUtils.safeGetIntExtra(', '                            intent, TabOpenType.REUSE_TAB_MATCHING_ID_STRING, Tab.INVALID_TAB_ID);', '                    if (tabId != Tab.INVALID_TAB_ID) {', '                        mTabModelOrchestrator.tryToRestoreTabStateForId(tabId);', '                        int matchingTabIndex = TabModelUtils.getTabIndexById(tabModel, tabId);', '                        boolean loaded = false;', '                        if (matchingTabIndex != TabModel.INVALID_TAB_INDEX) {', '                            Tab tab = tabModel.getTabAt(matchingTabIndex);', '                            if (tab.getUrl().getSpec().equals(url)', '                                    || tab.getUrl().getSpec().equals(IntentUtils.safeGetStringExtra(', '                                            intent, TabOpenType.REUSE_TAB_ORIGINAL_URL_STRING))) {', '                                tabModel.setIndex(matchingTabIndex, TabSelectionType.FROM_USER);', '                                tab.loadUrl(loadUrlParams);', '                                loaded = true;', '                            }', '                        }', '                        if (!loaded) {', '                            launchIntent(loadUrlParams, externalAppId, false, intent);', '                        }', '                    }', '                    break;', '                case TabOpenType.OPEN_NEW_TAB:', '                    if (fromLauncherShortcut) {', '                        recordLauncherShortcutAction(false);', '                        reportNewTabShortcutUsed(false);', '                    }', '', '                    launchIntent(loadUrlParams, externalAppId, true, intent);', '                    break;', '                case TabOpenType.OPEN_NEW_INCOGNITO_TAB:', '                    if (!TextUtils.equals(externalAppId, getPackageName())) {', '                        assert false : ""Only Chrome is allowed to open incognito tabs"";', '                        Log.e(TAG, ""Only Chrome is allowed to open incognito tabs"");', '                        return;', '                    }', '', '                    if (!IncognitoUtils.isIncognitoModeEnabled()) {', '                        // The incognito launcher shortcut is manipulated in #onDeferredStartup(),', ""                        // so it's possible for a user to invoke the shortcut before it's disabled."", '                        // Quick actions search widget is installed on the home screen and may', '                        // need to be updated before the incognito button is removed.', '                        // Opening an incognito tab while incognito mode is disabled from somewhere', '                        // besides the launcher shortcut of from quick action search widget is an', '                        // error.', '                        if (fromAppWidget || fromLauncherShortcut) {', '                            // We are using the message introduced for quick action search widget', '                            // for both the widget and the launcher shortcut here.', '                            Toast.makeText(ChromeTabbedActivity.this,', '                                         R.string.quick_action_search_widget_message_no_incognito,', '                                         Toast.LENGTH_LONG)', '                                    .show();', '                        } else {', '                            assert false : ""Tried to open incognito tab while incognito disabled"";', '                            Log.e(TAG, ""Tried to open incognito tab while incognito disabled"");', '                        }', '', '                        return;', '                    }', '', '                    if (url == null || url.equals(UrlConstants.NTP_URL)) {', '                        if (fromLauncherShortcut) {', '                            getTabCreator(true).launchUrl(', '                                    UrlConstants.NTP_URL, TabLaunchType.FROM_LAUNCHER_SHORTCUT);', '                            recordLauncherShortcutAction(true);', '                            reportNewTabShortcutUsed(true);', '                        } else if (fromAppWidget) {', '                            RecordUserAction.record(""QuickActionSearchWidget.StartIncognito"");', '                            getTabCreator(true).launchUrl(', '                                    UrlConstants.NTP_URL, TabLaunchType.FROM_APP_WIDGET);', '                        } else if (IncognitoTabLauncher.didCreateIntent(intent)) {', '                            Tab tab = getTabCreator(true).launchUrl(UrlConstants.NTP_URL,', '                                    TabLaunchType.FROM_LAUNCH_NEW_INCOGNITO_TAB);', '                            if (IncognitoTabLauncher.shouldFocusOmnibox(intent)) {', '                                // Since the Tab is created in the foreground, its View will gain', '                                // focus, and since the Tab and the URL bar are not yet in the same', ""                                // View hierarchy, setting the URL bar's focus here won't clear the"", ""                                // Tab's focus. When the Tab is added to the hierarchy, we want the"", ""                                // URL bar to retain focus, so we clear the Tab's focus here."", '                                tab.getView().clearFocus();', '                                focus = true;', '                            }', '', '                            IncognitoTabLauncher.recordUse();', '                        } else {', '                            // Used by the Account management screen to open a new incognito tab.', '                            // Account management screen collects its metrics separately.', '                            getTabCreator(true).launchUrl(UrlConstants.NTP_URL,', '                                    TabLaunchType.FROM_CHROME_UI, intent, mIntentHandlingTimeMs);', '                        }', '                    } else {', '                        @TabLaunchType', '                        Integer launchType = IntentHandler.getTabLaunchType(intent);', '                        if (launchType == null) launchType = TabLaunchType.FROM_LINK;', '                        getTabCreator(true).launchUrl(', '                                url, launchType, intent, mIntentHandlingTimeMs);', '                    }', '                    break;', '                default:', '                    assert false : ""Unknown TabOpenType: "" + tabOpenType;', '                    break;', '            }', '', '            getToolbarManager().setUrlBarFocusOnceNativeInitialized(focus,', '                    focus ? OmniboxFocusReason.LAUNCH_NEW_INCOGNITO_TAB', '                          : OmniboxFocusReason.UNFOCUS);', '', '            if (tabModel.getCount() > 0 && isInOverviewMode() && !isTablet()', '                    && !shouldShowOverviewPageOnStart()) {', '                mOverviewModeController.hideOverview(true);', '            }', '        }', '', '        @Override', '        public long getIntentHandlingTimeMs() {', '            return mIntentHandlingTimeMs;', '        }', '', '        @Override', '        public void processWebSearchIntent(String query) {', '            assert false;', '        }', '', '        @Override', '        public void processTranslateTabIntent(', '                @Nullable String targetLanguageCode, @Nullable String expectedUrl) {', '            TranslateIntentHandler.translateTab(getActivityTab(), targetLanguageCode, expectedUrl);', '        }', '', '        private boolean isFromChrome(Intent intent, String externalAppId) {', '            // To determine if the processed intent is from Chrome, check for any of the following:', '            // 1.) The authentication token that will be added to trusted intents.', '            // 2.) The app ID matches Chrome.  This value can be spoofed by other applications, but', '            //     in cases where we were not able to add the authentication token this is our only', '            //     indication the intent was from Chrome.', '            return IntentHandler.wasIntentSenderChrome(intent)', '                    || TextUtils.equals(externalAppId, getPackageName());', '        }', '    }', '', '    @Override', '    public void performPreInflationStartup() {', '        // Create JankTracker before invoking super, because the parent class will invoke', '        // createRootUiCoordinator(...), which in our case requires the JankTracker to already have', '        // been created.', '        mJankTracker = new JankTrackerImpl(this);', '', '        super.performPreInflationStartup();', '', '        // Decide whether to record startup UMA histograms. This is done  early in the main', '        // Activity.onCreate() to avoid recording navigation delays when they require user input to', '        // proceed. For example, FRE (First Run Experience) happens before the activity is created,', '        // and triggers initialization of the native library.', '        //', '        // An uninitialized native library is an indication of an application start that is followed', '        // by navigation immediately without user input.', '        if (!LibraryLoader.getInstance().isInitialized()) {', '            setTrackColdStartupMetrics(true);', '        }', '', '        supportRequestWindowFeature(Window.FEATURE_ACTION_MODE_OVERLAY);', '', '        IncognitoTabHostRegistry.getInstance().register(mIncognitoTabHost);', '', '        mStartupPaintPreviewHelperSupplier.attach(getWindowAndroid().getUnownedUserDataHost());', '    }', '', '    @Override', '    protected RootUiCoordinator createRootUiCoordinator() {', '        return new TabbedRootUiCoordinator(this, this::onOmniboxFocusChanged,', '                getShareDelegateSupplier(), getActivityTabProvider(), mTabModelProfileSupplier,', '                mBookmarkBridgeSupplier, this::getContextualSearchManager,', '                getTabModelSelectorSupplier(), mStartSurfaceSupplier,', '                mIntentMetadataOneshotSupplier, mLayoutStateProviderOneshotSupplier,', '                mStartSurfaceParentTabSupplier, getBrowserControlsManager(), getWindowAndroid(),', '                mJankTracker, getLifecycleDispatcher(), getLayoutManagerSupplier(),', '                /* menuOrKeyboardActionController= */ this, this::getActivityThemeColor,', '                getModalDialogManagerSupplier(), /* appMenuBlocker= */ this, this::supportsAppMenu,', '                this::supportsFindInPage, getTabCreatorManagerSupplier(), getFullscreenManager(),', '                getCompositorViewHolderSupplier(), getTabContentManagerSupplier(),', '                getOverviewModeBehaviorSupplier(), this::getSnackbarManager, getActivityType(),', '                this::isInOverviewMode, this::isWarmOnResume,', '                /* appMenuDelegate= */ this, /* statusBarColorProvider= */ this,', '                mEphemeralTabCoordinatorSupplier, getIntentRequestTracker(),', '                getControlContainerHeightResource(), this::getInsetObserverView,', '                this::backShouldCloseTab);', '    }', '', '    @Override', '    protected int getControlContainerLayoutId() {', '        return R.layout.control_container;', '    }', '', '    @Override', '    public int getControlContainerHeightResource() {', '        return R.dimen.control_container_height;', '    }', '', '    @Override', '    protected int getToolbarLayoutId() {', '        return isTablet() ? R.layout.toolbar_tablet : R.layout.toolbar_phone;', '    }', '', '    @Override', '    protected int getToolbarShadowResource() {', '        final boolean themeRefactorEnabled =', '                CachedFeatureFlags.isEnabled(ChromeFeatureList.THEME_REFACTOR_ANDROID);', '        return themeRefactorEnabled ? R.drawable.toolbar_hairline', '                                    : R.drawable.modern_toolbar_shadow;', '    }', '', '    @Override', '    protected int getToolbarShadowLayoutHeight() {', '        final int res = CachedFeatureFlags.isEnabled(ChromeFeatureList.THEME_REFACTOR_ANDROID)', '                ? R.dimen.toolbar_hairline_height', '                : R.dimen.toolbar_shadow_height;', '        return getResources().getDimensionPixelSize(res);', '    }', '', '    @Override', '    public void performPostInflationStartup() {', '        super.performPostInflationStartup();', '', '        FontPreloader.getInstance().onPostInflationStartupTabbedActivity();', '', '        TabModelSelector tabModelSelector = getTabModelSelector();', '        IncognitoProfileDestroyer.observeTabModelSelector(tabModelSelector);', '        IncognitoNotificationPresenceController.observeTabModelSelector(tabModelSelector);', '', '        // Critical path for startup. Create the minimum objects needed', '        // to allow a blank screen draw (without depending on any native code)', '        // and then yield ASAP.', '        if (isFinishing()) return;', '', ""        // Don't show the keyboard until user clicks in."", '        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN', '                | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);', '', '        mContentContainer = (ViewGroup) findViewById(android.R.id.content);', '        mControlContainer = (ToolbarControlContainer) findViewById(R.id.control_container);', '', '        Supplier<Boolean> dialogVisibilitySupplier = null;', '        if (TabUiFeatureUtilities.isTabGroupsAndroidEnabled(this)) {', '            dialogVisibilitySupplier = () -> {', '                assert mStartSurfaceSupplier.get() != null;', '                assert getToolbarManager().getTabGroupUi() != null;', '                // Return true if dialog from either tab switcher or tab strip is visible.', '', '                ToolbarManager toolbarManager = getToolbarManager();', '                TabGroupUi tabGroupUi = toolbarManager.getTabGroupUi();', '                boolean isDialogVisible = tabGroupUi.isTabGridDialogVisible();', '', '                Supplier<Boolean> tabSwitcherDialogVisibilitySupplier =', '                        mStartSurfaceSupplier.get().getTabGridDialogVisibilitySupplier();', '', '                if (tabSwitcherDialogVisibilitySupplier != null) {', '                    isDialogVisible = isDialogVisible || tabSwitcherDialogVisibilitySupplier.get();', '                }', '                return isDialogVisible;', '            };', '        }', '', '        mUndoBarPopupController = new UndoBarController(this, mTabModelSelector,', '                this::getSnackbarManager, mOverviewModeBehaviorSupplier, dialogVisibilitySupplier);', '', '        mInactivityTracker = new ChromeInactivityTracker(', '                ChromePreferenceKeys.TABBED_ACTIVITY_LAST_BACKGROUNDED_TIME_MS_PREF);', '', '        assert getActivityTabStartupMetricsTracker() != null;', '        if (StartupPaintPreviewHelper.isEnabled()) {', '            StartupPaintPreviewHelper paintPreviewHelper = new StartupPaintPreviewHelper(', '                    getWindowAndroid(), getOnCreateTimestampMs(), getBrowserControlsManager(),', '                    getTabModelSelector(), shouldShowOverviewPageOnStart(), () -> {', '                        return getToolbarManager() == null', '                                ? null', '                                : getToolbarManager().getProgressBarCoordinator();', '                    });', '            mStartupPaintPreviewHelperSupplier.set(paintPreviewHelper);', '            getActivityTabStartupMetricsTracker().registerPaintPreviewObserver(paintPreviewHelper);', '        }', '    }', '', '    private boolean shouldIgnoreIntent() {', '        if (mShouldIgnoreIntent == null) {', '            // We call this only once because mIntentHandler#shouldIgnoreIntent has side effects.', '            mShouldIgnoreIntent =', '                    mIntentHandler.shouldIgnoreIntent(getIntent(), /*startedActivity=*/true);', '        }', '        return mShouldIgnoreIntent;', '    }', '', '    @Override', '    protected final void dispatchOnInflationComplete() {', '        super.dispatchOnInflationComplete();', '', '        // When the feature flag {@link ChromeFeatureList.INSTANT_START} turns on phones (not', '        // tablet), a view-only start page created on Java will be shown before native is', '        // initialized. The {@link prepareToShowStartPagePreNative()} is only called in a cold', '        // start.', '        if (ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()', '                && TabUiFeatureUtilities.supportInstantStart(isTablet(), this) && !hadWarmStart()) {', '            prepareToShowStartPagePreNative();', '        }', '    }', '', '    /**', '     * Prepares to show the start page before native is initialized. For example, create', '     * an LayoutManagerChrome object, add overview mode observer and so on.', '     */', '    private void prepareToShowStartPagePreNative() {', '        assert TabUiFeatureUtilities.supportInstantStart(isTablet() && !hadWarmStart(), this);', '        try (TraceEvent e =', '                        TraceEvent.scoped(""ChromeTabbedActivity.prepareToShowStartPagePreNative"")) {', '            setupCompositorContentPreNativeForPhone();', '            getCompositorViewHolderSupplier().get().setLayoutManager(mLayoutManager);', '', '            if (shouldShowOverviewPageOnStart()) {', '                mLayoutManager.setTabModelSelector(mTabModelSelector);', '                mIsAccessibilityTabSwitcherEnabled =', '                        DeviceClassManager.enableAccessibilityLayout(this);', '                assert !mHasDeterminedOverviewStateForCurrentSession;', '                setInitialOverviewState();', '            }', '        }', '    }', '', '    @Override', '    protected TabModelOrchestrator createTabModelOrchestrator() {', '        boolean tabMergingEnabled =', '                mMultiInstanceManager != null && mMultiInstanceManager.isTabModelMergingEnabled();', '        mTabModelOrchestrator = new TabbedModeTabModelOrchestrator(tabMergingEnabled);', '        return mTabModelOrchestrator;', '    }', '', '    @Override', '    protected void createTabModels() {', '        assert mTabModelSelector == null;', '        assert mWindowId != INVALID_WINDOW_ID;', '', '        Bundle savedInstanceState = getSavedInstanceState();', '', '        // We determine the model as soon as possible so every systems get initialized coherently.', '        boolean startIncognito = savedInstanceState != null', '                && savedInstanceState.getBoolean(IS_INCOGNITO_SELECTED, false);', '', '        mNextTabPolicySupplier = new ChromeNextTabPolicySupplier(mOverviewModeBehaviorSupplier);', '', '        boolean tabModelWasCreated = mTabModelOrchestrator.createTabModels(', '                this, this, mNextTabPolicySupplier, mWindowId);', '        if (!tabModelWasCreated) {', '            finish();', '            return;', '        }', '', '        if (mMultiInstanceManager != null) {', '            int assignedIndex = TabWindowManagerSingleton.getInstance().getIndexForWindow(this);', '            // The given index and the one computed by TabWindowManager should be one and the same.', '            assert !MultiWindowUtils.isMultiInstanceApi31Enabled() || assignedIndex == mWindowId;', '            mMultiInstanceManager.initialize(assignedIndex, getTaskId());', '        }', '', '        mTabModelSelector = mTabModelOrchestrator.getTabModelSelector();', '        mTabModelSelector.addObserver(new TabModelSelectorObserver() {', '            @Override', '            public void onTabStateInitialized() {', '                if (!mCreatedTabOnStartup) return;', '', '                TabModel model = mTabModelSelector.getModel(false);', '                TasksUma.recordTasksUma(model);', '            }', '        });', '', '        mTabModelSelectorTabObserver = new TabModelSelectorTabObserver(mTabModelSelector) {', '            @Override', '            public void onDidFinishNavigation(Tab tab, NavigationHandle navigation) {', '                if (!navigation.hasCommitted() || !navigation.isInPrimaryMainFrame()) {', '                    return;', '                }', '                DataReductionPromoInfoBar.maybeLaunchPromoInfoBar(ChromeTabbedActivity.this,', '                        tab.getWebContents(), navigation.getUrl(), tab.isShowingErrorPage(),', '                        navigation.isFragmentNavigation(), navigation.httpStatusCode());', '                if (SyncErrorPromptUtils.isMessageUiEnabled()) {', '                    SyncErrorMessage.maybeShowMessageUi(', '                            getWindowAndroid(), ChromeTabbedActivity.this);', '                } else {', '                    SyncErrorInfoBar.maybeLaunchSyncErrorInfoBar(tab.getWebContents());', '                }', '                SendTabToSelfAndroidBridge.updateActiveWebContents(tab.getWebContents());', '            }', '        };', '        mAppIndexingUtil = new AppIndexingUtil(mTabModelSelector);', '', '        if (startIncognito) mTabModelSelector.selectModel(true);', '    }', '', '    @Override', '    protected LaunchCauseMetrics createLaunchCauseMetrics() {', '        return new TabbedActivityLaunchCauseMetrics(this);', '    }', '', '    @Override', '    public AppMenuPropertiesDelegate createAppMenuPropertiesDelegate() {', '        return new TabbedAppMenuPropertiesDelegate(this, getActivityTabProvider(),', '                getMultiWindowModeStateDispatcher(), getTabModelSelector(), getToolbarManager(),', '                getWindow().getDecorView(), this, mOverviewModeBehaviorSupplier,', '                ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()', '                        ? mStartSurfaceSupplier', '                        : null,', '                mBookmarkBridgeSupplier,', '                ()', '                        -> getTabCreator(/*incognito=*/false)', '                                   .launchUrl(NewTabPageUtils.encodeNtpUrl(', '                                                      NewTabPageLaunchOrigin.WEB_FEED),', '                                           TabLaunchType.FROM_CHROME_UI),', '                getModalDialogManager(), getSnackbarManager());', '    }', '', '    private TabDelegateFactory getTabDelegateFactory() {', '        if (mTabDelegateFactory == null) {', '            mTabDelegateFactory = new TabbedModeTabDelegateFactory(this,', '                    getAppBrowserControlsVisibilityDelegate(), getShareDelegateSupplier(),', '                    mEphemeralTabCoordinatorSupplier,', '                    ((TabbedRootUiCoordinator) mRootUiCoordinator)::onContextMenuCopyLink,', '                    mRootUiCoordinator.getBottomSheetController(),', '                    /* ChromeActivityNativeDelegate */ this, /* isCustomTab= */ false,', '                    getBrowserControlsManager(), getFullscreenManager(),', '                    /* TabCreatorManager */ this, getTabModelSelectorSupplier(),', '                    getCompositorViewHolderSupplier(), getModalDialogManagerSupplier(),', '                    this::getSnackbarManager, getBrowserControlsManager(), getActivityTabProvider(),', '                    getLifecycleDispatcher(), getWindowAndroid(), this::getLastUserInteractionTime,', '                    this::hadWarmStart, mJankTracker, getToolbarManager()::getToolbar);', '        }', '        return mTabDelegateFactory;', '    }', '', '    @Override', '    protected Pair<ChromeTabCreator, ChromeTabCreator> createTabCreators() {', '        ChromeTabCreator.OverviewNTPCreator overviewNTPCreator = null;', '', '        if (ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '            overviewNTPCreator = new ChromeTabCreator.OverviewNTPCreator() {', '                @Override', '                public boolean handleCreateNTPIfNeeded(boolean isNTP, boolean incognito,', '                        Tab parentTab, @NewTabPageLaunchOrigin int launchOrigin) {', '                    boolean shouldShowStart =', '                            showStartSurfaceHomeForNTP(isNTP, incognito, parentTab, launchOrigin);', '                    if (shouldShowStart) {', '                        mStartSurfaceParentTabSupplier.set(parentTab);', '                    }', '                    return shouldShowStart;', '                }', '', '                @Override', '                public void preTabInitialization(Tab tab, String url) {', '                    StartSurfaceConfiguration.maySetUserDataForEmptyTab(tab, url);', '                }', '            };', '        }', '        return Pair.create(', '                new ChromeTabCreator(this, getWindowAndroid(), getStartupTabPreloader(),', '                        this::getTabDelegateFactory, false, overviewNTPCreator,', '                        AsyncTabParamsManagerSingleton.getInstance(), getTabModelSelectorSupplier(),', '                        getCompositorViewHolderSupplier()),', '                new ChromeTabCreator(this, getWindowAndroid(), getStartupTabPreloader(),', '                        this::getTabDelegateFactory, true, overviewNTPCreator,', '                        AsyncTabParamsManagerSingleton.getInstance(), getTabModelSelectorSupplier(),', '                        getCompositorViewHolderSupplier()));', '    }', '', '    @Override', '    protected void initDeferredStartupForActivity() {', '        super.initDeferredStartupForActivity();', '        DeferredStartupHandler.getInstance().addDeferredTask(() -> {', '            ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);', '            RecordHistogram.recordSparseHistogram(', '                    ""MemoryAndroid.DeviceMemoryClass"", am.getMemoryClass());', '', '            LauncherShortcutActivity.updateIncognitoShortcut(ChromeTabbedActivity.this);', '', '            ChromeSurveyController.initialize(mTabModelSelector, getLifecycleDispatcher(),', '                    ChromeTabbedActivity.this, MessageDispatcherProvider.from(getWindowAndroid()));', '', '            if (mStartSurfaceSupplier.get() != null) {', '                mStartSurfaceSupplier.get().onOverviewShownAtLaunch(', '                        mOverviewShownOnStart, getOnCreateTimestampMs());', '            }', '        });', '    }', '', '    @Override', '    protected void recordIntentToCreationTime(long timeMs) {', '        super.recordIntentToCreationTime(timeMs);', '        RecordHistogram.recordCustomTimesHistogram(""MobileStartup.IntentToCreationTime.TabbedMode"",', '                timeMs, 1, DateUtils.SECOND_IN_MILLIS * 30, 50);', '    }', '', '    @Override', '    protected boolean isStartedUpCorrectly(Intent intent) {', '        mWindowId = 0;', '        Bundle savedInstanceState = getSavedInstanceState();', '        int windowId = getExtraWindowIdFromIntent(intent);', '        if (savedInstanceState != null && savedInstanceState.containsKey(WINDOW_INDEX)) {', '            // Activity is recreated after destruction. |windowId| must not be valid in this case.', '            assert windowId == INVALID_WINDOW_ID;', '            mWindowId = savedInstanceState.getInt(WINDOW_INDEX, 0);', '        } else if (mMultiInstanceManager != null) {', ""            // |allocInstanceId| doesn't do any disk I/O that would add a long-running task"", '            // to pre-inflation startup.', '            boolean preferNew = getExtraPreferNewFromIntent(intent);', '            mWindowId = mMultiInstanceManager.allocInstanceId(windowId, getTaskId(), preferNew);', '        }', '        if (mWindowId == INVALID_WINDOW_ID) {', '            Log.i(TAG, ""Window ID not allocated. Finishing the activity"");', '            Toast.makeText(this, R.string.max_number_of_windows, Toast.LENGTH_LONG).show();', '            return false;', '        }', '', '        if (mMultiInstanceManager != null', '                && !mMultiInstanceManager.isStartedUpCorrectly(getTaskId())) {', '            return false;', '        }', '', '        return super.isStartedUpCorrectly(intent);', '    }', '', '    private static int getExtraWindowIdFromIntent(Intent intent) {', '        int windowId = IntentUtils.safeGetIntExtra(', '                intent, IntentHandler.EXTRA_WINDOW_ID, INVALID_WINDOW_ID);', '        return IntentUtils.isTrustedIntentFromSelf(intent) ? windowId : INVALID_WINDOW_ID;', '    }', '', '    private static boolean getExtraPreferNewFromIntent(Intent intent) {', '        return IntentUtils.safeGetBooleanExtra(intent, IntentHandler.EXTRA_PREFER_NEW, false);', '    }', '', '    @Override', '    public void terminateIncognitoSession() {', '        getTabModelSelector().getModel(true).closeAllTabs();', '    }', '', '    @Override', '    public boolean onMenuOrKeyboardAction(final int id, boolean fromMenu) {', '        final Tab currentTab = getActivityTab();', '        boolean currentTabIsNtp = isTabNtp(currentTab);', '        if (id == R.id.new_tab_menu_id) {', '            getTabModelSelector().getModel(false).commitAllTabClosures();', '            RecordUserAction.record(""MobileMenuNewTab"");', '            RecordUserAction.record(""MobileNewTabOpened"");', '            ReturnToChromeExperimentsUtil.onNewTabOpened();', '            reportNewTabShortcutUsed(false);', '            if (fromMenu) RecordUserAction.record(""MobileMenuNewTab.AppMenu"");', '', '            getTabCreator(false).launchNTP();', '', '            mLocaleManager.showSearchEnginePromoIfNeeded(this, null);', '        } else if (id == R.id.new_incognito_tab_menu_id) {', '            if (IncognitoUtils.isIncognitoModeEnabled()) {', '                getTabModelSelector().getModel(false).commitAllTabClosures();', '                // This action must be recorded before opening the incognito tab since UMA actions', '                // are dropped when an incognito tab is open.', '                RecordUserAction.record(""MobileMenuNewIncognitoTab"");', '                RecordUserAction.record(""MobileNewTabOpened"");', '                ReturnToChromeExperimentsUtil.onNewTabOpened();', '                reportNewTabShortcutUsed(true);', '                if (fromMenu) RecordUserAction.record(""MobileMenuNewIncognitoTab.AppMenu"");', '                getTabCreator(true).launchNTP();', '            }', '        } else if (id == R.id.all_bookmarks_menu_id) {', ""            // Note that 'currentTab' could be null in overview mode when start surface is"", '            // enabled.', '            getCompositorViewHolderSupplier().get().hideKeyboard(() -> {', '                BookmarkUtils.showBookmarkManager(', '                        ChromeTabbedActivity.this, getCurrentTabModel().isIncognito());', '            });', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_BOOKMARKS_MANAGER);', '            }', '', '            @BrowserProfileType', '            int type = getCurrentTabModel().isIncognito() ? BrowserProfileType.INCOGNITO', '                                                          : BrowserProfileType.REGULAR;', '            RecordHistogram.recordEnumeratedHistogram(', '                    ""Bookmarks.OpenBookmarkManager.PerProfileType"", type,', '                    BrowserProfileType.MAX_VALUE + 1);', '', '            RecordUserAction.record(""MobileMenuAllBookmarks"");', '        } else if (id == R.id.recent_tabs_menu_id) {', '            LoadUrlParams params =', '                    new LoadUrlParams(UrlConstants.RECENT_TABS_URL, PageTransition.AUTO_BOOKMARK);', '            boolean isInOverviewMode = isInOverviewMode();', '            if (isInOverviewMode && !isTablet()', '                    && ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '                // When tapping the ""Recent tabs"" menu item from the overview page (Start surface or', '                // GTS), we will create the tab with the launch type FROM_START_SURFACE. Thus, if', '                // the back button is tapped on this ""Recent tabs"" page, it can go back to the', '                // overview page.', '                ReturnToChromeExperimentsUtil.handleLoadUrlFromStartSurface(', '                        params, getCurrentTabModel().isIncognito(), null);', '            } else if (currentTab != null) {', '                currentTab.loadUrl(params);', '            } else {', '                getTabCreator(getCurrentTabModel().isIncognito())', '                        .createNewTab(params, TabLaunchType.FROM_CHROME_UI, null);', '            }', '            if (isInOverviewMode) {', '                mOverviewModeController.hideOverview(true);', '            }', '', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_RECENT_TABS_MANAGER);', '            }', '            RecordUserAction.record(""MobileMenuRecentTabs"");', '            ReturnToChromeExperimentsUtil.onRecentTabsOpened();', '        } else if (id == R.id.close_tab) {', '            getCurrentTabModel().closeTab(currentTab, true, false, true);', '            RecordUserAction.record(""MobileTabClosed"");', '        } else if (id == R.id.close_all_tabs_menu_id) {', '            // Close both incognito and normal tabs', '            getTabModelSelector().closeAllTabs();', '            RecordUserAction.record(""MobileMenuCloseAllTabs"");', '        } else if (id == R.id.close_all_incognito_tabs_menu_id) {', '            // Close only incognito tabs', '            getTabModelSelector().getModel(true).closeAllTabs();', '            RecordUserAction.record(""MobileMenuCloseAllIncognitoTabs"");', '        } else if (id == R.id.focus_url_bar) {', '            boolean isUrlBarVisible = !mOverviewModeController.overviewVisible()', '                    && (!isTablet() || getCurrentTabModel().getCount() != 0);', '            if (isUrlBarVisible) {', '                getToolbarManager().setUrlBarFocus(', '                        true, OmniboxFocusReason.MENU_OR_KEYBOARD_ACTION);', '            }', '        } else if (id == R.id.downloads_menu_id) {', '            OTRProfileID otrProfileID = null;', '            if (currentTab != null && currentTab.getWebContents() != null) {', '                Profile profile = Profile.fromWebContents(currentTab.getWebContents());', '                otrProfileID = profile != null ? profile.getOTRProfileID() : null;', '            }', '            DownloadUtils.showDownloadManager(', '                    this, currentTab, otrProfileID, DownloadOpenSource.MENU);', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_DOWNLOADS_MANAGER);', '            }', '            RecordUserAction.record(""MobileMenuDownloadManager"");', '        } else if (id == R.id.open_recently_closed_tab) {', '            TabModel currentModel = mTabModelSelector.getCurrentModel();', '            if (!currentModel.isIncognito()) currentModel.openMostRecentlyClosedTab();', '            RecordUserAction.record(""MobileTabClosedUndoShortCut"");', '        } else if (id == R.id.enter_vr_id) {', '            VrModuleProvider.getDelegate().enterVrIfNecessary();', '        } else {', '            return super.onMenuOrKeyboardAction(id, fromMenu);', '        }', '        return true;', '    }', '', '    private boolean isTabNtp(Tab tab) {', '        return tab != null && UrlUtilities.isNTPUrl(tab.getUrl());', '    }', '', '    private boolean isTabRegularNtp(Tab tab) {', '        return isTabNtp(tab) && !tab.isIncognito();', '    }', '', '    private void onOmniboxFocusChanged(boolean hasFocus) {', '        mTabModalHandler.onOmniboxFocusChanged(hasFocus);', '    }', '', '    private void recordLauncherShortcutAction(boolean isIncognito) {', '        if (isIncognito) {', '            RecordUserAction.record(""Android.LauncherShortcut.NewIncognitoTab"");', '        } else {', '            RecordUserAction.record(""Android.LauncherShortcut.NewTab"");', '        }', '    }', '', '    @Override', '    public boolean handleBackPressed() {', '        if (!mUIWithNativeInitialized) return false;', '', '        if (getManualFillingComponent().handleBackPress()) return true;', '', '        if (exitFullscreenIfShowing()) {', '            return true;', '        }', '', '        // TODO(1091411): Find a better mechanism for back-press handling for features.', '        if (mRootUiCoordinator.getBottomSheetController().handleBackPress()) return true;', '', '        if (mTabModalHandler.handleBackPress()) return true;', '', '        final Tab currentTab = getActivityTab();', '        if (currentTab == null) {', '            moveTaskToBack(true);', '            return true;', '        }', '', '        // If we are in the tab switcher mode (not in the Start surface homepage) and not a tablet,', '        // then leave tab switcher mode on back.', '        if (mOverviewModeController.overviewVisible() && !isTablet()', '                && (mStartSurfaceSupplier.get() == null', '                        || mStartSurfaceSupplier.get().getController().getStartSurfaceState()', '                                == StartSurfaceState.SHOWN_TABSWITCHER)) {', '            mOverviewModeController.hideOverview(true);', '            return true;', '        }', '', '        final WebContents webContents = currentTab.getWebContents();', '        if (webContents != null) {', '            RenderFrameHost focusedFrame = webContents.getFocusedFrame();', '            if (focusedFrame != null && focusedFrame.signalCloseWatcherIfActive()) return true;', '        }', '', '        if (getToolbarManager().back()) return true;', '', '        // If the current tab url is HELP_URL, then the back button should close the tab to', '        // get back to the previous state. The reason for startsWith check is that the', '        // actual redirected URL is a different system language based help url.', '        final @TabLaunchType int type = currentTab.getLaunchType();', '        final boolean helpUrl = currentTab.getUrl().getSpec().startsWith(HELP_URL_PREFIX);', '        if (type == TabLaunchType.FROM_CHROME_UI && helpUrl) {', '            getCurrentTabModel().closeTab(currentTab);', '            return true;', '        }', '', ""        // If we aren't in the overview mode, we handle the Tab with launchType"", '        // TabLaunchType.FROM_START_SURFACE or has ""OpenedFromStart"" property.', '        if (!mOverviewModeController.overviewVisible()', '                && (type == TabLaunchType.FROM_START_SURFACE', '                        || StartSurfaceUserData.isOpenedFromStart(currentTab))) {', '            if (StartSurfaceUserData.getKeepTab(currentTab)', '                    || StartSurfaceUserData.isOpenedFromStart(currentTab)) {', '                // If the current tab is created from the start surface with the keepTab property,']}, {'a': ['                // shows the Start surface non-incognito homepage to prevent a loop between the', '                // current tab and previous overview mode. Once in the Start surface, it will close', '                // Chrome if back button is tapped again.'], 'b': ['                // shows the Start surface Homepage to prevent a loop between the current tab and', '                // previous overview mode. Once in the Start surface, it will close Chrome if back', '                // button is tapped again.']}, {'ab': ['                if (currentTab.isIncognito()) {', '                    if (!currentTab.isClosing()) {', '                        getCurrentTabModel().closeTab(currentTab);', '                    }']}, {'a': ['                    mTabModelSelector.selectModel(/*incognito=*/false);'], 'b': ['                    mTabModelSelector.selectModel(false);']}, {'ab': ['                }', '                showOverview(StartSurfaceState.SHOWING_HOMEPAGE);', '            } else {', '                // Otherwise, clicking the back button should close the tab and go back to the', '                // previous overview mode.', '                showOverview(StartSurfaceState.SHOWING_PREVIOUS);', '                if (!currentTab.isClosing()) {', '                    getCurrentTabModel().closeTab(currentTab);', '                }', '            }', '            return true;', '        }', '', '        final boolean shouldCloseTab = backShouldCloseTab(currentTab);', '', '        // Minimize the app if either:', '        // - we decided not to close the tab', '        // - we decided to close the tab, but it was opened by an external app, so we will go', '        //   exit Chrome on top of closing the tab', '        final boolean minimizeApp =', '                !shouldCloseTab || TabAssociatedApp.isOpenedFromExternalApp(currentTab);', '        if (minimizeApp) {', '            if (shouldCloseTab) {', '                sendToBackground(currentTab);', '                return true;', '            } else {', '                sendToBackground(null);', '                return true;', '            }', '        } else if (shouldCloseTab) {', '            currentTab.getWebContents().dispatchBeforeUnload(false);', '            return true;', '        }', '', '        assert false : ""The back button should have already been handled by this point"";', '        return false;', '    }', '', '    /**', '     * [true]: Reached the bottom of the back stack on a tab the user did not explicitly', '     * create (i.e. it was created by an external app or opening a link in background, etc).', '     * [false]: Reached the bottom of the back stack on a tab that the user explicitly', '     * created (e.g. selecting ""new tab"" from menu).', '     *', '     * @return Whether pressing the back button on the provided Tab should close the Tab.', '     */', '    @Override', '    public boolean backShouldCloseTab(Tab tab) {', '        if (!tab.isInitialized()) {', '            return false;', '        }', '        @TabLaunchType', '        int type = tab.getLaunchType();', '', '        return type == TabLaunchType.FROM_LINK || type == TabLaunchType.FROM_EXTERNAL_APP', '                || type == TabLaunchType.FROM_LONGPRESS_FOREGROUND', '                || type == TabLaunchType.FROM_LONGPRESS_BACKGROUND', '                || (type == TabLaunchType.FROM_RESTORE', '                        && CriticalPersistedTabData.from(tab).getParentId() != Tab.INVALID_TAB_ID);', '    }', '', '    /**', '     * Sends this Activity to the background.', '     *', '     * @param tabToClose Tab that will be closed once the app is not visible.', '     */', '    private void sendToBackground(@Nullable final Tab tabToClose) {', '        Log.i(TAG, ""sendToBackground(): "" + tabToClose);', '        moveTaskToBack(true);', '        if (tabToClose != null) {', ""            // In the case of closing a tab upon minimization, don't allow the close action to"", ""            // happen until after our app is minimized to make sure we don't get a brief glimpse of"", '            // the newly active tab before we exit Chrome.', '            //', ""            // If the runnable doesn't run before the Activity dies, Chrome won't crash but the tab"", ""            // won't be closed (crbug.com/587565)."", '            mHandler.postDelayed(() -> {', '                boolean hasNextTab =', '                        getCurrentTabModel().getNextTabIfClosed(tabToClose.getId()) != null;', '                getCurrentTabModel().closeTab(tabToClose, false, true, false);', '', '                // If there is no next tab to open, enter overview mode.', '                if (!hasNextTab) showOverview(StartSurfaceState.SHOWING_START);', '            }, CLOSE_TAB_ON_MINIMIZE_DELAY_MS);', '        }', '    }', '', '    @Override', '    public boolean moveTaskToBack(boolean nonRoot) {', '        try {', '            return super.moveTaskToBack(nonRoot);', '        } catch (NullPointerException e) {', '            // Work around framework bug described in https://crbug.com/817567.', '            finish();', '            return true;', '        }', '    }', '', '    /**', '     * Launch a URL from an intent.', '     *', '     * @param url           The url from the intent.', '     * @param referer       Optional referer URL to be used.', '     * @param headers       Optional headers to be sent when opening the URL.', '     * @param externalAppId External app id.', '     * @param forceNewTab   Whether to force the URL to be launched in a new tab or to fall', '     *                      back to the default behavior for making that determination.', '     * @param isRendererInitiated Whether the intent is originally from browser renderer process.', '     * @param initiatorOrigin Origin that initiates the intent.', '     * @param intent        The original intent.', '     */', '    private Tab launchIntent(', '            LoadUrlParams loadUrlParams, String externalAppId, boolean forceNewTab, Intent intent) {', '        if (mUIWithNativeInitialized && !UrlUtilities.isNTPUrl(loadUrlParams.getUrl())) {', '            mOverviewModeController.hideOverview(false);', '            getToolbarManager().finishAnimations();', '        }', '        if (IntentHandler.wasIntentSenderChrome(intent)) {', '            // If the intent was launched by chrome, open the new tab in the appropriate model.', '            boolean isIncognito = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_OPEN_NEW_INCOGNITO_TAB, false);', '            @TabLaunchType', '            Integer launchType = IntentHandler.getTabLaunchType(intent);', '            if (launchType == null) {', '                if (IntentUtils.safeGetBooleanExtra(', '                            intent, IntentHandler.EXTRA_INVOKED_FROM_SHORTCUT, false)) {', '                    launchType = TabLaunchType.FROM_LAUNCHER_SHORTCUT;', '                } else if (IntentUtils.safeGetBooleanExtra(', '                                   intent, IntentHandler.EXTRA_INVOKED_FROM_APP_WIDGET, false)) {', '                    launchType = TabLaunchType.FROM_APP_WIDGET;', '                } else if (IncognitoTabLauncher.didCreateIntent(intent)) {', '                    launchType = TabLaunchType.FROM_LAUNCH_NEW_INCOGNITO_TAB;', '                } else {', '                    // Using FROM_LINK ensures the tab is parented to the current tab, which allows', '                    // the back button to close these tabs and restore selection to the previous', '                    // tab.', '                    launchType = TabLaunchType.FROM_LINK;', '                }', '            }', '            return getTabCreator(isIncognito).createNewTab(loadUrlParams, launchType, null, intent);', '        }', '', '        // Check if the tab is being created from a Reader Mode navigation.', '        if (ReaderModeManager.isEnabled() && ReaderModeManager.isReaderModeCreatedIntent(intent)) {', '            Bundle extras = intent.getExtras();', '            int readerParentId = IntentUtils.safeGetInt(', '                    extras, ReaderModeManager.EXTRA_READER_MODE_PARENT, Tab.INVALID_TAB_ID);', '            extras.remove(ReaderModeManager.EXTRA_READER_MODE_PARENT);', '            // Set the parent tab to the tab that Reader Mode started from.', '            if (readerParentId != Tab.INVALID_TAB_ID && mTabModelSelector != null) {', '                return getCurrentTabCreator().createNewTab(', '                        new LoadUrlParams(loadUrlParams.getUrl(), PageTransition.LINK),', '                        TabLaunchType.FROM_LINK, mTabModelSelector.getTabById(readerParentId));', '            }', '        }', '', '        return getTabCreator(false).launchUrlFromExternalApp(', '                loadUrlParams, externalAppId, forceNewTab, intent);', '    }', '', '    private void showOverview(@StartSurfaceState int state) {', '        showOverview(state, NewTabPageLaunchOrigin.UNKNOWN);', '    }', '', '    // TODO(crbug.com/1115757): After crrev.com/c/2315823, Overview state and Startsurface state are', '    // two different things, we actual can split this into two methods: showOverview() and', ""    // showStartSurface(state). Let's do some auditing and clean up before perform the actual split."", '    private void showOverview(', '            @StartSurfaceState int state, @NewTabPageLaunchOrigin int launchOrigin) {', '        assert (state == StartSurfaceState.SHOWING_TABSWITCHER', '                || state == StartSurfaceState.SHOWING_HOMEPAGE', '                || state == StartSurfaceState.SHOWING_PREVIOUS', '                || state == StartSurfaceState.SHOWING_START);', '        if (mIsAccessibilityTabSwitcherEnabled != null && mIsAccessibilityTabSwitcherEnabled', '                && mOverviewModeController != null) {', '            // TODO(1200727): This is a temporary fix that should be removed once grid tab switcher', '            //                is completely launched. The ""start surface"" is now created regardless', '            //                of the state of accessibility, so we check that mode first and try', '            //                showing the overview list before going to the start surface.', '            mOverviewModeController.showOverview(false);', '        } else if (mStartSurfaceSupplier.get() != null) {', '            if (ReturnToChromeExperimentsUtil.shouldHideStartSurfaceWithAccessibilityOn(this)', '                    || !HomepageManager.isHomepageEnabled()) {', '                state = StartSurfaceState.SHOWING_TABSWITCHER;', '            }', '            mStartSurfaceSupplier.get().getController().setOverviewState(state, launchOrigin);', '        }', '', '        if (mOverviewModeController == null) return;', '', '        if (mOverviewModeController.overviewVisible()) {', '            if (didFinishNativeInitialization()) {', '                getCompositorViewHolderSupplier().get().hideKeyboard(() -> {});', '            }', '            return;', '        }', '', '        Tab currentTab = getActivityTab();', ""        // If we don't have a current tab, show the overview mode."", '        if (currentTab == null) {', '            mOverviewModeController.showOverview(false);', '        } else {', '            getCompositorViewHolderSupplier().get().hideKeyboard(', '                    () -> mOverviewModeController.showOverview(true));', '            updateAccessibilityState(false);', '            TasksUma.recordTabLaunchType(getCurrentTabModel());', '        }', '    }', '', '    private void hideOverview() {', '        assert (mOverviewModeController.overviewVisible());', '        if (getCurrentTabModel().getCount() != 0) {', ""            // Don't hide overview if current tab stack is empty()"", '            mOverviewModeController.hideOverview(true);', '            updateAccessibilityState(true);', '        }', '    }', '', '    /**', '     * @return Whether opening a new tab is handled by the Start surface. It may show the Start', '     * surface, or open a new tab with the omnibox get focused, depending on the value of', '     * {@link StartSurfaceConfiguration.OMNIBOX_FOCUSED_ON_NEW_TAB}.', '     */', '    private boolean showStartSurfaceHomeForNTP(boolean isNTP, boolean incognito, Tab parentTab,', '            @NewTabPageLaunchOrigin int launchOrigin) {', '        if (!isNTP', '                || !ReturnToChromeExperimentsUtil.shouldShowStartSurfaceHomeAsNTP(', '                        this, incognito, isTablet())) {', '            return false;', '        }', '', '        getTabModelSelector().selectModel(incognito);', '        if (StartSurfaceConfiguration.OMNIBOX_FOCUSED_ON_NEW_TAB.getValue()', '                && launchOrigin != NewTabPageLaunchOrigin.WEB_FEED) {', '            Runnable emptyTabCloseCallback = isInOverviewMode() ? () -> {', '                showOverview(StartSurfaceState.SHOWING_PREVIOUS, launchOrigin);', '            } : null;', '            ReturnToChromeExperimentsUtil.handleLoadUrlFromStartSurfaceAsNewTab(null,', '                    PageTransition.AUTO_TOPLEVEL, incognito, parentTab, getCurrentTabModel(),', '                    emptyTabCloseCallback);', '        } else if (TabUiFeatureUtilities.supportInstantStart(isTablet(), this)', '                || (getTabModelSelector().isTabStateInitialized() && isLayoutManagerCreated())) {', '            showOverview(StartSurfaceState.SHOWING_HOMEPAGE, launchOrigin);', '        }', '        return true;', '    }', '', '    private void updateAccessibilityState(boolean enabled) {', '        Tab currentTab = getActivityTab();', '        WebContents webContents = currentTab != null ? currentTab.getWebContents() : null;', '        if (webContents != null) {', '            WebContentsAccessibility.fromWebContents(webContents).setState(enabled);', '        }', '    }', '', '    @Override', '    public void onSaveInstanceState(Bundle outState) {', '        super.onSaveInstanceState(outState);', '        CipherFactory.getInstance().saveToBundle(outState);', '        outState.putInt(', '                WINDOW_INDEX, TabWindowManagerSingleton.getInstance().getIndexForWindow(this));', '        Boolean is_incognito = getCurrentTabModel().isIncognito();', '        outState.putBoolean(IS_INCOGNITO_SELECTED, is_incognito);', ""        // If it's Incognito and native is initialized and profile exists, serialize duration"", '        // service state.', '        if (is_incognito && ProfileManager.isInitialized()) {', '            AndroidSessionDurationsServiceState.serializeFromNative(', '                    outState, getCurrentTabModel().getProfile());', '        }', '    }', '', '    @Override', '    public void onDestroyInternal() {', '        if (mCallbackController != null) {', '            mCallbackController.destroy();', '            mCallbackController = null;', '        }', '', '        if (mTabModelSelectorTabObserver != null) {', '            mTabModelSelectorTabObserver.destroy();', '            mTabModelSelectorTabObserver = null;', '        }', '', '        if (mTabModelObserver != null) mTabModelObserver.destroy();', '', '        if (mUndoBarPopupController != null) {', '            mUndoBarPopupController.destroy();', '            mUndoBarPopupController = null;', '        }', '', '        if (mAppIndexingUtil != null) {', '            mAppIndexingUtil.destroy();', '            mAppIndexingUtil = null;', '        }', '', '        if (mStartSurfaceSupplier.get() != null) {', '            mStartSurfaceSupplier.get().destroy();', '        }', '', '        if (mStartupPaintPreviewHelperSupplier != null) {', '            mStartupPaintPreviewHelperSupplier.destroy();', '        }', '', '        if (mJankTracker != null) {', '            mJankTracker.destroy();', '            mJankTracker = null;', '        }', '', '        IncognitoTabHostRegistry.getInstance().unregister(mIncognitoTabHost);', '', '        TabObscuringHandler tabObscuringHandler = getTabObscuringHandler();', '        if (tabObscuringHandler != null) {', '            getTabObscuringHandler().removeObserver(mCompositorViewHolder);', '            getTabObscuringHandler().removeObserver(mOverviewListLayout);', '        }', '', '        if (isTablet()) ChromeAccessibilityUtil.get().removeObserver(mCompositorViewHolder);', '        ChromeAccessibilityUtil.get().removeObserver(this);', '        ChromeAccessibilityUtil.get().removeObserver(mLayoutManager);', '', '        if (mTabDelegateFactory != null) mTabDelegateFactory.destroy();', '', '        mAppLaunchDrawBlocker.destroy();', '', '        super.onDestroyInternal();', '    }', '', '    @Override', '    protected void destroyTabModels() {', '        if (mTabModelOrchestrator != null) {', '            mTabModelOrchestrator.destroy();', '        }', '    }', '', '    @Override', '    public void onTrimMemory(int level) {', '        super.onTrimMemory(level);', '        if (ChromeApplicationImpl.isSevereMemorySignal(level)) {', '            NativePageAssassin.getInstance().freezeAllHiddenPages();', '        }', '    }', '', '    @Override', '    public boolean dispatchKeyEvent(KeyEvent event) {', '        Boolean result = KeyboardShortcuts.dispatchKeyEvent(event, mUIWithNativeInitialized,', '                getFullscreenManager(), /* menuOrKeyboardActionController= */ this);', '        return result != null ? result : super.dispatchKeyEvent(event);', '    }', '', '    @Override', '    public boolean onKeyDown(int keyCode, KeyEvent event) {', '        if (!mUIWithNativeInitialized) {', '            return super.onKeyDown(keyCode, event);', '        }', '        // Detecting a long press of the back button via onLongPress is broken in Android N.', '        // To work around this, use a postDelayed, which is supported in all versions.', '        if (keyCode == KeyEvent.KEYCODE_BACK && !isTablet()', '                && !getFullscreenManager().getPersistentFullscreenMode()) {', '            if (mShowHistoryRunnable == null) mShowHistoryRunnable = this::showFullHistorySheet;', '            mHandler.postDelayed(mShowHistoryRunnable, ViewConfiguration.getLongPressTimeout());', '            return super.onKeyDown(keyCode, event);', '        }', '        boolean isCurrentTabVisible = !mOverviewModeController.overviewVisible()', '                && (!isTablet() || getCurrentTabModel().getCount() != 0);', '        return KeyboardShortcuts.onKeyDown(event, isCurrentTabVisible, true, getTabModelSelector(),', '                       /* menuOrKeyboardActionController= */ this, getToolbarManager())', '                || super.onKeyDown(keyCode, event);', '    }', '', '    private void showFullHistorySheet() {', '        ((TabbedRootUiCoordinator) mRootUiCoordinator).showFullHistorySheet();', '    }', '', '    @Override', '    public boolean onKeyUp(int keyCode, KeyEvent event) {', '        if (keyCode == KeyEvent.KEYCODE_BACK && !isTablet()) {', '            mHandler.removeCallbacks(mShowHistoryRunnable);', '            mShowHistoryRunnable = null;', '            if (event.getEventTime() - event.getDownTime()', '                            >= ViewConfiguration.getLongPressTimeout()', '                    && NavigationSheet.isInstanceShowing(', '                            mRootUiCoordinator.getBottomSheetController())) {', '                // If tab history popup is showing, do not process the keyUp event', '                // which will dismiss it immediately.', '                return true;', '            }', '        }', '        return super.onKeyUp(keyCode, event);', '    }', '', '    @VisibleForTesting', '    public boolean hasPendingNavigationRunnableForTesting() {', '        ThreadUtils.assertOnUiThread();', '        return mShowHistoryRunnable != null;', '    }', '', '    @Override', '    public void onProvideKeyboardShortcuts(', '            List<KeyboardShortcutGroup> data, Menu menu, int deviceId) {', '        data.addAll(KeyboardShortcuts.createShortcutGroup(this));', '    }', '', '    @VisibleForTesting', '    public View getTabsView() {', '        return getCompositorViewHolderSupplier().get();', '    }', '', '    @VisibleForTesting', '    public LayoutManagerChrome getLayoutManager() {', '        return (LayoutManagerChrome) getCompositorViewHolderSupplier().get().getLayoutManager();', '    }', '', '    @VisibleForTesting', '    public Layout getOverviewListLayout() {', '        return getLayoutManager().getOverviewListLayout();', '    }', '', '    @VisibleForTesting', '    public StartSurface getStartSurface() {', '        return mStartSurfaceSupplier.get();', '    }', '', '    private ComposedBrowserControlsVisibilityDelegate getAppBrowserControlsVisibilityDelegate() {', '        // TODO(jinsukkim): Move this to RootUiCoordinator.', '        return ((TabbedRootUiCoordinator) mRootUiCoordinator)', '                .getAppBrowserControlsVisibilityDelegate();', '    }', '', '    @Override', '    protected ModalDialogManager createModalDialogManager() {', '        ModalDialogManager manager = super.createModalDialogManager();', '        // TODO(crbug.com/1157310): Transition this::method refs to dedicated suppliers.', '        mTabModalHandler = new TabModalLifetimeHandler(this, getLifecycleDispatcher(), manager,', '                this::getAppBrowserControlsVisibilityDelegate, this::getTabObscuringHandler,', '                this::getToolbarManager, this::getContextualSearchManager,', '                getTabModelSelectorSupplier(), this::getBrowserControlsManager,', '                this::getFullscreenManager);', '        return manager;', '    }', '', '    // App Menu related code -----------------------------------------------------------------------', '', '    @Override', '    public boolean canShowAppMenu() {', '        // The popup menu relies on the model created during the full UI initialization, so do not', '        // attempt to show the menu until the UI creation has finished.', '        if (!mUIWithNativeInitialized) return false;', '', ""        // If the current active tab is showing a tab modal dialog, an app menu shouldn't be shown"", '        // in any cases, e.g. when a hardware menu button is clicked.', '        Tab tab = getActivityTab();', '        if (tab != null && ChromeTabModalPresenter.isDialogShowing(tab)) return false;', '', '        return super.canShowAppMenu();', '    }', '', '    @Override', '    public boolean isInOverviewMode() {', '        return mOverviewModeController != null && mOverviewModeController.overviewVisible();', '    }', '', '    @Override', '    protected IntentHandlerDelegate createIntentHandlerDelegate() {', '        return new InternalIntentDelegate();', '    }', '', '    @Override', '    public void onSceneChange(Layout layout) {', '        super.onSceneChange(layout);', '        if (!layout.shouldDisplayContentOverlay()) mTabModelSelector.onTabsViewShown();', '    }', '', '    /**', '     * Writes the tab state to disk.', '     */', '    @VisibleForTesting', '    public void saveState() {', '        mTabModelOrchestrator.saveState();', '    }', '', '    @Override', '    public void onEnterVr() {', '        super.onEnterVr();', '        mControlContainer.setVisibility(View.INVISIBLE);', '        if (mVrBrowserControlsVisibilityDelegate == null) {', '            mVrBrowserControlsVisibilityDelegate =', '                    new BrowserControlsVisibilityDelegate(BrowserControlsState.BOTH);', '            getAppBrowserControlsVisibilityDelegate().addDelegate(', '                    mVrBrowserControlsVisibilityDelegate);', '        }', '        mVrBrowserControlsVisibilityDelegate.set(BrowserControlsState.HIDDEN);', '    }', '', '    @Override', '    public void onExitVr() {', '        super.onExitVr();', '        mControlContainer.setVisibility(View.VISIBLE);', '        if (mVrBrowserControlsVisibilityDelegate != null) {', '            mVrBrowserControlsVisibilityDelegate.set(BrowserControlsState.BOTH);', '        }', '    }', '', '    @Override', '    protected void applyThemeOverlays() {', '        super.applyThemeOverlays();', '', '        if (TabManagementModuleProvider.getDelegate() != null) {', '            TabManagementModuleProvider.getDelegate().applyThemeOverlays(this);', '        }', '    }', '', '    @Override', '    protected boolean supportsDynamicColors() {', '        return CachedFeatureFlags.isEnabled(ChromeFeatureList.DYNAMIC_COLOR_ANDROID);', '    }', '', '    /**', '     * Reports that a new tab launcher shortcut was selected or an action equivalent to a shortcut', '     * was performed.', '     * @param isIncognito Whether the shortcut or action created a new incognito tab.', '     */', '    @TargetApi(Build.VERSION_CODES.N_MR1)', '    private void reportNewTabShortcutUsed(boolean isIncognito) {', '        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N_MR1) return;', '', '        ShortcutManager shortcutManager = getSystemService(ShortcutManager.class);', '        shortcutManager.reportShortcutUsed(', '                isIncognito ? ""new-incognito-tab-shortcut"" : ""new-tab-shortcut"");', '    }', '', '    @VisibleForTesting', '    public MultiInstanceManager getMultiInstanceMangerForTesting() {', '        return mMultiInstanceManager;', '    }', '', '    @VisibleForTesting', '    public ChromeNextTabPolicySupplier getNextTabPolicySupplier() {', '        return (ChromeNextTabPolicySupplier) mNextTabPolicySupplier;', '    }', '}', '']}]",chromium%2Fsrc~main~Ib63fff1d02f6696a61891dd6449012e0c7a5d027,8731f872fe833f2c64a8604ff02ad616355d9fed,chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java,7fa9753f_9d8ef123_before.java,7fa9753f_9d8ef123_after.java,ChromeTabbedActivity::handleBackPressed,True,True
2,b5ea4309_819de63f,2168.0,Ack,,,"[{'ab': ['// Copyright 2015 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser;', '', 'import android.annotation.TargetApi;', 'import android.app.ActivityManager;', 'import android.content.ComponentName;', 'import android.content.Context;', 'import android.content.Intent;', 'import android.content.pm.ApplicationInfo;', 'import android.content.pm.ShortcutManager;', 'import android.os.Build;', 'import android.os.Bundle;', 'import android.os.SystemClock;', 'import android.text.TextUtils;', 'import android.text.format.DateUtils;', 'import android.util.Pair;', 'import android.view.KeyEvent;', 'import android.view.KeyboardShortcutGroup;', 'import android.view.Menu;', 'import android.view.View;', 'import android.view.View.OnClickListener;', 'import android.view.ViewConfiguration;', 'import android.view.ViewGroup;', 'import android.view.Window;', 'import android.view.WindowManager;', '', 'import androidx.annotation.IntDef;', 'import androidx.annotation.Nullable;', 'import androidx.annotation.VisibleForTesting;', 'import androidx.lifecycle.Lifecycle;', 'import androidx.lifecycle.LifecycleObserver;', 'import androidx.lifecycle.LifecycleRegistry;', '', 'import org.chromium.base.CallbackController;', 'import org.chromium.base.CommandLine;', 'import org.chromium.base.ContextUtils;', 'import org.chromium.base.IntentUtils;', 'import org.chromium.base.Log;', 'import org.chromium.base.MemoryPressureListener;', 'import org.chromium.base.ThreadUtils;', 'import org.chromium.base.TraceEvent;', 'import org.chromium.base.annotations.UsedByReflection;', 'import org.chromium.base.jank_tracker.JankTrackerImpl;', 'import org.chromium.base.library_loader.LibraryLoader;', 'import org.chromium.base.metrics.RecordHistogram;', 'import org.chromium.base.metrics.RecordUserAction;', 'import org.chromium.base.supplier.ObservableSupplierImpl;', 'import org.chromium.base.supplier.OneShotCallback;', 'import org.chromium.base.supplier.OneshotSupplier;', 'import org.chromium.base.supplier.OneshotSupplierImpl;', 'import org.chromium.base.supplier.Supplier;', 'import org.chromium.base.supplier.UnownedUserDataSupplier;', 'import org.chromium.base.task.PostTask;', 'import org.chromium.cc.input.BrowserControlsState;', 'import org.chromium.chrome.R;', 'import org.chromium.chrome.browser.IntentHandler.IntentHandlerDelegate;', 'import org.chromium.chrome.browser.IntentHandler.TabOpenType;', 'import org.chromium.chrome.browser.accessibility_tab_switcher.OverviewListLayout;', 'import org.chromium.chrome.browser.app.ChromeActivity;', 'import org.chromium.chrome.browser.app.metrics.LaunchCauseMetrics;', 'import org.chromium.chrome.browser.app.metrics.TabbedActivityLaunchCauseMetrics;', 'import org.chromium.chrome.browser.app.tabmodel.AsyncTabParamsManagerSingleton;', 'import org.chromium.chrome.browser.app.tabmodel.ChromeNextTabPolicySupplier;', 'import org.chromium.chrome.browser.app.tabmodel.TabModelOrchestrator;', 'import org.chromium.chrome.browser.app.tabmodel.TabWindowManagerSingleton;', 'import org.chromium.chrome.browser.app.tabmodel.TabbedModeTabModelOrchestrator;', 'import org.chromium.chrome.browser.bookmarks.BookmarkUtils;', 'import org.chromium.chrome.browser.browserservices.intents.WebappConstants;', 'import org.chromium.chrome.browser.compositor.CompositorViewHolder;', 'import org.chromium.chrome.browser.compositor.bottombar.ephemeraltab.EphemeralTabCoordinator;', 'import org.chromium.chrome.browser.compositor.layouts.Layout;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChrome;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChromePhone;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChromeTablet;', 'import org.chromium.chrome.browser.compositor.layouts.OverviewModeBehavior;', 'import org.chromium.chrome.browser.compositor.layouts.OverviewModeController;', 'import org.chromium.chrome.browser.cookies.CookiesFetcher;', 'import org.chromium.chrome.browser.crypto.CipherFactory;', 'import org.chromium.chrome.browser.dependency_injection.ChromeActivityComponent;', 'import org.chromium.chrome.browser.device.DeviceClassManager;', 'import org.chromium.chrome.browser.dom_distiller.ReaderModeManager;', 'import org.chromium.chrome.browser.download.DownloadNotificationService;', 'import org.chromium.chrome.browser.download.DownloadOpenSource;', 'import org.chromium.chrome.browser.download.DownloadUtils;', 'import org.chromium.chrome.browser.feature_engagement.TrackerFactory;', 'import org.chromium.chrome.browser.feed.FeedSurfaceTracker;', 'import org.chromium.chrome.browser.firstrun.FirstRunSignInProcessor;', 'import org.chromium.chrome.browser.flags.ActivityType;', 'import org.chromium.chrome.browser.flags.CachedFeatureFlags;', 'import org.chromium.chrome.browser.flags.ChromeFeatureList;', 'import org.chromium.chrome.browser.flags.ChromeSwitches;', 'import org.chromium.chrome.browser.fonts.FontPreloader;', 'import org.chromium.chrome.browser.gesturenav.NavigationSheet;', 'import org.chromium.chrome.browser.homepage.HomepageManager;', 'import org.chromium.chrome.browser.incognito.IncognitoNotificationManager;', 'import org.chromium.chrome.browser.incognito.IncognitoNotificationPresenceController;', 'import org.chromium.chrome.browser.incognito.IncognitoProfileDestroyer;', 'import org.chromium.chrome.browser.incognito.IncognitoStartup;', 'import org.chromium.chrome.browser.incognito.IncognitoTabLauncher;', 'import org.chromium.chrome.browser.incognito.IncognitoTabSnapshotController;', 'import org.chromium.chrome.browser.incognito.IncognitoUtils;', 'import org.chromium.chrome.browser.infobar.DataReductionPromoInfoBar;', 'import org.chromium.chrome.browser.infobar.SyncErrorInfoBar;', 'import org.chromium.chrome.browser.layouts.LayoutStateProvider;', 'import org.chromium.chrome.browser.lifecycle.ActivityLifecycleDispatcher;', 'import org.chromium.chrome.browser.locale.LocaleManager;', 'import org.chromium.chrome.browser.metrics.AndroidSessionDurationsServiceState;', 'import org.chromium.chrome.browser.metrics.LaunchMetrics;', 'import org.chromium.chrome.browser.metrics.MainIntentBehaviorMetrics;', 'import org.chromium.chrome.browser.modaldialog.ChromeTabModalPresenter;', 'import org.chromium.chrome.browser.modaldialog.TabModalLifetimeHandler;', 'import org.chromium.chrome.browser.multiwindow.MultiInstanceChromeTabbedActivity;', 'import org.chromium.chrome.browser.multiwindow.MultiInstanceManager;', 'import org.chromium.chrome.browser.multiwindow.MultiWindowUtils;', 'import org.chromium.chrome.browser.native_page.NativePageAssassin;', 'import org.chromium.chrome.browser.navigation_predictor.NavigationPredictorBridge;', 'import org.chromium.chrome.browser.night_mode.WebContentsDarkModeController;', 'import org.chromium.chrome.browser.ntp.NewTabPageLaunchOrigin;', 'import org.chromium.chrome.browser.ntp.NewTabPageUma;', 'import org.chromium.chrome.browser.ntp.NewTabPageUtils;', 'import org.chromium.chrome.browser.omnibox.OmniboxFocusReason;', 'import org.chromium.chrome.browser.paint_preview.StartupPaintPreviewHelper;', 'import org.chromium.chrome.browser.paint_preview.StartupPaintPreviewHelperSupplier;', 'import org.chromium.chrome.browser.partnercustomizations.PartnerBrowserCustomizations;', 'import org.chromium.chrome.browser.preferences.ChromePreferenceKeys;', 'import org.chromium.chrome.browser.profiles.OTRProfileID;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.profiles.ProfileManager;', 'import org.chromium.chrome.browser.reengagement.ReengagementNotificationController;', 'import org.chromium.chrome.browser.search_engines.SearchEngineChoiceNotification;', 'import org.chromium.chrome.browser.settings.SettingsLauncherImpl;', 'import org.chromium.chrome.browser.share.send_tab_to_self.SendTabToSelfAndroidBridge;', 'import org.chromium.chrome.browser.suggestions.SuggestionsMetrics;', 'import org.chromium.chrome.browser.survey.ChromeSurveyController;', 'import org.chromium.chrome.browser.sync.ui.SyncErrorMessage;', 'import org.chromium.chrome.browser.sync.ui.SyncErrorPromptUtils;', 'import org.chromium.chrome.browser.tab.RedirectHandlerTabHelper;', 'import org.chromium.chrome.browser.tab.Tab;', 'import org.chromium.chrome.browser.tab.TabAssociatedApp;', 'import org.chromium.chrome.browser.tab.TabCreationState;', 'import org.chromium.chrome.browser.tab.TabDelegateFactory;', 'import org.chromium.chrome.browser.tab.TabLaunchType;', 'import org.chromium.chrome.browser.tab.TabSelectionType;', 'import org.chromium.chrome.browser.tab.state.CriticalPersistedTabData;', 'import org.chromium.chrome.browser.tabbed_mode.TabbedAppMenuPropertiesDelegate;', 'import org.chromium.chrome.browser.tabbed_mode.TabbedRootUiCoordinator;', 'import org.chromium.chrome.browser.tabmodel.ChromeTabCreator;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHost;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHostRegistry;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHostUtils;', 'import org.chromium.chrome.browser.tabmodel.NextTabPolicy.NextTabPolicySupplier;', 'import org.chromium.chrome.browser.tabmodel.TabModel;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelector;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorBase;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorTabModelObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorTabObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelUtils;', 'import org.chromium.chrome.browser.tabmodel.TabWindowManager;', 'import org.chromium.chrome.browser.tasks.ConditionalTabStripUtils;', 'import org.chromium.chrome.browser.tasks.EngagementTimeUtil;', 'import org.chromium.chrome.browser.tasks.JourneyManager;', 'import org.chromium.chrome.browser.tasks.ReturnToChromeExperimentsUtil;', 'import org.chromium.chrome.browser.tasks.TasksUma;', 'import org.chromium.chrome.browser.tasks.tab_management.TabGroupUi;', 'import org.chromium.chrome.browser.tasks.tab_management.TabManagementDelegate;', 'import org.chromium.chrome.browser.tasks.tab_management.TabManagementModuleProvider;', 'import org.chromium.chrome.browser.tasks.tab_management.TabUiFeatureUtilities;', 'import org.chromium.chrome.browser.toolbar.ToolbarButtonInProductHelpController;', 'import org.chromium.chrome.browser.toolbar.ToolbarIntentMetadata;', 'import org.chromium.chrome.browser.toolbar.ToolbarManager;', 'import org.chromium.chrome.browser.toolbar.top.ToolbarControlContainer;', 'import org.chromium.chrome.browser.translate.TranslateIntentHandler;', 'import org.chromium.chrome.browser.ui.AppLaunchDrawBlocker;', 'import org.chromium.chrome.browser.ui.RootUiCoordinator;', 'import org.chromium.chrome.browser.ui.TabObscuringHandler;', 'import org.chromium.chrome.browser.ui.appmenu.AppMenuPropertiesDelegate;', 'import org.chromium.chrome.browser.undo_tab_close_snackbar.UndoBarController;', 'import org.chromium.chrome.browser.usage_stats.UsageStatsService;', 'import org.chromium.chrome.browser.util.ChromeAccessibilityUtil;', 'import org.chromium.chrome.browser.vr.VrModuleProvider;', 'import org.chromium.chrome.features.start_surface.StartSurface;', 'import org.chromium.chrome.features.start_surface.StartSurfaceConfiguration;', 'import org.chromium.chrome.features.start_surface.StartSurfaceState;', 'import org.chromium.chrome.features.start_surface.StartSurfaceUserData;', 'import org.chromium.components.browser_ui.settings.SettingsLauncher;', 'import org.chromium.components.browser_ui.util.BrowserControlsVisibilityDelegate;', 'import org.chromium.components.browser_ui.util.ComposedBrowserControlsVisibilityDelegate;', 'import org.chromium.components.embedder_support.util.UrlConstants;', 'import org.chromium.components.embedder_support.util.UrlUtilities;', 'import org.chromium.components.feature_engagement.EventConstants;', 'import org.chromium.components.messages.MessageDispatcherProvider;', 'import org.chromium.components.profile_metrics.BrowserProfileType;', 'import org.chromium.components.webapps.ShortcutSource;', 'import org.chromium.content_public.browser.LoadUrlParams;', 'import org.chromium.content_public.browser.NavigationHandle;', 'import org.chromium.content_public.browser.RenderFrameHost;', 'import org.chromium.content_public.browser.UiThreadTaskTraits;', 'import org.chromium.content_public.browser.WebContents;', 'import org.chromium.content_public.browser.WebContentsAccessibility;', 'import org.chromium.content_public.common.ContentSwitches;', 'import org.chromium.ui.base.PageTransition;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', 'import org.chromium.ui.widget.Toast;', '', 'import java.lang.annotation.Retention;', 'import java.lang.annotation.RetentionPolicy;', 'import java.util.HashSet;', 'import java.util.List;', 'import java.util.Locale;', '', '/**', ' * This is the main activity for ChromeMobile when not running in document mode.  All the tabs', ' * are accessible via a chrome specific tab switching UI.', ' */', 'public class ChromeTabbedActivity extends ChromeActivity<ChromeActivityComponent>', '        implements ChromeAccessibilityUtil.Observer {', '    private static final String TAG = ""ChromeTabbedActivity"";', '', '    private static final String HELP_URL_PREFIX = ""https://support.google.com/chrome/"";', '', '    protected static final String WINDOW_INDEX = ""window_index"";', '', '    private static final String IS_INCOGNITO_SELECTED = ""is_incognito_selected"";', '', '    private static final int INVALID_WINDOW_ID = TabWindowManager.INVALID_WINDOW_INDEX;', '', '    // How long to delay closing the current tab when our app is minimized.  Have to delay this', ""    // so that we don't show the contents of the next tab while minimizing."", '    private static final long CLOSE_TAB_ON_MINIMIZE_DELAY_MS = 500;', '', '    // Maximum delay for initial tab creation. This is for homepage and NTP, not previous tabs', '    // restore. This is needed because we do not know when reading PartnerBrowserCustomizations', '    // provider will be finished.', '    private static final int INITIAL_TAB_CREATION_TIMEOUT_MS = 500;', '', '    /**', '     * Sending an intent with this action to Chrome will cause it to close all tabs', '     * (iff the --enable-test-intents command line flag is set). If a URL is supplied in the', '     * intent data, this will be loaded and unaffected by the close all action.', '     */', '    private static final String ACTION_CLOSE_TABS =', '            ""com.google.android.apps.chrome.ACTION_CLOSE_TABS"";', '', '    @VisibleForTesting', '    public static final String STARTUP_UMA_HISTOGRAM_SUFFIX = "".Tabbed"";', '', '    // Name of the ChromeTabbedActivity alias that handles MAIN intents.', '    public static final String MAIN_LAUNCHER_ACTIVITY_NAME = ""com.google.android.apps.chrome.Main"";', '', '    public static final SettingsLauncher SETTINGS_LAUNCHER = new SettingsLauncherImpl();', '', '    public static final HashSet<String> TABBED_MODE_COMPONENT_NAMES = new HashSet<String>() {', '        {', '            add(ChromeTabbedActivity.class.getName());', '            add(MultiInstanceChromeTabbedActivity.class.getName());', '            add(ChromeTabbedActivity2.class.getName());', '            add(MAIN_LAUNCHER_ACTIVITY_NAME);', '        }', '    };', '', '    /**', '     * Identifies a histogram to use in {@link #maybeDispatchExplicitMainViewIntent(Intent, int)}.', '     */', '    @IntDef({DispatchedBy.ON_CREATE, DispatchedBy.ON_NEW_INTENT})', '    @Retention(RetentionPolicy.SOURCE)', '    private @interface DispatchedBy {', '        int ON_CREATE = 1;', '        int ON_NEW_INTENT = 2;', '    }', '', '    // Count histogram used to track number of tabs when we show the Overview on Return to Chrome.', '    private static final String TAB_COUNT_ON_RETURN = ""Tabs.TabCountOnStartScreenShown"";', '', '    private final MainIntentBehaviorMetrics mMainIntentMetrics;', '    private @Nullable MultiInstanceManager mMultiInstanceManager;', '', '    private UndoBarController mUndoBarPopupController;', '', '    private LayoutManagerChrome mLayoutManager;', '', '    private ViewGroup mContentContainer;', '', '    private ToolbarControlContainer mControlContainer;', '', '    private TabbedModeTabModelOrchestrator mTabModelOrchestrator;', '    private TabModelSelectorBase mTabModelSelector;', '    private TabModelSelectorTabObserver mTabModelSelectorTabObserver;', '    private TabModelSelectorTabModelObserver mTabModelObserver;', '', '    private BrowserControlsVisibilityDelegate mVrBrowserControlsVisibilityDelegate;', '    private TabModalLifetimeHandler mTabModalHandler;', '', '    private boolean mUIWithNativeInitialized;', '', '    private Boolean mIsAccessibilityTabSwitcherEnabled;', '', '    private LocaleManager mLocaleManager;', '', '    private AppIndexingUtil mAppIndexingUtil;', '', '    private Runnable mShowHistoryRunnable;', '', '    private CompositorViewHolder mCompositorViewHolder;', '    private OverviewListLayout mOverviewListLayout;', '    /**', '     * Keeps track of whether or not a specific tab was created based on the startup intent.', '     */', '    private boolean mCreatedTabOnStartup;', '', '    // Whether or not the initial tab is being created.', '    private boolean mPendingInitialTabCreation;', '', '    // Whether {@link setInitialOverviewState()} has been called within the current onStart/onStop', '    // session.', '    private boolean mHasDeterminedOverviewStateForCurrentSession;', '    /**', '     *  Keeps track of the pref for the last time since this activity was stopped.', '     */', '    private ChromeInactivityTracker mInactivityTracker;', '', ""    // This is the cached value of mIntentHandler#shouldIgnoreIntent and shouldn't be read directly."", '    // Use #shouldIgnoreIntent instead.', '    private Boolean mShouldIgnoreIntent;', '    /*', '     *  Listens to FrameMetrics and records jank metrics.', '     */', '    private JankTrackerImpl mJankTracker;', '', '    // Supplier for a dependency to inform about the type of intent used to launch Chrome.', '    private OneshotSupplierImpl<ToolbarIntentMetadata> mIntentMetadataOneshotSupplier =', '            new OneshotSupplierImpl<>();', '', '    // Time at which an intent was received and handled.', '    private long mIntentHandlingTimeMs;', '', '    /**', '     * Whether the StartSurface is shown when Chrome is launched.', '     */', '    private boolean mOverviewShownOnStart;', '', '    private NextTabPolicySupplier mNextTabPolicySupplier;', '', '    private final UnownedUserDataSupplier<StartupPaintPreviewHelper>', '            mStartupPaintPreviewHelperSupplier = new StartupPaintPreviewHelperSupplier();', '', '    private final OneshotSupplierImpl<LayoutStateProvider> mLayoutStateProviderOneshotSupplier =', '            new OneshotSupplierImpl<>();', '    // TODO(crbug.com/1108496): Removed after all usages has been migrated to LayoutStateProvider.', '    private final OneshotSupplierImpl<OverviewModeBehavior> mOverviewModeBehaviorSupplier =', '            new OneshotSupplierImpl<>();', '    private OverviewModeController mOverviewModeController;', '', '    private ObservableSupplierImpl<EphemeralTabCoordinator> mEphemeralTabCoordinatorSupplier =', '            new ObservableSupplierImpl<>();', '    private final OneshotSupplierImpl<StartSurface> mStartSurfaceSupplier =', '            new OneshotSupplierImpl<>();', '    private ObservableSupplierImpl<Tab> mStartSurfaceParentTabSupplier =', '            new ObservableSupplierImpl<>();', '', '    private CallbackController mCallbackController = new CallbackController();', '    private TabbedModeTabDelegateFactory mTabDelegateFactory;', '', '    private final AppLaunchDrawBlocker mAppLaunchDrawBlocker;', '', '    // ID assigned to each ChromeTabbedActivity instance in Android S+ where multi-instance feature', '    // is supported. This can be explicitly set in the incoming Intent or internally assigned.', '    private int mWindowId;', '', '    private final IncognitoTabHost mIncognitoTabHost = new IncognitoTabHost() {', '        @Override', '        public boolean hasIncognitoTabs() {', '            return getTabModelSelector().getModel(true).getCount() > 0;', '        }', '', '        @Override', '        public void closeAllIncognitoTabs() {', '            if (isActivityFinishingOrDestroyed()) return;', '', '            // If the tabbed activity has not yet initialized, then finish the activity to avoid', '            // timing issues with clearing the incognito tab state in the background.', '            if (!areTabModelsInitialized() || !didFinishNativeInitialization()) {', '                finish();', '                return;', '            }', '', '            getTabModelSelector().getModel(true).closeAllTabs(false, false);', '        }', '', '        @Override', '        public boolean isActiveModel() {', '            return getTabModelSelector().getModel(true).isActiveModel();', '        }', '    };', '', '    /**', '     * This class is used to warm up the chrome split ClassLoader. See SplitChromeApplication for', '     * more info', '     */', '    @UsedByReflection(""SplitChromeApplication.java"")', '    public static class Preload extends ChromeTabbedActivity {', '        private LifecycleRegistry mLifecycleRegistry;', '', '        @UsedByReflection(""SplitChromeApplication.java"")', '        public Preload() {}', '', '        @Override', '        public Lifecycle getLifecycle() {', '            if (mLifecycleRegistry == null) {', '                // LifecycleRegistry normally enforces it is called on the main thread, but this', '                // class will be preloaded in a background thread. The only method that gets called', '                // in the activity constructor is addObserver(), so just override that.', '                mLifecycleRegistry = new LifecycleRegistry(null) {', '                    @Override', '                    public void addObserver(LifecycleObserver observer) {}', '                };', '            }', '            return mLifecycleRegistry;', '        }', '    }', '', '    /**', '     * Specify the proper non-.Main-aliased Chrome Activity for the given component.', '     *', '     * @param intent The intent to set the component for.', '     * @param component The client generated component to be validated.', '     */', '    public static void setNonAliasedComponent(Intent intent, ComponentName component) {', '        assert component != null;', '        Context appContext = ContextUtils.getApplicationContext();', '        if (!TextUtils.equals(component.getPackageName(), appContext.getPackageName())) {', '            return;', '        }', '        if (component.getClassName() != null', '                && TextUtils.equals(component.getClassName(),', '                        ChromeTabbedActivity.MAIN_LAUNCHER_ACTIVITY_NAME)) {', '            // Keep in sync with the activities that the .Main alias points to in', '            // AndroidManifest.xml.', '            intent.setClass(appContext, ChromeTabbedActivity.class);', '        } else {', '            intent.setComponent(component);', '        }', '    }', '', '    /**', '     * Constructs a ChromeTabbedActivity.', '     */', '    public ChromeTabbedActivity() {', '        mMainIntentMetrics = new MainIntentBehaviorMetrics();', '', '        // AppLaunchDrawBlocker may block drawing the Activity content until the initial tab is', '        // available.', '        // clang-format off', '        mAppLaunchDrawBlocker = new AppLaunchDrawBlocker(getLifecycleDispatcher(),', '                () -> findViewById(android.R.id.content),', '                this::getIntent, this::shouldIgnoreIntent, this::isTablet,', '                this::shouldShowOverviewPageOnStart);', '        // clang-format on', '    }', '', '    @Override', '    protected void onPreCreate() {', '        super.onPreCreate();', '        mMultiInstanceManager = MultiInstanceManager.create(this, getTabModelOrchestratorSupplier(),', '                getMultiWindowModeStateDispatcher(), getLifecycleDispatcher(),', '                getModalDialogManagerSupplier(), this);', '    }', '', '    @Override', '    protected @LaunchIntentDispatcher.Action int maybeDispatchLaunchIntent(', '            Intent intent, Bundle savedInstanceState) {', '        // Detect if incoming intent is a result of Chrome recreating itself. For now, restrict this', ""        // path to reparenting to ensure the launching logic isn't disrupted."", ""        // TODO(crbug.com/1065491): Unlock this codepath for all incoming intents once it's"", '        // confirmed working and stable.', '        if (savedInstanceState != null', '                && AsyncTabParamsManagerSingleton.getInstance().hasParamsWithTabToReparent()) {', '            return LaunchIntentDispatcher.Action.CONTINUE;', '        }', '', '        if (getClass().equals(ChromeTabbedActivity.class)', '                && Intent.ACTION_MAIN.equals(intent.getAction())) {', '            // Call dispatchToTabbedActivity() for MAIN intents to activate proper multi-window', '            // TabbedActivity (i.e. if CTA2 is currently running and Chrome is started, CTA2', ""            // should be brought to front). Don't call dispatchToTabbedActivity() for non-MAIN"", '            // intents to avoid breaking cases where CTA is started explicitly (e.g. to handle', ""            // 'Move to other window' command from CTA2)."", '            return LaunchIntentDispatcher.dispatchToTabbedActivity(this, intent);', '        }', '        @LaunchIntentDispatcher.Action', '        int action = maybeDispatchExplicitMainViewIntent(intent, DispatchedBy.ON_CREATE);', '        if (action != LaunchIntentDispatcher.Action.CONTINUE) {', '            return action;', '        }', '        return super.maybeDispatchLaunchIntent(intent, savedInstanceState);', '    }', '', '    // We know of at least one app that explicitly specifies .Main activity in custom tab', ""    // intents. The app shouldn't be doing that, but until it's updated, we need to support"", '    // such use case.', '    //', '    // This method attempts to treat VIEW intents explicitly sent to .Main as custom tab', '    // intents, and dispatch them accordingly. If the intent was not dispatched, the method', '    // returns Action.CONTINUE.', '    //', '    // The method also updates the supplied boolean histogram with the dispatching result,', '    // but only if the intent is a VIEW intent sent explicitly to .Main activity.', '    private @LaunchIntentDispatcher.Action int maybeDispatchExplicitMainViewIntent(', '            Intent intent, @DispatchedBy int dispatchedBy) {', ""        // The first check ensures that this is .Main activity alias (we can't check exactly, but"", '        // this gets us sufficiently close).', '        if (getClass().equals(ChromeTabbedActivity.class)', '                && Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getComponent() != null', '                && MAIN_LAUNCHER_ACTIVITY_NAME.equals(intent.getComponent().getClassName())) {', '            @LaunchIntentDispatcher.Action', '            int action = LaunchIntentDispatcher.dispatchToCustomTabActivity(this, intent);', '            switch (dispatchedBy) {', '                case DispatchedBy.ON_CREATE:', '                    RecordHistogram.recordBooleanHistogram(', '                            ""Android.MainActivity.ExplicitMainViewIntentDispatched.OnCreate"",', '                            action != LaunchIntentDispatcher.Action.CONTINUE);', '                    break;', '                case DispatchedBy.ON_NEW_INTENT:', '', '                    RecordHistogram.recordBooleanHistogram(', '                            ""Android.MainActivity.ExplicitMainViewIntentDispatched.OnNewIntent"",', '                            action != LaunchIntentDispatcher.Action.CONTINUE);', '                    break;', '                default:', '                    assert false : ""Unknown dispatchedBy value "" + dispatchedBy;', '            }', '            if (action == LaunchIntentDispatcher.Action.CONTINUE) {', '                // Intent was not dispatched, record its source.', '                @IntentHandler.ExternalAppId', '                int externalId = IntentHandler.determineExternalIntentSource(intent);', '                RecordHistogram.recordEnumeratedHistogram(', '                        ""Android.MainActivity.UndispatchedExplicitMainViewIntentSource"", externalId,', '                        IntentHandler.ExternalAppId.NUM_ENTRIES);', '', ""                // Crash if intent came from us, but only in debug builds and only if we weren't"", ""                // explicitly told not to. Hopefully we'll get enough reports to find where"", '                // these intents come from.', '                if (externalId == IntentHandler.ExternalAppId.CHROME', '                        && 0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE)', '                        && !CommandLine.getInstance().hasSwitch(', '                                ChromeSwitches.DONT_CRASH_ON_VIEW_MAIN_INTENTS)) {', '                    String intentInfo = intent.toString();', '                    Bundle extras = intent.getExtras();', '                    if (extras != null) {', '                        intentInfo +=', '                                "", extras.keySet = ["" + TextUtils.join("", "", extras.keySet()) + ""]"";', '                    }', '                    String message = String.format((Locale) null,', '                            ""VIEW intent sent to .Main activity alias was not dispatched. PLEASE ""', '                                    + ""report the following info to crbug.com/789732: \\""%s\\"". Use ""', '                                    + ""--%s flag to disable this check."",', '                            intentInfo, ChromeSwitches.DONT_CRASH_ON_VIEW_MAIN_INTENTS);', '                    throw new IllegalStateException(message);', '                }', '            }', '            return action;', '        }', '        return LaunchIntentDispatcher.Action.CONTINUE;', '    }', '', '    @Override', '    public void initializeCompositor() {', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.initializeCompositor"");', '            super.initializeCompositor();', '', '            // LocaleManager can only function after the native library is loaded.', '            mLocaleManager = LocaleManager.getInstance();', '            mLocaleManager.setSettingsLauncher(SETTINGS_LAUNCHER);', '            mLocaleManager.showSearchEnginePromoIfNeeded(this, null);', '', '            mTabModelOrchestrator.onNativeLibraryReady(getTabContentManager());', '', '            mTabModelObserver = new TabModelSelectorTabModelObserver(mTabModelSelector) {', '                @Override', '                public void didCloseTab(int tabId, boolean incognito) {', '                    closeIfNoTabsAndHomepageEnabled(false);', '                }', '', '                @Override', '                public void tabPendingClosure(Tab tab) {', '                    closeIfNoTabsAndHomepageEnabled(true);', '                }', '', '                @Override', '                public void tabRemoved(Tab tab) {', '                    closeIfNoTabsAndHomepageEnabled(false);', '                }', '', '                private void closeIfNoTabsAndHomepageEnabled(boolean isPendingClosure) {', '                    if (getTabModelSelector().getTotalTabCount() == 0) {', '                        // If the last tab is closed, and homepage is enabled, then exit Chrome.', '                        if (HomepageManager.shouldCloseAppWithZeroTabs()) {', '                            finish();', '                        } else if (isPendingClosure) {', '                            NewTabPageUma.recordNTPImpression(', '                                    NewTabPageUma.NTP_IMPESSION_POTENTIAL_NOTAB);', '                        }', '                    }', '', '                    // TODO(960196) : remove this when the associated bug fix. This is a band-aid', '                    //  fix for TabGrid and closing tabs with TabGroupUi.', '                    //  If one of the following is true, then exit Chrome when TabGroupsAndroid is', '                    //  enabled, and tab switcher is not shown:', '                    //   1. If the very last tab is closed.', '                    //   2. If normal tab model is selected and no normal tabs.', '                    if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(ChromeTabbedActivity.this)', '                            && !mOverviewModeController.overviewVisible()) {', '                        if (getTabModelSelector().getTotalTabCount() == 0', '                                || (!getTabModelSelector().isIncognitoSelected()', '                                        && getTabModelSelector().getModel(false).getCount() == 0)) {', '                            finish();', '                        }', '                    }', '                }', '', '                @Override', '                public void didAddTab(', '                        Tab tab, @TabLaunchType int type, @TabCreationState int creationState) {', '                    if (type == TabLaunchType.FROM_LONGPRESS_BACKGROUND', '                            && !DeviceClassManager.enableAnimations()) {', '                        Toast.makeText(ChromeTabbedActivity.this, R.string.open_in_new_tab_toast,', '                                     Toast.LENGTH_SHORT)', '                                .show();', '                    }', '                }', '', '                @Override', '                public void multipleTabsPendingClosure(List<Tab> tabs, boolean isAllTabs) {', '                    if (!isAllTabs) return;', '                    NewTabPageUma.recordNTPImpression(NewTabPageUma.NTP_IMPESSION_POTENTIAL_NOTAB);', '                }', '            };', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.initializeCompositor"");', '        }', '    }', '', '    private void refreshSignIn() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.refreshSignIn"")) {', '            FirstRunSignInProcessor.start(this);', '        }', '    }', '', '    private void setupCompositorContentPreNativeForPhone() {', '        if (isTablet()) return;', '', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPreNativeForPhone"")) {', '            CompositorViewHolder compositorViewHolder = getCompositorViewHolderSupplier().get();', '', '            // TODO(1169205): Remove all GTS enabled checks after M5 is default.', '            if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(this)) {', '                TabManagementDelegate tabManagementDelegate =', '                        TabManagementModuleProvider.getDelegate();', '                if (tabManagementDelegate != null) {', '                    StartSurface startSurface = tabManagementDelegate.createStartSurface(this,', '                            mRootUiCoordinator.getScrimCoordinator(),', '                            mRootUiCoordinator.getBottomSheetController(), mStartSurfaceSupplier,', '                            mStartSurfaceParentTabSupplier, hadWarmStart(), getWindowAndroid(),', '                            compositorViewHolder, compositorViewHolder::getDynamicResourceLoader,', '                            getTabModelSelector(), getBrowserControlsManager(),', '                            getSnackbarManager(), getShareDelegateSupplier(),', '                            getToolbarManager()::getOmniboxStub, getTabContentManager(),', '                            getModalDialogManager(),', '                            /* chromeActivityNativeDelegate= */ this, getLifecycleDispatcher(),', '                            getTabCreatorManagerSupplier().get(),', '                            getMenuOrKeyboardActionController(),', '                            getMultiWindowModeStateDispatcher(), mJankTracker,', '                            getToolbarManager()::getToolbar);', '                }', '            }', '', '            // clang-format off', '            mLayoutManager = new LayoutManagerChromePhone(compositorViewHolder, mContentContainer,', '                    mStartSurfaceSupplier.get(), getTabContentManagerSupplier(),', '                    () -> {', '                        if (!getCompositorViewHolderSupplier().hasValue()) return null;', '                        return getCompositorViewHolderSupplier().get().getLayerTitleCache();', '                    },', '                    mOverviewModeBehaviorSupplier,', '                    mRootUiCoordinator::getTopUiThemeColorProvider, mJankTracker);', '            mLayoutStateProviderOneshotSupplier.set(mLayoutManager);', '            // clang-format on', '            mOverviewModeController = mLayoutManager;', '        }', '    }', '', '    private void setupCompositorContentPreNativeForTablet() {', '        if (!isTablet()) return;', '', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPreNativeForTablet"")) {', '            // clang-format off', '            mLayoutManager = new LayoutManagerChromeTablet(getCompositorViewHolderSupplier().get(),', '                    mContentContainer, getTabContentManagerSupplier(),', '                    () -> {', '                        if (!getCompositorViewHolderSupplier().hasValue()) return null;', '                        return getCompositorViewHolderSupplier().get().getLayerTitleCache();', '                    },', '                    mOverviewModeBehaviorSupplier,', '                    mRootUiCoordinator::getTopUiThemeColorProvider, mJankTracker);', '            mLayoutStateProviderOneshotSupplier.set(mLayoutManager);', '            // clang-format on', '            mOverviewModeController = mLayoutManager;', '        }', '    }', '', '    private void setupCompositorContentPostNative() {', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPostNative"")) {', '            if (!isLayoutManagerCreated()) {', '                if (isTablet()) {', '                    setupCompositorContentPreNativeForTablet();', '                } else {', '                    setupCompositorContentPreNativeForPhone();', '                }', '            }', '', '            mLayoutManager.setEnableAnimations(DeviceClassManager.enableAnimations());', '', '            // TODO(yusufo): get rid of findViewById(R.id.url_bar).', '            initializeCompositorContent(mLayoutManager, findViewById(R.id.url_bar),', '                    mContentContainer, mControlContainer);', '        }', '    }', '', '    private boolean isLayoutManagerCreated() {', '        return mLayoutManager != null;', '    }', '', '    private void initializeToolbarManager() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.initializeToolbarManager"")) {', '            mUndoBarPopupController.initialize();', '', '            OnClickListener tabSwitcherClickHandler = v -> {', '                if (ChromeFeatureList.isEnabled(ChromeFeatureList.TOOLBAR_IPH_ANDROID)) {', '                    Profile profile = mTabModelProfileSupplier.get();', '                    if (profile != null) {', '                        TrackerFactory.getTrackerForProfile(profile).notifyEvent(', '                                EventConstants.TAB_SWITCHER_BUTTON_CLICKED);', '                    }', '                }', '', '                if (getFullscreenManager().getPersistentFullscreenMode()) {', '                    return;', '                }', '', '                if (isInOverviewMode()', '                        && !ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '                    hideOverview();', '                } else {', '                    showOverview(StartSurfaceState.SHOWING_TABSWITCHER);', '                }', '            };', '            OnClickListener newTabClickHandler = v -> {', '                getTabModelSelector().getModel(false).commitAllTabClosures();', '                // This assumes that the keyboard can not be seen at the same time as the', '                // newtab button on the toolbar.', '                getCurrentTabCreator().launchNTP();', '                mLocaleManager.showSearchEnginePromoIfNeeded(ChromeTabbedActivity.this, null);', '                if (getTabModelSelector().isIncognitoSelected()) {', '                    RecordUserAction.record(""MobileToolbarStackViewNewIncognitoTab"");', '                } else {', '                    RecordUserAction.record(""MobileToolbarStackViewNewTab"");', '                }', '                RecordUserAction.record(""MobileTopToolbarNewTabButton"");', '', '                RecordUserAction.record(""MobileNewTabOpened"");', '                ReturnToChromeExperimentsUtil.onNewTabOpened();', '            };', '            OnClickListener bookmarkClickHandler = v -> addOrEditBookmark(getActivityTab());', '', '            Supplier<Boolean> showStartSurfaceSupplier = () -> {', '                // If incognito is selected, tapping the home button stays on the current incognito', '                // tab.', '                if (ReturnToChromeExperimentsUtil.shouldShowStartSurfaceAsTheHomePageOnPhone(', '                            this, isTablet())', '                        && !mTabModelSelector.isIncognitoSelected()) {', '                    StartSurfaceUserData.setKeepTab(getActivityTab(), true);', '                    showOverview(StartSurfaceState.SHOWING_HOMEPAGE);', '                    return true;', '                }', '                return false;', '            };', '', '            getToolbarManager().initializeWithNative(mLayoutManager, tabSwitcherClickHandler,', '                    newTabClickHandler, bookmarkClickHandler, null, showStartSurfaceSupplier);', '', '            if (!TabUiFeatureUtilities.supportInstantStart(isTablet(), this)) {', '                assert !(mOverviewModeController != null', '                        && mOverviewModeController.overviewVisible());', '            }', '        }', '    }', '', '    private void maybeCreateIncognitoTabSnapshotController() {', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.maybeCreateIncognitoTabSnapshotController"")) {', '            if (!CommandLine.getInstance().hasSwitch(', '                        ChromeSwitches.ENABLE_INCOGNITO_SNAPSHOTS_IN_ANDROID_RECENTS)) {', '                IncognitoTabSnapshotController.createIncognitoTabSnapshotController(', '                        this, getWindow(), mLayoutManager, mTabModelSelector);', '            }', '', '            mUIWithNativeInitialized = true;', '            onAccessibilityTabSwitcherModeChanged();', '', '            // The dataset has already been created, we need to initialize our state.', '            mTabModelSelector.notifyChanged();', '', '            // Check for incognito tabs to handle the case where Chrome was swiped away in the', '            // background.', '            if (!IncognitoTabHostUtils.doIncognitoTabsExist()) {', '                IncognitoNotificationManager.dismissIncognitoNotification();', '                DownloadNotificationService.getInstance().cancelOffTheRecordDownloads();', '            }', '        }', '    }', '', '    private void maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.""', '                     + ""maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver"")) {', '            FeedSurfaceTracker.getInstance().startup();', '', '            if (UsageStatsService.isEnabled()) {', '                UsageStatsService.getInstance().createPageViewObserver(', '                        this, getActivityTabProvider(), getTabContentManagerSupplier());', '            }', '        }', '    }', '', '    private void initJourneyManager() {', '        assert mOverviewModeController != null;', '', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.initJourneyManager"")) {', '            if (ChromeFeatureList.isEnabled(ChromeFeatureList.TAB_ENGAGEMENT_REPORTING_ANDROID)) {', '                // The lifecycle of this object is managed by the lifecycle dispatcher.', '                new JourneyManager(getTabModelSelector(), getLifecycleDispatcher(),', '                        mOverviewModeController, new EngagementTimeUtil());', '            }', '        }', '    }', '', '    @Override', '    public void onNewIntent(Intent intent) {', ""        // The intent to use in maybeDispatchExplicitMainViewIntent(). We're explicitly"", '        // adding NEW_TASK flag to make sure backing from CCT brings up the caller activity,', '        // and not Chrome', '        Intent intentForDispatching = new Intent(intent);', '        intentForDispatching.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);', '        @LaunchIntentDispatcher.Action', '        int action = maybeDispatchExplicitMainViewIntent(', '                intentForDispatching, DispatchedBy.ON_NEW_INTENT);', '        if (action != LaunchIntentDispatcher.Action.CONTINUE) {', '            // Pressing back button in CCT should bring user to the caller activity.', '            moveTaskToBack(true);', '            // Intent was dispatched to CustomTabActivity, consume it.', '            return;', '        }', '', '        mIntentHandlingTimeMs = SystemClock.uptimeMillis();', '        super.onNewIntent(intent);', '    }', '', '    @Override', '    public void startNativeInitialization() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.startNativeInitialization"")) {', ""            // This is on the critical path so don't delay."", '            if (ChromeFeatureList.isEnabled(', '                        ChromeFeatureList.DARKEN_WEBSITES_CHECKBOX_IN_THEMES_SETTING)) {', '                WebContentsDarkModeController.createInstance();', '            }', '            setupCompositorContentPostNative();', '', ""            // All this initialization can be expensive so it's split into multiple tasks."", '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::refreshSignIn));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::initializeToolbarManager));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::maybeCreateIncognitoTabSnapshotController));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::onAccessibilityTabSwitcherModeChanged));', '', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::initJourneyManager));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::finishNativeInitialization));', '            ChromeAccessibilityUtil.get().addObserver(this);', '        }', '    }', '', '    @Override', '    public void finishNativeInitialization() {', '        super.finishNativeInitialization();', '', '        // TODO(jinsukkim): Let these classes handle the registration by themselves.', '        mCompositorViewHolder = getCompositorViewHolderSupplier().get();', '        mOverviewListLayout = (OverviewListLayout) mLayoutManager.getOverviewListLayout();', '        getTabObscuringHandler().addObserver(mCompositorViewHolder);', '        getTabObscuringHandler().addObserver(mOverviewListLayout);', '', '        ChromeAccessibilityUtil.get().addObserver(mLayoutManager);', '        if (isTablet()) ChromeAccessibilityUtil.get().addObserver(mCompositorViewHolder);', '    }', '', '    @Override', '    public void onResumeWithNative() {', '        super.onResumeWithNative();', '', '        IncognitoStartup.onResumeWithNative(', '                getTabModelSelectorSupplier(), TABBED_MODE_COMPONENT_NAMES);', '', '        mLocaleManager.setSnackbarManager(getSnackbarManager());', '        mLocaleManager.startObservingPhoneChanges();', '', '        if (isWarmOnResume()) {', '            NavigationPredictorBridge.onActivityWarmResumed();', '        } else {', '            NavigationPredictorBridge.onColdStart();', '        }', '', '        // This call is not guarded by a feature flag.', '        SearchEngineChoiceNotification.handleSearchEngineChoice(', '                this, getSnackbarManager(), SETTINGS_LAUNCHER);', '', '        if (!isWarmOnResume()) {', '            SuggestionsMetrics.recordArticlesListVisible();', '        }', '    }', '', '    @Override', '    public void onPauseWithNative() {', '        mTabModelSelector.commitAllTabClosures();', '        CookiesFetcher.persistCookies();', '', '        mLocaleManager.setSnackbarManager(null);', '        mLocaleManager.stopObservingPhoneChanges();', '', '        NavigationPredictorBridge.onPause();', '', '        super.onPauseWithNative();', '    }', '', '    @Override', '    public void onStopWithNative() {', '        super.onStopWithNative();', '', '        mTabModelOrchestrator.saveState();', '        mHasDeterminedOverviewStateForCurrentSession = false;', '    }', '', '    @Override', '    public void onStartWithNative() {', '        mMainIntentMetrics.logLaunchBehavior();', '        super.onStartWithNative();', '', ""        // Don't call setInitialOverviewState if we're waiting for the tab's creation or we risk"", '        // showing a glimpse of the tab selector during start up.', '        if (!mPendingInitialTabCreation) {', '            setInitialOverviewState();', '        }', '', '        if (TabUiFeatureUtilities.isConditionalTabStripEnabled()', '                || ConditionalTabStripUtils.getOptOutIndicator()) {', '            ConditionalTabStripUtils.updateFeatureExpiration(', '                    mInactivityTracker.getLastBackgroundedTimeMs());', '        }', '', '        Bundle savedInstanceState = getSavedInstanceState();', '        if (savedInstanceState != null', '                && savedInstanceState.getBoolean(IS_INCOGNITO_SELECTED, false)) {', '            // This will be executed only once since SavedInstanceState will be reset a few lines', '            // later.', '            AndroidSessionDurationsServiceState.restoreNativeFromSerialized(savedInstanceState,', '                    getCurrentTabModel().getProfile().getPrimaryOTRProfile(', '                            /* createIfNeeded= */ true));', '        }', '', '        resetSavedInstanceState();', '        StartSurfaceConfiguration.addFeedVisibilityObserver();', '        BookmarkUtils.maybeExpireLastBookmarkLocationForReadLater(', '                mInactivityTracker.getTimeSinceLastBackgroundedMs());', '    }', '', '    @Override', '    public void onNewIntentWithNative(Intent intent) {', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.onNewIntentWithNative"");', '', '            super.onNewIntentWithNative(intent);', '            if (IntentUtils.isMainIntentFromLauncher(intent)) {', '                logMainIntentBehavior(intent);', '            }', '', '            if (CommandLine.getInstance().hasSwitch(ContentSwitches.ENABLE_TEST_INTENTS)) {', '                handleDebugIntent(intent);', '            }', '', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.onNewIntentWithNative"");', '        }', '    }', '', '    @Override', '    public @ActivityType int getActivityType() {', '        return ActivityType.TABBED;', '    }', '', '    @Override', '    public ChromeTabCreator getTabCreator(boolean incognito) {', '        return (ChromeTabCreator) super.getTabCreator(incognito);', '    }', '', '    @Override', '    public ChromeTabCreator getCurrentTabCreator() {', '        return (ChromeTabCreator) super.getCurrentTabCreator();', '    }', '', '    @Override', '    public OverviewModeBehavior getOverviewModeBehavior() {', '        return mOverviewModeController;', '    }', '', '    @Override', '    public @Nullable OneshotSupplier<OverviewModeBehavior> getOverviewModeBehaviorSupplier() {', '        return mOverviewModeBehaviorSupplier;', '    }', '', '    /**', '     * @return The toolbar button in-product help controller for this activity.', '     * TODO(pnoland, https://crbug.com/865801): remove this in favor', ""     *        of injecting the controller directly where it's needed."", '     */', '    public ToolbarButtonInProductHelpController getToolbarButtonInProductHelpController() {', '        return ((TabbedRootUiCoordinator) mRootUiCoordinator)', '                .getToolbarButtonInProductHelpController();', '    }', '', '    private void handleDebugIntent(Intent intent) {', '        if (ACTION_CLOSE_TABS.equals(intent.getAction())) {', '            getTabModelSelector().closeAllTabs();', '        } else if (MemoryPressureListener.handleDebugIntent(', '                           ChromeTabbedActivity.this, intent.getAction())) {', '            // Handled.', '        }', '    }', '', '    private void setTrackColdStartupMetrics(boolean shouldTrackColdStartupMetrics) {', '        assert getActivityTabStartupMetricsTracker() != null;', '', '        if (shouldTrackColdStartupMetrics) {', '            getActivityTabStartupMetricsTracker().trackStartupMetrics(STARTUP_UMA_HISTOGRAM_SUFFIX);', '        } else {', '            getActivityTabStartupMetricsTracker().cancelTrackingStartupMetrics();', '        }', '', '        // Paint Preview should follow the same logic as startup UMA histograms as the feature', '        // should only run on cold startup of Chrome when the user is unable to interact before', '        // entering a tab.', '        StartupPaintPreviewHelper.setShouldShowOnRestore(shouldTrackColdStartupMetrics);', '    }', '', '    private void setInitialOverviewState() {', '        if (mHasDeterminedOverviewStateForCurrentSession) return;', '', '        mHasDeterminedOverviewStateForCurrentSession = true;', '        boolean isOverviewVisible = mOverviewModeController.overviewVisible();', '', '        if (shouldRefreshAndShowOverview(isOverviewVisible)) {', '            if (getCurrentTabModel() != null) {', '                RecordHistogram.recordCountHistogram(', '                        TAB_COUNT_ON_RETURN, getCurrentTabModel().getCount());', '            }', '            if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(this) && !isTablet()) {', '                mStartSurfaceSupplier.get().getController().enableRecordingFirstMeaningfulPaint(', '                        getOnCreateTimestampMs());', '            }', '            mOverviewShownOnStart = true;', '            // Cancel recording cold startup metrics if an overview is shown as they expect a tab to', '            // be the first thing shown after startup.', '            setTrackColdStartupMetrics(false);', '            showOverview(StartSurfaceState.SHOWING_START);', '            return;', '        }', '', '        if (getActivityTab() == null && !isOverviewVisible) {', '            mOverviewShownOnStart = true;', '            // Cancel recording cold startup metrics if an overview is shown as they expect a tab to', '            // be the first thing shown after startup.', '            setTrackColdStartupMetrics(false);', '            showOverview(StartSurfaceState.SHOWING_START);', '        }', '', '        if (IntentUtils.isMainIntentFromLauncher(getIntent())', '                && mOverviewModeController.overviewVisible()) {', '            RecordUserAction.record(""MobileStartup.UserEnteredTabSwitcher"");', '        }', '    }', '', '    private boolean shouldRefreshAndShowOverview(boolean isOverviewVisible) {', '        // If StartSurfaceConfiguration.NEW_SURFACE_FROM_HOME_BUTTON is turned on, MV tiles and', '        // carousels may be hidden before Chrome is brought to the background. If overview should be', '        // shown, no matter overview was already visible or not, we should call', '        // showOverview(StartSurfaceState.SHOWING_START) to show MV tiles and carousels again.', '        return shouldShowOverviewPageOnStart()', '                && (!isOverviewVisible', '                        || StartSurfaceConfiguration.shouldShowNewSurfaceFromHomeButton());', '    }', '', '    /**', '     * Returns whether grid Tab switcher or the Start surface should be shown at startup.', '     */', '    private boolean shouldShowOverviewPageOnStart() {', '        return ReturnToChromeExperimentsUtil.shouldShowOverviewPageOnStart(', '                this, getIntent(), getTabModelSelector(), mInactivityTracker);', '    }', '', '    private void logMainIntentBehavior(Intent intent) {', '        assert IntentUtils.isMainIntentFromLauncher(intent);', '        // TODO(tedchoc): We should cache the last visible time and reuse it to avoid different', '        //                values of this depending on when it is called after the activity was', '        //                shown.', '', '        // Temporary safety check to make sure none of this code runs if the feature is', '        // disabled.', '        if (ReengagementNotificationController.isEnabled()) {', '            if (mCallbackController != null) {', '                new OneShotCallback<>(', '                        mTabModelProfileSupplier, mCallbackController.makeCancelable(profile -> {', '                            assert profile != null : ""Unexpectedly null profile from TabModel."";', '                            if (profile == null) return;', '', '                            TrackerFactory.getTrackerForProfile(profile).notifyEvent(', '                                    EventConstants.STARTED_FROM_MAIN_INTENT);', '                        }));', '            }', '        }', '', '        mMainIntentMetrics.onMainIntentWithNative(', '                mInactivityTracker.getTimeSinceLastBackgroundedMs());', '    }', '', '    /** Access the main intent metrics for test validation. */', '    @VisibleForTesting', '    public MainIntentBehaviorMetrics getMainIntentBehaviorMetricsForTesting() {', '        return mMainIntentMetrics;', '    }', '', '    @VisibleForTesting', '    public ChromeInactivityTracker getInactivityTrackerForTesting() {', '        return mInactivityTracker;', '    }', '', '    @Override', '    public void initializeState() {', '        // This method goes through 3 steps:', ""        // 1. Load the saved tab state (but don't start restoring the tabs yet)."", '        // 2. Process the Intent that this activity received and if that should result in any', '        //    new tabs, create them.  This is done after step 1 so that the new tab gets', '        //    created after previous tab state was restored.', '        // 3. If no tabs were created in any of the above steps, create an NTP, otherwise', '        //    start asynchronous tab restore (loading the previously active tab synchronously', '        //    if no new tabs created in step 2).', '', '        // Only look at the original intent if this is not a ""restoration"" and we are allowed to', '        // process intents. Any subsequent intents are carried through onNewIntent.', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.initializeState"");', '', '            super.initializeState();', '            Log.i(TAG, ""#initializeState"");', '            Intent intent = getIntent();', '', '            boolean hadCipherData =', '                    CipherFactory.getInstance().restoreFromBundle(getSavedInstanceState());', '', '            boolean noRestoreState =', '                    CommandLine.getInstance().hasSwitch(ChromeSwitches.NO_RESTORE_STATE);', '            if (noRestoreState) {', '                // Clear the state files because they are inconsistent and useless from now on.', '                mTabModelOrchestrator.clearState();', '            } else {', '                // State should be clear when we start first run and hence we do not need to load', '                // a previous state. This may change the current Model, watch out for initialization', '                // based on the model.', '                // Never attempt to restore incognito tabs when this activity was previously swiped', '                // away in Recents. http://crbug.com/626629', '                boolean ignoreIncognitoFiles = !hadCipherData;', '                mTabModelOrchestrator.loadState(ignoreIncognitoFiles);', '            }', '', '            mInactivityTracker.register(this.getLifecycleDispatcher());', '            boolean isIntentWithEffect = false;', '            boolean isMainIntentFromLauncher = false;', '            if (getSavedInstanceState() == null && intent != null) {', '                if (!shouldIgnoreIntent()) {', '                    isIntentWithEffect = mIntentHandler.onNewIntent(intent);', '                }', '', '                if (IntentUtils.isMainIntentFromLauncher(intent)) {', '                    isMainIntentFromLauncher = true;', '                    logMainIntentBehavior(intent);', '                }', '            }', '', '            mIntentMetadataOneshotSupplier.set(', '                    new ToolbarIntentMetadata(isMainIntentFromLauncher, isIntentWithEffect));', '', '            // If we have tabs to reparent and getSavedInstanceState() is non-null, then the tabs', '            // are coming from night mode tab reparenting. In this case, reparenting happens', '            // synchronously along with tab restoration so there are no tabs waiting for', '            // reparenting like there are for other tab reparenting operations.', '            boolean hasTabWaitingForReparenting =', '                    AsyncTabParamsManagerSingleton.getInstance().hasParamsWithTabToReparent()', '                    && getSavedInstanceState() == null;', '            mCreatedTabOnStartup = getCurrentTabModel().getCount() > 0', '                    || mTabModelOrchestrator.getRestoredTabCount() > 0 || isIntentWithEffect', '                    || hasTabWaitingForReparenting;', '', '            // We always need to try to restore tabs. The set of tabs might be empty, but at least', '            // it will trigger the notification that tab restore is complete which is needed by', '            // other parts of Chrome such as sync.', '            boolean activeTabBeingRestored = !isIntentWithEffect', '                    || (shouldShowOverviewPageOnStart()', '                            && !mTabModelSelector.isIncognitoSelected());', '', '            mTabModelOrchestrator.restoreTabs(activeTabBeingRestored);', '', '            // Only create an initial tab if no tabs were restored and no intent was handled.', '            // Also, check whether the active tab was supposed to be restored and that the total', '            // tab count is now non zero.  If this is not the case, tab restore failed and we need', '            // to create a new tab as well.', '            if (!mCreatedTabOnStartup', '                    || (!hasTabWaitingForReparenting && activeTabBeingRestored', '                            && getTabModelSelector().getTotalTabCount() == 0)) {', '                // If homepage URI is not determined, due to PartnerBrowserCustomizations provider', '                // async reading, then create a tab at the async reading finished. If it takes', '                // too long, just create NTP.', '', '                mPendingInitialTabCreation = true;', '                PartnerBrowserCustomizations.getInstance().setOnInitializeAsyncFinished(() -> {', '                    if (!isActivityFinishingOrDestroyed()) {', '                        createInitialTab();', '                    }', '                }, INITIAL_TAB_CREATION_TIMEOUT_MS);', '            }', '', '            // If initial tab creation is pending, this will instead be handled when we create the', '            // initial tab in #createInitialTab.', '            if (!mPendingInitialTabCreation) {', '                mAppLaunchDrawBlocker.onActiveTabAvailable(isTabRegularNtp(getActivityTab()));', '            }', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.initializeState"");', '        }', '    }', '', '    private boolean hasStartWithNativeBeenCalled() {', '        int activity_state = getLifecycleDispatcher().getCurrentActivityState();', '        return activity_state == ActivityLifecycleDispatcher.ActivityState.STARTED_WITH_NATIVE', '                || activity_state == ActivityLifecycleDispatcher.ActivityState.RESUMED_WITH_NATIVE;', '    }', '', '    /**', '     * Create an initial tab for cold start without restored tabs.', '     */', '    private void createInitialTab() {', '        Log.i(TAG, ""#createInitialTab executed."");', '        mPendingInitialTabCreation = false;', '', '        // If the start surface or grid tab switcher will be shown on start, do not create a new', '        // tab.', '        if (!shouldShowOverviewPageOnStart()) {', '            String url = HomepageManager.getHomepageUri();', '            if (TextUtils.isEmpty(url)) {', '                url = UrlConstants.NTP_URL;', '            } else {', '                // Migrate legacy NTP URLs (chrome://newtab) to the newer format', '                // (chrome-native://newtab)', '                if (UrlUtilities.isNTPUrl(url)) {', '                    url = UrlConstants.NTP_URL;', '                }', '            }', '', '            getTabCreator(false).launchUrl(url, TabLaunchType.FROM_STARTUP);', '        }', '', ""        // If we didn't call setInitialOverviewState() in onStartWithNative() because"", '        // mPendingInitialTabCreation was true then do so now.', '        if (hasStartWithNativeBeenCalled()) {', '            setInitialOverviewState();', '        }', '', '        mAppLaunchDrawBlocker.onActiveTabAvailable(isTabRegularNtp(getActivityTab()));', '    }', '', '    @Override', '    public void onAccessibilityModeChanged(boolean enabled) {', '        onAccessibilityTabSwitcherModeChanged();', '    }', '', '    private void onAccessibilityTabSwitcherModeChanged() {', '        if (!mUIWithNativeInitialized) return;', '', '        boolean accessibilityTabSwitcherEnabled =', '                DeviceClassManager.enableAccessibilityLayout(this);', '        if (mOverviewModeController != null && mOverviewModeController.overviewVisible()', '                && (mIsAccessibilityTabSwitcherEnabled == null', '                        || mIsAccessibilityTabSwitcherEnabled', '                                != DeviceClassManager.enableAccessibilityLayout(this))) {', '            /**', '             * If Start surface homepage is showing and launching NTP will show the Start surface', '             * again, skips the calls of hideOverview() and launchNTP(). We need to check', '             * {@link ReturnToChromeExperimentsUtil#shouldShowStartSurfaceHomeAsNTP(Context,', '             * boolean, boolean)} to see whether Start surface can be shown when accessibility is', '             * enabled.', '             */', '            if (mStartSurfaceSupplier.get() == null', '                    || mStartSurfaceSupplier.get().getController().getStartSurfaceState()', '                            != StartSurfaceState.SHOWN_HOMEPAGE', '                    || !ReturnToChromeExperimentsUtil.shouldShowStartSurfaceHomeAsNTP(', '                            this, getCurrentTabModel().isIncognito(), isTablet())) {', '                mOverviewModeController.hideOverview(true);', '                if (getTabModelSelector().getCurrentModel().getCount() == 0) {', '                    getCurrentTabCreator().launchNTP();', '                }', '            }', '        }', '        mIsAccessibilityTabSwitcherEnabled = accessibilityTabSwitcherEnabled;', '', '        if (ChromeAccessibilityUtil.get().isAccessibilityEnabled()) {', '            RecordHistogram.recordBooleanHistogram(', '                    ""Accessibility.Android.TabSwitcherPreferenceEnabled"",', '                    mIsAccessibilityTabSwitcherEnabled);', '        }', '    }', '', '    /**', '     * Internal class which performs the intent handling operations delegated by IntentHandler.', '     */', '    private class InternalIntentDelegate implements IntentHandler.IntentHandlerDelegate {', '        /**', '         * Processes a url view intent.', '         *', '         * @param url The url from the intent.', '         */', '        @Override', '        public void processUrlViewIntent(LoadUrlParams loadUrlParams, @TabOpenType int tabOpenType,', '                String externalAppId, int tabIdToBringToFront, Intent intent) {', '            if (isActivityFinishingOrDestroyed()) {', '                return;', '            }', '            if (isFromChrome(intent, externalAppId)) {', '                RecordUserAction.record(""MobileTabbedModeViewIntentFromChrome"");', '            } else {', '                RecordUserAction.record(""MobileTabbedModeViewIntentFromApp"");', '            }', '', '            final String url = loadUrlParams.getUrl();', '            boolean fromLauncherShortcut = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_INVOKED_FROM_SHORTCUT, false);', '            boolean fromAppWidget = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_INVOKED_FROM_APP_WIDGET, false);', '            boolean focus = false;', '', '            TabModel tabModel = getCurrentTabModel();', '            switch (tabOpenType) {', '                case TabOpenType.REUSE_URL_MATCHING_TAB_ELSE_NEW_TAB:', '                    mTabModelOrchestrator.tryToRestoreTabStateForUrl(url);', '                    int tabToBeClobberedIndex = TabModelUtils.getTabIndexByUrl(tabModel, url);', '                    Tab tabToBeClobbered = tabModel.getTabAt(tabToBeClobberedIndex);', '                    if (tabToBeClobbered != null) {', '                        TabModelUtils.setIndex(tabModel, tabToBeClobberedIndex);', '                        tabToBeClobbered.reload();', '                    } else {', '                        launchIntent(loadUrlParams, externalAppId, true, intent);', '                    }', '                    int shortcutSource = intent.getIntExtra(', '                            WebappConstants.EXTRA_SOURCE, ShortcutSource.UNKNOWN);', '                    LaunchMetrics.recordHomeScreenLaunchIntoTab(url, shortcutSource);', '                    if (fromAppWidget && url.startsWith(UrlConstants.CHROME_DINO_URL)) {', '                        RecordUserAction.record(""QuickActionSearchWidget.StartDinoGame"");', '                    }', '                    break;', '                case TabOpenType.BRING_TAB_TO_FRONT:', '                    mTabModelOrchestrator.tryToRestoreTabStateForId(tabIdToBringToFront);', '', '                    int tabIndex = TabModelUtils.getTabIndexById(tabModel, tabIdToBringToFront);', '                    if (tabIndex == TabModel.INVALID_TAB_INDEX) {', '                        TabModel otherModel =', '                                getTabModelSelector().getModel(!tabModel.isIncognito());', '                        tabIndex = TabModelUtils.getTabIndexById(otherModel, tabIdToBringToFront);', '                        if (tabIndex != TabModel.INVALID_TAB_INDEX) {', '                            getTabModelSelector().selectModel(otherModel.isIncognito());', '                            TabModelUtils.setIndex(otherModel, tabIndex);', '                        } else {', '                            Log.e(TAG, ""Failed to bring tab to front because it doesn\'t exist."");', '                            return;', '                        }', '                    } else {', '                        TabModelUtils.setIndex(tabModel, tabIndex);', '                    }', '                    break;', '                case TabOpenType.CLOBBER_CURRENT_TAB:', '                    // The browser triggered the intent. This happens when clicking links which', '                    // can be handled by other applications (e.g. www.youtube.com links).', '                    Tab currentTab = getActivityTab();', '                    if (currentTab != null) {', '                        RedirectHandlerTabHelper.updateIntentInTab(currentTab, intent);', '                        currentTab.loadUrl(loadUrlParams);', '                    } else {', '                        launchIntent(loadUrlParams, externalAppId, true, intent);', '                    }', '                    break;', '                case TabOpenType.REUSE_APP_ID_MATCHING_TAB_ELSE_NEW_TAB:', '                    launchIntent(loadUrlParams, externalAppId, false, intent);', '                    break;', '                case TabOpenType.REUSE_TAB_MATCHING_ID_ELSE_NEW_TAB:', '                    int tabId = IntentUtils.safeGetIntExtra(', '                            intent, TabOpenType.REUSE_TAB_MATCHING_ID_STRING, Tab.INVALID_TAB_ID);', '                    if (tabId != Tab.INVALID_TAB_ID) {', '                        mTabModelOrchestrator.tryToRestoreTabStateForId(tabId);', '                        int matchingTabIndex = TabModelUtils.getTabIndexById(tabModel, tabId);', '                        boolean loaded = false;', '                        if (matchingTabIndex != TabModel.INVALID_TAB_INDEX) {', '                            Tab tab = tabModel.getTabAt(matchingTabIndex);', '                            if (tab.getUrl().getSpec().equals(url)', '                                    || tab.getUrl().getSpec().equals(IntentUtils.safeGetStringExtra(', '                                            intent, TabOpenType.REUSE_TAB_ORIGINAL_URL_STRING))) {', '                                tabModel.setIndex(matchingTabIndex, TabSelectionType.FROM_USER);', '                                tab.loadUrl(loadUrlParams);', '                                loaded = true;', '                            }', '                        }', '                        if (!loaded) {', '                            launchIntent(loadUrlParams, externalAppId, false, intent);', '                        }', '                    }', '                    break;', '                case TabOpenType.OPEN_NEW_TAB:', '                    if (fromLauncherShortcut) {', '                        recordLauncherShortcutAction(false);', '                        reportNewTabShortcutUsed(false);', '                    }', '', '                    launchIntent(loadUrlParams, externalAppId, true, intent);', '                    break;', '                case TabOpenType.OPEN_NEW_INCOGNITO_TAB:', '                    if (!TextUtils.equals(externalAppId, getPackageName())) {', '                        assert false : ""Only Chrome is allowed to open incognito tabs"";', '                        Log.e(TAG, ""Only Chrome is allowed to open incognito tabs"");', '                        return;', '                    }', '', '                    if (!IncognitoUtils.isIncognitoModeEnabled()) {', '                        // The incognito launcher shortcut is manipulated in #onDeferredStartup(),', ""                        // so it's possible for a user to invoke the shortcut before it's disabled."", '                        // Quick actions search widget is installed on the home screen and may', '                        // need to be updated before the incognito button is removed.', '                        // Opening an incognito tab while incognito mode is disabled from somewhere', '                        // besides the launcher shortcut of from quick action search widget is an', '                        // error.', '                        if (fromAppWidget || fromLauncherShortcut) {', '                            // We are using the message introduced for quick action search widget', '                            // for both the widget and the launcher shortcut here.', '                            Toast.makeText(ChromeTabbedActivity.this,', '                                         R.string.quick_action_search_widget_message_no_incognito,', '                                         Toast.LENGTH_LONG)', '                                    .show();', '                        } else {', '                            assert false : ""Tried to open incognito tab while incognito disabled"";', '                            Log.e(TAG, ""Tried to open incognito tab while incognito disabled"");', '                        }', '', '                        return;', '                    }', '', '                    if (url == null || url.equals(UrlConstants.NTP_URL)) {', '                        if (fromLauncherShortcut) {', '                            getTabCreator(true).launchUrl(', '                                    UrlConstants.NTP_URL, TabLaunchType.FROM_LAUNCHER_SHORTCUT);', '                            recordLauncherShortcutAction(true);', '                            reportNewTabShortcutUsed(true);', '                        } else if (fromAppWidget) {', '                            RecordUserAction.record(""QuickActionSearchWidget.StartIncognito"");', '                            getTabCreator(true).launchUrl(', '                                    UrlConstants.NTP_URL, TabLaunchType.FROM_APP_WIDGET);', '                        } else if (IncognitoTabLauncher.didCreateIntent(intent)) {', '                            Tab tab = getTabCreator(true).launchUrl(UrlConstants.NTP_URL,', '                                    TabLaunchType.FROM_LAUNCH_NEW_INCOGNITO_TAB);', '                            if (IncognitoTabLauncher.shouldFocusOmnibox(intent)) {', '                                // Since the Tab is created in the foreground, its View will gain', '                                // focus, and since the Tab and the URL bar are not yet in the same', ""                                // View hierarchy, setting the URL bar's focus here won't clear the"", ""                                // Tab's focus. When the Tab is added to the hierarchy, we want the"", ""                                // URL bar to retain focus, so we clear the Tab's focus here."", '                                tab.getView().clearFocus();', '                                focus = true;', '                            }', '', '                            IncognitoTabLauncher.recordUse();', '                        } else {', '                            // Used by the Account management screen to open a new incognito tab.', '                            // Account management screen collects its metrics separately.', '                            getTabCreator(true).launchUrl(UrlConstants.NTP_URL,', '                                    TabLaunchType.FROM_CHROME_UI, intent, mIntentHandlingTimeMs);', '                        }', '                    } else {', '                        @TabLaunchType', '                        Integer launchType = IntentHandler.getTabLaunchType(intent);', '                        if (launchType == null) launchType = TabLaunchType.FROM_LINK;', '                        getTabCreator(true).launchUrl(', '                                url, launchType, intent, mIntentHandlingTimeMs);', '                    }', '                    break;', '                default:', '                    assert false : ""Unknown TabOpenType: "" + tabOpenType;', '                    break;', '            }', '', '            getToolbarManager().setUrlBarFocusOnceNativeInitialized(focus,', '                    focus ? OmniboxFocusReason.LAUNCH_NEW_INCOGNITO_TAB', '                          : OmniboxFocusReason.UNFOCUS);', '', '            if (tabModel.getCount() > 0 && isInOverviewMode() && !isTablet()', '                    && !shouldShowOverviewPageOnStart()) {', '                mOverviewModeController.hideOverview(true);', '            }', '        }', '', '        @Override', '        public long getIntentHandlingTimeMs() {', '            return mIntentHandlingTimeMs;', '        }', '', '        @Override', '        public void processWebSearchIntent(String query) {', '            assert false;', '        }', '', '        @Override', '        public void processTranslateTabIntent(', '                @Nullable String targetLanguageCode, @Nullable String expectedUrl) {', '            TranslateIntentHandler.translateTab(getActivityTab(), targetLanguageCode, expectedUrl);', '        }', '', '        private boolean isFromChrome(Intent intent, String externalAppId) {', '            // To determine if the processed intent is from Chrome, check for any of the following:', '            // 1.) The authentication token that will be added to trusted intents.', '            // 2.) The app ID matches Chrome.  This value can be spoofed by other applications, but', '            //     in cases where we were not able to add the authentication token this is our only', '            //     indication the intent was from Chrome.', '            return IntentHandler.wasIntentSenderChrome(intent)', '                    || TextUtils.equals(externalAppId, getPackageName());', '        }', '    }', '', '    @Override', '    public void performPreInflationStartup() {', '        // Create JankTracker before invoking super, because the parent class will invoke', '        // createRootUiCoordinator(...), which in our case requires the JankTracker to already have', '        // been created.', '        mJankTracker = new JankTrackerImpl(this);', '', '        super.performPreInflationStartup();', '', '        // Decide whether to record startup UMA histograms. This is done  early in the main', '        // Activity.onCreate() to avoid recording navigation delays when they require user input to', '        // proceed. For example, FRE (First Run Experience) happens before the activity is created,', '        // and triggers initialization of the native library.', '        //', '        // An uninitialized native library is an indication of an application start that is followed', '        // by navigation immediately without user input.', '        if (!LibraryLoader.getInstance().isInitialized()) {', '            setTrackColdStartupMetrics(true);', '        }', '', '        supportRequestWindowFeature(Window.FEATURE_ACTION_MODE_OVERLAY);', '', '        IncognitoTabHostRegistry.getInstance().register(mIncognitoTabHost);', '', '        mStartupPaintPreviewHelperSupplier.attach(getWindowAndroid().getUnownedUserDataHost());', '    }', '', '    @Override', '    protected RootUiCoordinator createRootUiCoordinator() {', '        return new TabbedRootUiCoordinator(this, this::onOmniboxFocusChanged,', '                getShareDelegateSupplier(), getActivityTabProvider(), mTabModelProfileSupplier,', '                mBookmarkBridgeSupplier, this::getContextualSearchManager,', '                getTabModelSelectorSupplier(), mStartSurfaceSupplier,', '                mIntentMetadataOneshotSupplier, mLayoutStateProviderOneshotSupplier,', '                mStartSurfaceParentTabSupplier, getBrowserControlsManager(), getWindowAndroid(),', '                mJankTracker, getLifecycleDispatcher(), getLayoutManagerSupplier(),', '                /* menuOrKeyboardActionController= */ this, this::getActivityThemeColor,', '                getModalDialogManagerSupplier(), /* appMenuBlocker= */ this, this::supportsAppMenu,', '                this::supportsFindInPage, getTabCreatorManagerSupplier(), getFullscreenManager(),', '                getCompositorViewHolderSupplier(), getTabContentManagerSupplier(),', '                getOverviewModeBehaviorSupplier(), this::getSnackbarManager, getActivityType(),', '                this::isInOverviewMode, this::isWarmOnResume,', '                /* appMenuDelegate= */ this, /* statusBarColorProvider= */ this,', '                mEphemeralTabCoordinatorSupplier, getIntentRequestTracker(),', '                getControlContainerHeightResource(), this::getInsetObserverView,', '                this::backShouldCloseTab);', '    }', '', '    @Override', '    protected int getControlContainerLayoutId() {', '        return R.layout.control_container;', '    }', '', '    @Override', '    public int getControlContainerHeightResource() {', '        return R.dimen.control_container_height;', '    }', '', '    @Override', '    protected int getToolbarLayoutId() {', '        return isTablet() ? R.layout.toolbar_tablet : R.layout.toolbar_phone;', '    }', '', '    @Override', '    protected int getToolbarShadowResource() {', '        final boolean themeRefactorEnabled =', '                CachedFeatureFlags.isEnabled(ChromeFeatureList.THEME_REFACTOR_ANDROID);', '        return themeRefactorEnabled ? R.drawable.toolbar_hairline', '                                    : R.drawable.modern_toolbar_shadow;', '    }', '', '    @Override', '    protected int getToolbarShadowLayoutHeight() {', '        final int res = CachedFeatureFlags.isEnabled(ChromeFeatureList.THEME_REFACTOR_ANDROID)', '                ? R.dimen.toolbar_hairline_height', '                : R.dimen.toolbar_shadow_height;', '        return getResources().getDimensionPixelSize(res);', '    }', '', '    @Override', '    public void performPostInflationStartup() {', '        super.performPostInflationStartup();', '', '        FontPreloader.getInstance().onPostInflationStartupTabbedActivity();', '', '        TabModelSelector tabModelSelector = getTabModelSelector();', '        IncognitoProfileDestroyer.observeTabModelSelector(tabModelSelector);', '        IncognitoNotificationPresenceController.observeTabModelSelector(tabModelSelector);', '', '        // Critical path for startup. Create the minimum objects needed', '        // to allow a blank screen draw (without depending on any native code)', '        // and then yield ASAP.', '        if (isFinishing()) return;', '', ""        // Don't show the keyboard until user clicks in."", '        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN', '                | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);', '', '        mContentContainer = (ViewGroup) findViewById(android.R.id.content);', '        mControlContainer = (ToolbarControlContainer) findViewById(R.id.control_container);', '', '        Supplier<Boolean> dialogVisibilitySupplier = null;', '        if (TabUiFeatureUtilities.isTabGroupsAndroidEnabled(this)) {', '            dialogVisibilitySupplier = () -> {', '                assert mStartSurfaceSupplier.get() != null;', '                assert getToolbarManager().getTabGroupUi() != null;', '                // Return true if dialog from either tab switcher or tab strip is visible.', '', '                ToolbarManager toolbarManager = getToolbarManager();', '                TabGroupUi tabGroupUi = toolbarManager.getTabGroupUi();', '                boolean isDialogVisible = tabGroupUi.isTabGridDialogVisible();', '', '                Supplier<Boolean> tabSwitcherDialogVisibilitySupplier =', '                        mStartSurfaceSupplier.get().getTabGridDialogVisibilitySupplier();', '', '                if (tabSwitcherDialogVisibilitySupplier != null) {', '                    isDialogVisible = isDialogVisible || tabSwitcherDialogVisibilitySupplier.get();', '                }', '                return isDialogVisible;', '            };', '        }', '', '        mUndoBarPopupController = new UndoBarController(this, mTabModelSelector,', '                this::getSnackbarManager, mOverviewModeBehaviorSupplier, dialogVisibilitySupplier);', '', '        mInactivityTracker = new ChromeInactivityTracker(', '                ChromePreferenceKeys.TABBED_ACTIVITY_LAST_BACKGROUNDED_TIME_MS_PREF);', '', '        assert getActivityTabStartupMetricsTracker() != null;', '        if (StartupPaintPreviewHelper.isEnabled()) {', '            StartupPaintPreviewHelper paintPreviewHelper = new StartupPaintPreviewHelper(', '                    getWindowAndroid(), getOnCreateTimestampMs(), getBrowserControlsManager(),', '                    getTabModelSelector(), shouldShowOverviewPageOnStart(), () -> {', '                        return getToolbarManager() == null', '                                ? null', '                                : getToolbarManager().getProgressBarCoordinator();', '                    });', '            mStartupPaintPreviewHelperSupplier.set(paintPreviewHelper);', '            getActivityTabStartupMetricsTracker().registerPaintPreviewObserver(paintPreviewHelper);', '        }', '    }', '', '    private boolean shouldIgnoreIntent() {', '        if (mShouldIgnoreIntent == null) {', '            // We call this only once because mIntentHandler#shouldIgnoreIntent has side effects.', '            mShouldIgnoreIntent =', '                    mIntentHandler.shouldIgnoreIntent(getIntent(), /*startedActivity=*/true);', '        }', '        return mShouldIgnoreIntent;', '    }', '', '    @Override', '    protected final void dispatchOnInflationComplete() {', '        super.dispatchOnInflationComplete();', '', '        // When the feature flag {@link ChromeFeatureList.INSTANT_START} turns on phones (not', '        // tablet), a view-only start page created on Java will be shown before native is', '        // initialized. The {@link prepareToShowStartPagePreNative()} is only called in a cold', '        // start.', '        if (ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()', '                && TabUiFeatureUtilities.supportInstantStart(isTablet(), this) && !hadWarmStart()) {', '            prepareToShowStartPagePreNative();', '        }', '    }', '', '    /**', '     * Prepares to show the start page before native is initialized. For example, create', '     * an LayoutManagerChrome object, add overview mode observer and so on.', '     */', '    private void prepareToShowStartPagePreNative() {', '        assert TabUiFeatureUtilities.supportInstantStart(isTablet() && !hadWarmStart(), this);', '        try (TraceEvent e =', '                        TraceEvent.scoped(""ChromeTabbedActivity.prepareToShowStartPagePreNative"")) {', '            setupCompositorContentPreNativeForPhone();', '            getCompositorViewHolderSupplier().get().setLayoutManager(mLayoutManager);', '', '            if (shouldShowOverviewPageOnStart()) {', '                mLayoutManager.setTabModelSelector(mTabModelSelector);', '                mIsAccessibilityTabSwitcherEnabled =', '                        DeviceClassManager.enableAccessibilityLayout(this);', '                assert !mHasDeterminedOverviewStateForCurrentSession;', '                setInitialOverviewState();', '            }', '        }', '    }', '', '    @Override', '    protected TabModelOrchestrator createTabModelOrchestrator() {', '        boolean tabMergingEnabled =', '                mMultiInstanceManager != null && mMultiInstanceManager.isTabModelMergingEnabled();', '        mTabModelOrchestrator = new TabbedModeTabModelOrchestrator(tabMergingEnabled);', '        return mTabModelOrchestrator;', '    }', '', '    @Override', '    protected void createTabModels() {', '        assert mTabModelSelector == null;', '        assert mWindowId != INVALID_WINDOW_ID;', '', '        Bundle savedInstanceState = getSavedInstanceState();', '', '        // We determine the model as soon as possible so every systems get initialized coherently.', '        boolean startIncognito = savedInstanceState != null', '                && savedInstanceState.getBoolean(IS_INCOGNITO_SELECTED, false);', '', '        mNextTabPolicySupplier = new ChromeNextTabPolicySupplier(mOverviewModeBehaviorSupplier);', '', '        boolean tabModelWasCreated = mTabModelOrchestrator.createTabModels(', '                this, this, mNextTabPolicySupplier, mWindowId);', '        if (!tabModelWasCreated) {', '            finish();', '            return;', '        }', '', '        if (mMultiInstanceManager != null) {', '            int assignedIndex = TabWindowManagerSingleton.getInstance().getIndexForWindow(this);', '            // The given index and the one computed by TabWindowManager should be one and the same.', '            assert !MultiWindowUtils.isMultiInstanceApi31Enabled() || assignedIndex == mWindowId;', '            mMultiInstanceManager.initialize(assignedIndex, getTaskId());', '        }', '', '        mTabModelSelector = mTabModelOrchestrator.getTabModelSelector();', '        mTabModelSelector.addObserver(new TabModelSelectorObserver() {', '            @Override', '            public void onTabStateInitialized() {', '                if (!mCreatedTabOnStartup) return;', '', '                TabModel model = mTabModelSelector.getModel(false);', '                TasksUma.recordTasksUma(model);', '            }', '        });', '', '        mTabModelSelectorTabObserver = new TabModelSelectorTabObserver(mTabModelSelector) {', '            @Override', '            public void onDidFinishNavigation(Tab tab, NavigationHandle navigation) {', '                if (!navigation.hasCommitted() || !navigation.isInPrimaryMainFrame()) {', '                    return;', '                }', '                DataReductionPromoInfoBar.maybeLaunchPromoInfoBar(ChromeTabbedActivity.this,', '                        tab.getWebContents(), navigation.getUrl(), tab.isShowingErrorPage(),', '                        navigation.isFragmentNavigation(), navigation.httpStatusCode());', '                if (SyncErrorPromptUtils.isMessageUiEnabled()) {', '                    SyncErrorMessage.maybeShowMessageUi(', '                            getWindowAndroid(), ChromeTabbedActivity.this);', '                } else {', '                    SyncErrorInfoBar.maybeLaunchSyncErrorInfoBar(tab.getWebContents());', '                }', '                SendTabToSelfAndroidBridge.updateActiveWebContents(tab.getWebContents());', '            }', '        };', '        mAppIndexingUtil = new AppIndexingUtil(mTabModelSelector);', '', '        if (startIncognito) mTabModelSelector.selectModel(true);', '    }', '', '    @Override', '    protected LaunchCauseMetrics createLaunchCauseMetrics() {', '        return new TabbedActivityLaunchCauseMetrics(this);', '    }', '', '    @Override', '    public AppMenuPropertiesDelegate createAppMenuPropertiesDelegate() {', '        return new TabbedAppMenuPropertiesDelegate(this, getActivityTabProvider(),', '                getMultiWindowModeStateDispatcher(), getTabModelSelector(), getToolbarManager(),', '                getWindow().getDecorView(), this, mOverviewModeBehaviorSupplier,', '                ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()', '                        ? mStartSurfaceSupplier', '                        : null,', '                mBookmarkBridgeSupplier,', '                ()', '                        -> getTabCreator(/*incognito=*/false)', '                                   .launchUrl(NewTabPageUtils.encodeNtpUrl(', '                                                      NewTabPageLaunchOrigin.WEB_FEED),', '                                           TabLaunchType.FROM_CHROME_UI),', '                getModalDialogManager(), getSnackbarManager());', '    }', '', '    private TabDelegateFactory getTabDelegateFactory() {', '        if (mTabDelegateFactory == null) {', '            mTabDelegateFactory = new TabbedModeTabDelegateFactory(this,', '                    getAppBrowserControlsVisibilityDelegate(), getShareDelegateSupplier(),', '                    mEphemeralTabCoordinatorSupplier,', '                    ((TabbedRootUiCoordinator) mRootUiCoordinator)::onContextMenuCopyLink,', '                    mRootUiCoordinator.getBottomSheetController(),', '                    /* ChromeActivityNativeDelegate */ this, /* isCustomTab= */ false,', '                    getBrowserControlsManager(), getFullscreenManager(),', '                    /* TabCreatorManager */ this, getTabModelSelectorSupplier(),', '                    getCompositorViewHolderSupplier(), getModalDialogManagerSupplier(),', '                    this::getSnackbarManager, getBrowserControlsManager(), getActivityTabProvider(),', '                    getLifecycleDispatcher(), getWindowAndroid(), this::getLastUserInteractionTime,', '                    this::hadWarmStart, mJankTracker, getToolbarManager()::getToolbar);', '        }', '        return mTabDelegateFactory;', '    }', '', '    @Override', '    protected Pair<ChromeTabCreator, ChromeTabCreator> createTabCreators() {', '        ChromeTabCreator.OverviewNTPCreator overviewNTPCreator = null;', '', '        if (ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '            overviewNTPCreator = new ChromeTabCreator.OverviewNTPCreator() {', '                @Override', '                public boolean handleCreateNTPIfNeeded(boolean isNTP, boolean incognito,', '                        Tab parentTab, @NewTabPageLaunchOrigin int launchOrigin) {', '                    boolean shouldShowStart =', '                            showStartSurfaceHomeForNTP(isNTP, incognito, parentTab, launchOrigin);', '                    if (shouldShowStart) {', '                        mStartSurfaceParentTabSupplier.set(parentTab);', '                    }', '                    return shouldShowStart;', '                }', '', '                @Override', '                public void preTabInitialization(Tab tab, String url) {', '                    StartSurfaceConfiguration.maySetUserDataForEmptyTab(tab, url);', '                }', '            };', '        }', '        return Pair.create(', '                new ChromeTabCreator(this, getWindowAndroid(), getStartupTabPreloader(),', '                        this::getTabDelegateFactory, false, overviewNTPCreator,', '                        AsyncTabParamsManagerSingleton.getInstance(), getTabModelSelectorSupplier(),', '                        getCompositorViewHolderSupplier()),', '                new ChromeTabCreator(this, getWindowAndroid(), getStartupTabPreloader(),', '                        this::getTabDelegateFactory, true, overviewNTPCreator,', '                        AsyncTabParamsManagerSingleton.getInstance(), getTabModelSelectorSupplier(),', '                        getCompositorViewHolderSupplier()));', '    }', '', '    @Override', '    protected void initDeferredStartupForActivity() {', '        super.initDeferredStartupForActivity();', '        DeferredStartupHandler.getInstance().addDeferredTask(() -> {', '            ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);', '            RecordHistogram.recordSparseHistogram(', '                    ""MemoryAndroid.DeviceMemoryClass"", am.getMemoryClass());', '', '            LauncherShortcutActivity.updateIncognitoShortcut(ChromeTabbedActivity.this);', '', '            ChromeSurveyController.initialize(mTabModelSelector, getLifecycleDispatcher(),', '                    ChromeTabbedActivity.this, MessageDispatcherProvider.from(getWindowAndroid()));', '', '            if (mStartSurfaceSupplier.get() != null) {', '                mStartSurfaceSupplier.get().onOverviewShownAtLaunch(', '                        mOverviewShownOnStart, getOnCreateTimestampMs());', '            }', '        });', '    }', '', '    @Override', '    protected void recordIntentToCreationTime(long timeMs) {', '        super.recordIntentToCreationTime(timeMs);', '        RecordHistogram.recordCustomTimesHistogram(""MobileStartup.IntentToCreationTime.TabbedMode"",', '                timeMs, 1, DateUtils.SECOND_IN_MILLIS * 30, 50);', '    }', '', '    @Override', '    protected boolean isStartedUpCorrectly(Intent intent) {', '        mWindowId = 0;', '        Bundle savedInstanceState = getSavedInstanceState();', '        int windowId = getExtraWindowIdFromIntent(intent);', '        if (savedInstanceState != null && savedInstanceState.containsKey(WINDOW_INDEX)) {', '            // Activity is recreated after destruction. |windowId| must not be valid in this case.', '            assert windowId == INVALID_WINDOW_ID;', '            mWindowId = savedInstanceState.getInt(WINDOW_INDEX, 0);', '        } else if (mMultiInstanceManager != null) {', ""            // |allocInstanceId| doesn't do any disk I/O that would add a long-running task"", '            // to pre-inflation startup.', '            boolean preferNew = getExtraPreferNewFromIntent(intent);', '            mWindowId = mMultiInstanceManager.allocInstanceId(windowId, getTaskId(), preferNew);', '        }', '        if (mWindowId == INVALID_WINDOW_ID) {', '            Log.i(TAG, ""Window ID not allocated. Finishing the activity"");', '            Toast.makeText(this, R.string.max_number_of_windows, Toast.LENGTH_LONG).show();', '            return false;', '        }', '', '        if (mMultiInstanceManager != null', '                && !mMultiInstanceManager.isStartedUpCorrectly(getTaskId())) {', '            return false;', '        }', '', '        return super.isStartedUpCorrectly(intent);', '    }', '', '    private static int getExtraWindowIdFromIntent(Intent intent) {', '        int windowId = IntentUtils.safeGetIntExtra(', '                intent, IntentHandler.EXTRA_WINDOW_ID, INVALID_WINDOW_ID);', '        return IntentUtils.isTrustedIntentFromSelf(intent) ? windowId : INVALID_WINDOW_ID;', '    }', '', '    private static boolean getExtraPreferNewFromIntent(Intent intent) {', '        return IntentUtils.safeGetBooleanExtra(intent, IntentHandler.EXTRA_PREFER_NEW, false);', '    }', '', '    @Override', '    public void terminateIncognitoSession() {', '        getTabModelSelector().getModel(true).closeAllTabs();', '    }', '', '    @Override', '    public boolean onMenuOrKeyboardAction(final int id, boolean fromMenu) {', '        final Tab currentTab = getActivityTab();', '        boolean currentTabIsNtp = isTabNtp(currentTab);', '        if (id == R.id.new_tab_menu_id) {', '            getTabModelSelector().getModel(false).commitAllTabClosures();', '            RecordUserAction.record(""MobileMenuNewTab"");', '            RecordUserAction.record(""MobileNewTabOpened"");', '            ReturnToChromeExperimentsUtil.onNewTabOpened();', '            reportNewTabShortcutUsed(false);', '            if (fromMenu) RecordUserAction.record(""MobileMenuNewTab.AppMenu"");', '', '            getTabCreator(false).launchNTP();', '', '            mLocaleManager.showSearchEnginePromoIfNeeded(this, null);', '        } else if (id == R.id.new_incognito_tab_menu_id) {', '            if (IncognitoUtils.isIncognitoModeEnabled()) {', '                getTabModelSelector().getModel(false).commitAllTabClosures();', '                // This action must be recorded before opening the incognito tab since UMA actions', '                // are dropped when an incognito tab is open.', '                RecordUserAction.record(""MobileMenuNewIncognitoTab"");', '                RecordUserAction.record(""MobileNewTabOpened"");', '                ReturnToChromeExperimentsUtil.onNewTabOpened();', '                reportNewTabShortcutUsed(true);', '                if (fromMenu) RecordUserAction.record(""MobileMenuNewIncognitoTab.AppMenu"");', '                getTabCreator(true).launchNTP();', '            }', '        } else if (id == R.id.all_bookmarks_menu_id) {', ""            // Note that 'currentTab' could be null in overview mode when start surface is"", '            // enabled.', '            getCompositorViewHolderSupplier().get().hideKeyboard(() -> {', '                BookmarkUtils.showBookmarkManager(', '                        ChromeTabbedActivity.this, getCurrentTabModel().isIncognito());', '            });', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_BOOKMARKS_MANAGER);', '            }', '', '            @BrowserProfileType', '            int type = getCurrentTabModel().isIncognito() ? BrowserProfileType.INCOGNITO', '                                                          : BrowserProfileType.REGULAR;', '            RecordHistogram.recordEnumeratedHistogram(', '                    ""Bookmarks.OpenBookmarkManager.PerProfileType"", type,', '                    BrowserProfileType.MAX_VALUE + 1);', '', '            RecordUserAction.record(""MobileMenuAllBookmarks"");', '        } else if (id == R.id.recent_tabs_menu_id) {', '            LoadUrlParams params =', '                    new LoadUrlParams(UrlConstants.RECENT_TABS_URL, PageTransition.AUTO_BOOKMARK);', '            boolean isInOverviewMode = isInOverviewMode();', '            if (isInOverviewMode && !isTablet()', '                    && ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '                // When tapping the ""Recent tabs"" menu item from the overview page (Start surface or', '                // GTS), we will create the tab with the launch type FROM_START_SURFACE. Thus, if', '                // the back button is tapped on this ""Recent tabs"" page, it can go back to the', '                // overview page.', '                ReturnToChromeExperimentsUtil.handleLoadUrlFromStartSurface(', '                        params, getCurrentTabModel().isIncognito(), null);', '            } else if (currentTab != null) {', '                currentTab.loadUrl(params);', '            } else {', '                getTabCreator(getCurrentTabModel().isIncognito())', '                        .createNewTab(params, TabLaunchType.FROM_CHROME_UI, null);', '            }', '            if (isInOverviewMode) {', '                mOverviewModeController.hideOverview(true);', '            }', '', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_RECENT_TABS_MANAGER);', '            }', '            RecordUserAction.record(""MobileMenuRecentTabs"");', '            ReturnToChromeExperimentsUtil.onRecentTabsOpened();', '        } else if (id == R.id.close_tab) {', '            getCurrentTabModel().closeTab(currentTab, true, false, true);', '            RecordUserAction.record(""MobileTabClosed"");', '        } else if (id == R.id.close_all_tabs_menu_id) {', '            // Close both incognito and normal tabs', '            getTabModelSelector().closeAllTabs();', '            RecordUserAction.record(""MobileMenuCloseAllTabs"");', '        } else if (id == R.id.close_all_incognito_tabs_menu_id) {', '            // Close only incognito tabs', '            getTabModelSelector().getModel(true).closeAllTabs();', '            RecordUserAction.record(""MobileMenuCloseAllIncognitoTabs"");', '        } else if (id == R.id.focus_url_bar) {', '            boolean isUrlBarVisible = !mOverviewModeController.overviewVisible()', '                    && (!isTablet() || getCurrentTabModel().getCount() != 0);', '            if (isUrlBarVisible) {', '                getToolbarManager().setUrlBarFocus(', '                        true, OmniboxFocusReason.MENU_OR_KEYBOARD_ACTION);', '            }', '        } else if (id == R.id.downloads_menu_id) {', '            OTRProfileID otrProfileID = null;', '            if (currentTab != null && currentTab.getWebContents() != null) {', '                Profile profile = Profile.fromWebContents(currentTab.getWebContents());', '                otrProfileID = profile != null ? profile.getOTRProfileID() : null;', '            }', '            DownloadUtils.showDownloadManager(', '                    this, currentTab, otrProfileID, DownloadOpenSource.MENU);', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_DOWNLOADS_MANAGER);', '            }', '            RecordUserAction.record(""MobileMenuDownloadManager"");', '        } else if (id == R.id.open_recently_closed_tab) {', '            TabModel currentModel = mTabModelSelector.getCurrentModel();', '            if (!currentModel.isIncognito()) currentModel.openMostRecentlyClosedTab();', '            RecordUserAction.record(""MobileTabClosedUndoShortCut"");', '        } else if (id == R.id.enter_vr_id) {', '            VrModuleProvider.getDelegate().enterVrIfNecessary();', '        } else {', '            return super.onMenuOrKeyboardAction(id, fromMenu);', '        }', '        return true;', '    }', '', '    private boolean isTabNtp(Tab tab) {', '        return tab != null && UrlUtilities.isNTPUrl(tab.getUrl());', '    }', '', '    private boolean isTabRegularNtp(Tab tab) {', '        return isTabNtp(tab) && !tab.isIncognito();', '    }', '', '    private void onOmniboxFocusChanged(boolean hasFocus) {', '        mTabModalHandler.onOmniboxFocusChanged(hasFocus);', '    }', '', '    private void recordLauncherShortcutAction(boolean isIncognito) {', '        if (isIncognito) {', '            RecordUserAction.record(""Android.LauncherShortcut.NewIncognitoTab"");', '        } else {', '            RecordUserAction.record(""Android.LauncherShortcut.NewTab"");', '        }', '    }', '', '    @Override', '    public boolean handleBackPressed() {', '        if (!mUIWithNativeInitialized) return false;', '', '        if (getManualFillingComponent().handleBackPress()) return true;', '', '        if (exitFullscreenIfShowing()) {', '            return true;', '        }', '', '        // TODO(1091411): Find a better mechanism for back-press handling for features.', '        if (mRootUiCoordinator.getBottomSheetController().handleBackPress()) return true;', '', '        if (mTabModalHandler.handleBackPress()) return true;', '', '        final Tab currentTab = getActivityTab();', '        if (currentTab == null) {', '            moveTaskToBack(true);', '            return true;', '        }', '', '        // If we are in the tab switcher mode (not in the Start surface homepage) and not a tablet,', '        // then leave tab switcher mode on back.', '        if (mOverviewModeController.overviewVisible() && !isTablet()', '                && (mStartSurfaceSupplier.get() == null', '                        || mStartSurfaceSupplier.get().getController().getStartSurfaceState()', '                                == StartSurfaceState.SHOWN_TABSWITCHER)) {', '            mOverviewModeController.hideOverview(true);', '            return true;', '        }', '', '        final WebContents webContents = currentTab.getWebContents();', '        if (webContents != null) {', '            RenderFrameHost focusedFrame = webContents.getFocusedFrame();', '            if (focusedFrame != null && focusedFrame.signalCloseWatcherIfActive()) return true;', '        }', '', '        if (getToolbarManager().back()) return true;', '', '        // If the current tab url is HELP_URL, then the back button should close the tab to', '        // get back to the previous state. The reason for startsWith check is that the', '        // actual redirected URL is a different system language based help url.', '        final @TabLaunchType int type = currentTab.getLaunchType();', '        final boolean helpUrl = currentTab.getUrl().getSpec().startsWith(HELP_URL_PREFIX);', '        if (type == TabLaunchType.FROM_CHROME_UI && helpUrl) {', '            getCurrentTabModel().closeTab(currentTab);', '            return true;', '        }', '', ""        // If we aren't in the overview mode, we handle the Tab with launchType"", '        // TabLaunchType.FROM_START_SURFACE or has ""OpenedFromStart"" property.', '        if (!mOverviewModeController.overviewVisible()', '                && (type == TabLaunchType.FROM_START_SURFACE', '                        || StartSurfaceUserData.isOpenedFromStart(currentTab))) {', '            if (StartSurfaceUserData.getKeepTab(currentTab)', '                    || StartSurfaceUserData.isOpenedFromStart(currentTab)) {', '                // If the current tab is created from the start surface with the keepTab property,']}, {'a': ['                // shows the Start surface non-incognito homepage to prevent a loop between the', '                // current tab and previous overview mode. Once in the Start surface, it will close', '                // Chrome if back button is tapped again.'], 'b': ['                // shows the Start surface Homepage to prevent a loop between the current tab and', '                // previous overview mode. Once in the Start surface, it will close Chrome if back', '                // button is tapped again.']}, {'ab': ['                if (currentTab.isIncognito()) {', '                    if (!currentTab.isClosing()) {', '                        getCurrentTabModel().closeTab(currentTab);', '                    }']}, {'a': ['                    mTabModelSelector.selectModel(/*incognito=*/false);'], 'b': ['                    mTabModelSelector.selectModel(false);']}, {'ab': ['                }', '                showOverview(StartSurfaceState.SHOWING_HOMEPAGE);', '            } else {', '                // Otherwise, clicking the back button should close the tab and go back to the', '                // previous overview mode.', '                showOverview(StartSurfaceState.SHOWING_PREVIOUS);', '                if (!currentTab.isClosing()) {', '                    getCurrentTabModel().closeTab(currentTab);', '                }', '            }', '            return true;', '        }', '', '        final boolean shouldCloseTab = backShouldCloseTab(currentTab);', '', '        // Minimize the app if either:', '        // - we decided not to close the tab', '        // - we decided to close the tab, but it was opened by an external app, so we will go', '        //   exit Chrome on top of closing the tab', '        final boolean minimizeApp =', '                !shouldCloseTab || TabAssociatedApp.isOpenedFromExternalApp(currentTab);', '        if (minimizeApp) {', '            if (shouldCloseTab) {', '                sendToBackground(currentTab);', '                return true;', '            } else {', '                sendToBackground(null);', '                return true;', '            }', '        } else if (shouldCloseTab) {', '            currentTab.getWebContents().dispatchBeforeUnload(false);', '            return true;', '        }', '', '        assert false : ""The back button should have already been handled by this point"";', '        return false;', '    }', '', '    /**', '     * [true]: Reached the bottom of the back stack on a tab the user did not explicitly', '     * create (i.e. it was created by an external app or opening a link in background, etc).', '     * [false]: Reached the bottom of the back stack on a tab that the user explicitly', '     * created (e.g. selecting ""new tab"" from menu).', '     *', '     * @return Whether pressing the back button on the provided Tab should close the Tab.', '     */', '    @Override', '    public boolean backShouldCloseTab(Tab tab) {', '        if (!tab.isInitialized()) {', '            return false;', '        }', '        @TabLaunchType', '        int type = tab.getLaunchType();', '', '        return type == TabLaunchType.FROM_LINK || type == TabLaunchType.FROM_EXTERNAL_APP', '                || type == TabLaunchType.FROM_LONGPRESS_FOREGROUND', '                || type == TabLaunchType.FROM_LONGPRESS_BACKGROUND', '                || (type == TabLaunchType.FROM_RESTORE', '                        && CriticalPersistedTabData.from(tab).getParentId() != Tab.INVALID_TAB_ID);', '    }', '', '    /**', '     * Sends this Activity to the background.', '     *', '     * @param tabToClose Tab that will be closed once the app is not visible.', '     */', '    private void sendToBackground(@Nullable final Tab tabToClose) {', '        Log.i(TAG, ""sendToBackground(): "" + tabToClose);', '        moveTaskToBack(true);', '        if (tabToClose != null) {', ""            // In the case of closing a tab upon minimization, don't allow the close action to"", ""            // happen until after our app is minimized to make sure we don't get a brief glimpse of"", '            // the newly active tab before we exit Chrome.', '            //', ""            // If the runnable doesn't run before the Activity dies, Chrome won't crash but the tab"", ""            // won't be closed (crbug.com/587565)."", '            mHandler.postDelayed(() -> {', '                boolean hasNextTab =', '                        getCurrentTabModel().getNextTabIfClosed(tabToClose.getId()) != null;', '                getCurrentTabModel().closeTab(tabToClose, false, true, false);', '', '                // If there is no next tab to open, enter overview mode.', '                if (!hasNextTab) showOverview(StartSurfaceState.SHOWING_START);', '            }, CLOSE_TAB_ON_MINIMIZE_DELAY_MS);', '        }', '    }', '', '    @Override', '    public boolean moveTaskToBack(boolean nonRoot) {', '        try {', '            return super.moveTaskToBack(nonRoot);', '        } catch (NullPointerException e) {', '            // Work around framework bug described in https://crbug.com/817567.', '            finish();', '            return true;', '        }', '    }', '', '    /**', '     * Launch a URL from an intent.', '     *', '     * @param url           The url from the intent.', '     * @param referer       Optional referer URL to be used.', '     * @param headers       Optional headers to be sent when opening the URL.', '     * @param externalAppId External app id.', '     * @param forceNewTab   Whether to force the URL to be launched in a new tab or to fall', '     *                      back to the default behavior for making that determination.', '     * @param isRendererInitiated Whether the intent is originally from browser renderer process.', '     * @param initiatorOrigin Origin that initiates the intent.', '     * @param intent        The original intent.', '     */', '    private Tab launchIntent(', '            LoadUrlParams loadUrlParams, String externalAppId, boolean forceNewTab, Intent intent) {', '        if (mUIWithNativeInitialized && !UrlUtilities.isNTPUrl(loadUrlParams.getUrl())) {', '            mOverviewModeController.hideOverview(false);', '            getToolbarManager().finishAnimations();', '        }', '        if (IntentHandler.wasIntentSenderChrome(intent)) {', '            // If the intent was launched by chrome, open the new tab in the appropriate model.', '            boolean isIncognito = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_OPEN_NEW_INCOGNITO_TAB, false);', '            @TabLaunchType', '            Integer launchType = IntentHandler.getTabLaunchType(intent);', '            if (launchType == null) {', '                if (IntentUtils.safeGetBooleanExtra(', '                            intent, IntentHandler.EXTRA_INVOKED_FROM_SHORTCUT, false)) {', '                    launchType = TabLaunchType.FROM_LAUNCHER_SHORTCUT;', '                } else if (IntentUtils.safeGetBooleanExtra(', '                                   intent, IntentHandler.EXTRA_INVOKED_FROM_APP_WIDGET, false)) {', '                    launchType = TabLaunchType.FROM_APP_WIDGET;', '                } else if (IncognitoTabLauncher.didCreateIntent(intent)) {', '                    launchType = TabLaunchType.FROM_LAUNCH_NEW_INCOGNITO_TAB;', '                } else {', '                    // Using FROM_LINK ensures the tab is parented to the current tab, which allows', '                    // the back button to close these tabs and restore selection to the previous', '                    // tab.', '                    launchType = TabLaunchType.FROM_LINK;', '                }', '            }', '            return getTabCreator(isIncognito).createNewTab(loadUrlParams, launchType, null, intent);', '        }', '', '        // Check if the tab is being created from a Reader Mode navigation.', '        if (ReaderModeManager.isEnabled() && ReaderModeManager.isReaderModeCreatedIntent(intent)) {', '            Bundle extras = intent.getExtras();', '            int readerParentId = IntentUtils.safeGetInt(', '                    extras, ReaderModeManager.EXTRA_READER_MODE_PARENT, Tab.INVALID_TAB_ID);', '            extras.remove(ReaderModeManager.EXTRA_READER_MODE_PARENT);', '            // Set the parent tab to the tab that Reader Mode started from.', '            if (readerParentId != Tab.INVALID_TAB_ID && mTabModelSelector != null) {', '                return getCurrentTabCreator().createNewTab(', '                        new LoadUrlParams(loadUrlParams.getUrl(), PageTransition.LINK),', '                        TabLaunchType.FROM_LINK, mTabModelSelector.getTabById(readerParentId));', '            }', '        }', '', '        return getTabCreator(false).launchUrlFromExternalApp(', '                loadUrlParams, externalAppId, forceNewTab, intent);', '    }', '', '    private void showOverview(@StartSurfaceState int state) {', '        showOverview(state, NewTabPageLaunchOrigin.UNKNOWN);', '    }', '', '    // TODO(crbug.com/1115757): After crrev.com/c/2315823, Overview state and Startsurface state are', '    // two different things, we actual can split this into two methods: showOverview() and', ""    // showStartSurface(state). Let's do some auditing and clean up before perform the actual split."", '    private void showOverview(', '            @StartSurfaceState int state, @NewTabPageLaunchOrigin int launchOrigin) {', '        assert (state == StartSurfaceState.SHOWING_TABSWITCHER', '                || state == StartSurfaceState.SHOWING_HOMEPAGE', '                || state == StartSurfaceState.SHOWING_PREVIOUS', '                || state == StartSurfaceState.SHOWING_START);', '        if (mIsAccessibilityTabSwitcherEnabled != null && mIsAccessibilityTabSwitcherEnabled', '                && mOverviewModeController != null) {', '            // TODO(1200727): This is a temporary fix that should be removed once grid tab switcher', '            //                is completely launched. The ""start surface"" is now created regardless', '            //                of the state of accessibility, so we check that mode first and try', '            //                showing the overview list before going to the start surface.', '            mOverviewModeController.showOverview(false);', '        } else if (mStartSurfaceSupplier.get() != null) {', '            if (ReturnToChromeExperimentsUtil.shouldHideStartSurfaceWithAccessibilityOn(this)', '                    || !HomepageManager.isHomepageEnabled()) {', '                state = StartSurfaceState.SHOWING_TABSWITCHER;', '            }', '            mStartSurfaceSupplier.get().getController().setOverviewState(state, launchOrigin);', '        }', '', '        if (mOverviewModeController == null) return;', '', '        if (mOverviewModeController.overviewVisible()) {', '            if (didFinishNativeInitialization()) {', '                getCompositorViewHolderSupplier().get().hideKeyboard(() -> {});', '            }', '            return;', '        }', '', '        Tab currentTab = getActivityTab();', ""        // If we don't have a current tab, show the overview mode."", '        if (currentTab == null) {', '            mOverviewModeController.showOverview(false);', '        } else {', '            getCompositorViewHolderSupplier().get().hideKeyboard(', '                    () -> mOverviewModeController.showOverview(true));', '            updateAccessibilityState(false);', '            TasksUma.recordTabLaunchType(getCurrentTabModel());', '        }', '    }', '', '    private void hideOverview() {', '        assert (mOverviewModeController.overviewVisible());', '        if (getCurrentTabModel().getCount() != 0) {', ""            // Don't hide overview if current tab stack is empty()"", '            mOverviewModeController.hideOverview(true);', '            updateAccessibilityState(true);', '        }', '    }', '', '    /**', '     * @return Whether opening a new tab is handled by the Start surface. It may show the Start', '     * surface, or open a new tab with the omnibox get focused, depending on the value of', '     * {@link StartSurfaceConfiguration.OMNIBOX_FOCUSED_ON_NEW_TAB}.', '     */', '    private boolean showStartSurfaceHomeForNTP(boolean isNTP, boolean incognito, Tab parentTab,', '            @NewTabPageLaunchOrigin int launchOrigin) {', '        if (!isNTP', '                || !ReturnToChromeExperimentsUtil.shouldShowStartSurfaceHomeAsNTP(', '                        this, incognito, isTablet())) {', '            return false;', '        }', '', '        getTabModelSelector().selectModel(incognito);', '        if (StartSurfaceConfiguration.OMNIBOX_FOCUSED_ON_NEW_TAB.getValue()', '                && launchOrigin != NewTabPageLaunchOrigin.WEB_FEED) {', '            Runnable emptyTabCloseCallback = isInOverviewMode() ? () -> {', '                showOverview(StartSurfaceState.SHOWING_PREVIOUS, launchOrigin);', '            } : null;', '            ReturnToChromeExperimentsUtil.handleLoadUrlFromStartSurfaceAsNewTab(null,', '                    PageTransition.AUTO_TOPLEVEL, incognito, parentTab, getCurrentTabModel(),', '                    emptyTabCloseCallback);', '        } else if (TabUiFeatureUtilities.supportInstantStart(isTablet(), this)', '                || (getTabModelSelector().isTabStateInitialized() && isLayoutManagerCreated())) {', '            showOverview(StartSurfaceState.SHOWING_HOMEPAGE, launchOrigin);', '        }', '        return true;', '    }', '', '    private void updateAccessibilityState(boolean enabled) {', '        Tab currentTab = getActivityTab();', '        WebContents webContents = currentTab != null ? currentTab.getWebContents() : null;', '        if (webContents != null) {', '            WebContentsAccessibility.fromWebContents(webContents).setState(enabled);', '        }', '    }', '', '    @Override', '    public void onSaveInstanceState(Bundle outState) {', '        super.onSaveInstanceState(outState);', '        CipherFactory.getInstance().saveToBundle(outState);', '        outState.putInt(', '                WINDOW_INDEX, TabWindowManagerSingleton.getInstance().getIndexForWindow(this));', '        Boolean is_incognito = getCurrentTabModel().isIncognito();', '        outState.putBoolean(IS_INCOGNITO_SELECTED, is_incognito);', ""        // If it's Incognito and native is initialized and profile exists, serialize duration"", '        // service state.', '        if (is_incognito && ProfileManager.isInitialized()) {', '            AndroidSessionDurationsServiceState.serializeFromNative(', '                    outState, getCurrentTabModel().getProfile());', '        }', '    }', '', '    @Override', '    public void onDestroyInternal() {', '        if (mCallbackController != null) {', '            mCallbackController.destroy();', '            mCallbackController = null;', '        }', '', '        if (mTabModelSelectorTabObserver != null) {', '            mTabModelSelectorTabObserver.destroy();', '            mTabModelSelectorTabObserver = null;', '        }', '', '        if (mTabModelObserver != null) mTabModelObserver.destroy();', '', '        if (mUndoBarPopupController != null) {', '            mUndoBarPopupController.destroy();', '            mUndoBarPopupController = null;', '        }', '', '        if (mAppIndexingUtil != null) {', '            mAppIndexingUtil.destroy();', '            mAppIndexingUtil = null;', '        }', '', '        if (mStartSurfaceSupplier.get() != null) {', '            mStartSurfaceSupplier.get().destroy();', '        }', '', '        if (mStartupPaintPreviewHelperSupplier != null) {', '            mStartupPaintPreviewHelperSupplier.destroy();', '        }', '', '        if (mJankTracker != null) {', '            mJankTracker.destroy();', '            mJankTracker = null;', '        }', '', '        IncognitoTabHostRegistry.getInstance().unregister(mIncognitoTabHost);', '', '        TabObscuringHandler tabObscuringHandler = getTabObscuringHandler();', '        if (tabObscuringHandler != null) {', '            getTabObscuringHandler().removeObserver(mCompositorViewHolder);', '            getTabObscuringHandler().removeObserver(mOverviewListLayout);', '        }', '', '        if (isTablet()) ChromeAccessibilityUtil.get().removeObserver(mCompositorViewHolder);', '        ChromeAccessibilityUtil.get().removeObserver(this);', '        ChromeAccessibilityUtil.get().removeObserver(mLayoutManager);', '', '        if (mTabDelegateFactory != null) mTabDelegateFactory.destroy();', '', '        mAppLaunchDrawBlocker.destroy();', '', '        super.onDestroyInternal();', '    }', '', '    @Override', '    protected void destroyTabModels() {', '        if (mTabModelOrchestrator != null) {', '            mTabModelOrchestrator.destroy();', '        }', '    }', '', '    @Override', '    public void onTrimMemory(int level) {', '        super.onTrimMemory(level);', '        if (ChromeApplicationImpl.isSevereMemorySignal(level)) {', '            NativePageAssassin.getInstance().freezeAllHiddenPages();', '        }', '    }', '', '    @Override', '    public boolean dispatchKeyEvent(KeyEvent event) {', '        Boolean result = KeyboardShortcuts.dispatchKeyEvent(event, mUIWithNativeInitialized,', '                getFullscreenManager(), /* menuOrKeyboardActionController= */ this);', '        return result != null ? result : super.dispatchKeyEvent(event);', '    }', '', '    @Override', '    public boolean onKeyDown(int keyCode, KeyEvent event) {', '        if (!mUIWithNativeInitialized) {', '            return super.onKeyDown(keyCode, event);', '        }', '        // Detecting a long press of the back button via onLongPress is broken in Android N.', '        // To work around this, use a postDelayed, which is supported in all versions.', '        if (keyCode == KeyEvent.KEYCODE_BACK && !isTablet()', '                && !getFullscreenManager().getPersistentFullscreenMode()) {', '            if (mShowHistoryRunnable == null) mShowHistoryRunnable = this::showFullHistorySheet;', '            mHandler.postDelayed(mShowHistoryRunnable, ViewConfiguration.getLongPressTimeout());', '            return super.onKeyDown(keyCode, event);', '        }', '        boolean isCurrentTabVisible = !mOverviewModeController.overviewVisible()', '                && (!isTablet() || getCurrentTabModel().getCount() != 0);', '        return KeyboardShortcuts.onKeyDown(event, isCurrentTabVisible, true, getTabModelSelector(),', '                       /* menuOrKeyboardActionController= */ this, getToolbarManager())', '                || super.onKeyDown(keyCode, event);', '    }', '', '    private void showFullHistorySheet() {', '        ((TabbedRootUiCoordinator) mRootUiCoordinator).showFullHistorySheet();', '    }', '', '    @Override', '    public boolean onKeyUp(int keyCode, KeyEvent event) {', '        if (keyCode == KeyEvent.KEYCODE_BACK && !isTablet()) {', '            mHandler.removeCallbacks(mShowHistoryRunnable);', '            mShowHistoryRunnable = null;', '            if (event.getEventTime() - event.getDownTime()', '                            >= ViewConfiguration.getLongPressTimeout()', '                    && NavigationSheet.isInstanceShowing(', '                            mRootUiCoordinator.getBottomSheetController())) {', '                // If tab history popup is showing, do not process the keyUp event', '                // which will dismiss it immediately.', '                return true;', '            }', '        }', '        return super.onKeyUp(keyCode, event);', '    }', '', '    @VisibleForTesting', '    public boolean hasPendingNavigationRunnableForTesting() {', '        ThreadUtils.assertOnUiThread();', '        return mShowHistoryRunnable != null;', '    }', '', '    @Override', '    public void onProvideKeyboardShortcuts(', '            List<KeyboardShortcutGroup> data, Menu menu, int deviceId) {', '        data.addAll(KeyboardShortcuts.createShortcutGroup(this));', '    }', '', '    @VisibleForTesting', '    public View getTabsView() {', '        return getCompositorViewHolderSupplier().get();', '    }', '', '    @VisibleForTesting', '    public LayoutManagerChrome getLayoutManager() {', '        return (LayoutManagerChrome) getCompositorViewHolderSupplier().get().getLayoutManager();', '    }', '', '    @VisibleForTesting', '    public Layout getOverviewListLayout() {', '        return getLayoutManager().getOverviewListLayout();', '    }', '', '    @VisibleForTesting', '    public StartSurface getStartSurface() {', '        return mStartSurfaceSupplier.get();', '    }', '', '    private ComposedBrowserControlsVisibilityDelegate getAppBrowserControlsVisibilityDelegate() {', '        // TODO(jinsukkim): Move this to RootUiCoordinator.', '        return ((TabbedRootUiCoordinator) mRootUiCoordinator)', '                .getAppBrowserControlsVisibilityDelegate();', '    }', '', '    @Override', '    protected ModalDialogManager createModalDialogManager() {', '        ModalDialogManager manager = super.createModalDialogManager();', '        // TODO(crbug.com/1157310): Transition this::method refs to dedicated suppliers.', '        mTabModalHandler = new TabModalLifetimeHandler(this, getLifecycleDispatcher(), manager,', '                this::getAppBrowserControlsVisibilityDelegate, this::getTabObscuringHandler,', '                this::getToolbarManager, this::getContextualSearchManager,', '                getTabModelSelectorSupplier(), this::getBrowserControlsManager,', '                this::getFullscreenManager);', '        return manager;', '    }', '', '    // App Menu related code -----------------------------------------------------------------------', '', '    @Override', '    public boolean canShowAppMenu() {', '        // The popup menu relies on the model created during the full UI initialization, so do not', '        // attempt to show the menu until the UI creation has finished.', '        if (!mUIWithNativeInitialized) return false;', '', ""        // If the current active tab is showing a tab modal dialog, an app menu shouldn't be shown"", '        // in any cases, e.g. when a hardware menu button is clicked.', '        Tab tab = getActivityTab();', '        if (tab != null && ChromeTabModalPresenter.isDialogShowing(tab)) return false;', '', '        return super.canShowAppMenu();', '    }', '', '    @Override', '    public boolean isInOverviewMode() {', '        return mOverviewModeController != null && mOverviewModeController.overviewVisible();', '    }', '', '    @Override', '    protected IntentHandlerDelegate createIntentHandlerDelegate() {', '        return new InternalIntentDelegate();', '    }', '', '    @Override', '    public void onSceneChange(Layout layout) {', '        super.onSceneChange(layout);', '        if (!layout.shouldDisplayContentOverlay()) mTabModelSelector.onTabsViewShown();', '    }', '', '    /**', '     * Writes the tab state to disk.', '     */', '    @VisibleForTesting', '    public void saveState() {', '        mTabModelOrchestrator.saveState();', '    }', '', '    @Override', '    public void onEnterVr() {', '        super.onEnterVr();', '        mControlContainer.setVisibility(View.INVISIBLE);', '        if (mVrBrowserControlsVisibilityDelegate == null) {', '            mVrBrowserControlsVisibilityDelegate =', '                    new BrowserControlsVisibilityDelegate(BrowserControlsState.BOTH);', '            getAppBrowserControlsVisibilityDelegate().addDelegate(', '                    mVrBrowserControlsVisibilityDelegate);', '        }', '        mVrBrowserControlsVisibilityDelegate.set(BrowserControlsState.HIDDEN);', '    }', '', '    @Override', '    public void onExitVr() {', '        super.onExitVr();', '        mControlContainer.setVisibility(View.VISIBLE);', '        if (mVrBrowserControlsVisibilityDelegate != null) {', '            mVrBrowserControlsVisibilityDelegate.set(BrowserControlsState.BOTH);', '        }', '    }', '', '    @Override', '    protected void applyThemeOverlays() {', '        super.applyThemeOverlays();', '', '        if (TabManagementModuleProvider.getDelegate() != null) {', '            TabManagementModuleProvider.getDelegate().applyThemeOverlays(this);', '        }', '    }', '', '    @Override', '    protected boolean supportsDynamicColors() {', '        return CachedFeatureFlags.isEnabled(ChromeFeatureList.DYNAMIC_COLOR_ANDROID);', '    }', '', '    /**', '     * Reports that a new tab launcher shortcut was selected or an action equivalent to a shortcut', '     * was performed.', '     * @param isIncognito Whether the shortcut or action created a new incognito tab.', '     */', '    @TargetApi(Build.VERSION_CODES.N_MR1)', '    private void reportNewTabShortcutUsed(boolean isIncognito) {', '        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N_MR1) return;', '', '        ShortcutManager shortcutManager = getSystemService(ShortcutManager.class);', '        shortcutManager.reportShortcutUsed(', '                isIncognito ? ""new-incognito-tab-shortcut"" : ""new-tab-shortcut"");', '    }', '', '    @VisibleForTesting', '    public MultiInstanceManager getMultiInstanceMangerForTesting() {', '        return mMultiInstanceManager;', '    }', '', '    @VisibleForTesting', '    public ChromeNextTabPolicySupplier getNextTabPolicySupplier() {', '        return (ChromeNextTabPolicySupplier) mNextTabPolicySupplier;', '    }', '}', '']}]",chromium%2Fsrc~main~Ib63fff1d02f6696a61891dd6449012e0c7a5d027,8731f872fe833f2c64a8604ff02ad616355d9fed,chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java,b5ea4309_819de63f_before.java,b5ea4309_819de63f_after.java,ChromeTabbedActivity::handleBackPressed,True,True
6,dc75234d_557459ea,391.0,"Reading through the CL one more time - it looks like mForeignSessions can be null ONLY before updateForeignSessions call in the ctor. In all other cases it is guaranteed to be non-null. With this in mind, does it make sense to move updatePromoState after updateForeignSessions call in ctor (and use assert in this method instead)?",390.0,391.0,"[{'ab': ['// Copyright 2015 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ntp;', '', 'import android.content.Context;', '', 'import androidx.annotation.IntDef;', 'import androidx.annotation.Nullable;', 'import androidx.annotation.VisibleForTesting;', '', 'import org.chromium.base.metrics.RecordUserAction;', 'import org.chromium.base.task.PostTask;', 'import org.chromium.chrome.browser.invalidation.SessionsInvalidationManager;', 'import org.chromium.chrome.browser.ntp.ForeignSessionHelper.ForeignSession;', 'import org.chromium.chrome.browser.ntp.ForeignSessionHelper.ForeignSessionTab;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.signin.SyncConsentActivityLauncherImpl;', 'import org.chromium.chrome.browser.signin.services.IdentityServicesProvider;', 'import org.chromium.chrome.browser.signin.services.ProfileDataCache;', 'import org.chromium.chrome.browser.signin.services.SigninManager;', 'import org.chromium.chrome.browser.signin.services.SigninManager.SignInStateObserver;', 'import org.chromium.chrome.browser.signin.ui.PersonalizedSigninPromoView;', 'import org.chromium.chrome.browser.signin.ui.SigninPromoController;', 'import org.chromium.chrome.browser.sync.SyncService;', 'import org.chromium.chrome.browser.tab.Tab;', 'import org.chromium.chrome.browser.ui.favicon.FaviconHelper;', 'import org.chromium.chrome.browser.ui.favicon.FaviconHelper.FaviconImageCallback;', 'import org.chromium.components.signin.AccountManagerFacadeProvider;', 'import org.chromium.components.signin.AccountsChangeObserver;', 'import org.chromium.components.signin.identitymanager.ConsentLevel;', 'import org.chromium.components.signin.metrics.SigninAccessPoint;', 'import org.chromium.content_public.browser.UiThreadTaskTraits;', 'import org.chromium.url.GURL;', '', 'import java.lang.annotation.Retention;', 'import java.lang.annotation.RetentionPolicy;', 'import java.util.Collections;', 'import java.util.List;', '', '/**', ' * Provides the domain logic and data for RecentTabsPage and RecentTabsRowAdapter.', ' */', 'public class RecentTabsManager implements SyncService.SyncStateChangedListener, SignInStateObserver,', '                                          ProfileDataCache.Observer, AccountsChangeObserver {', '    /**', '     * Implement this to receive updates when the page contents change.', '     */', '    interface UpdatedCallback {', '        /**', '         * Called when the list of recently closed tabs or foreign sessions changes.', '         */', '        void onUpdated();', '    }', '    @Retention(RetentionPolicy.SOURCE)', '    @IntDef({PromoState.PROMO_NONE, PromoState.PROMO_SIGNIN_PERSONALIZED,', '            PromoState.PROMO_SYNC_PERSONALIZED, PromoState.PROMO_SYNC})', '    @interface PromoState {', '        int PROMO_NONE = 0;', '        int PROMO_SIGNIN_PERSONALIZED = 1;', '        int PROMO_SYNC_PERSONALIZED = 2;', '        int PROMO_SYNC = 3;', '    }', '', '    private static final int RECENTLY_CLOSED_MAX_TAB_COUNT = 5;', '', '    private static RecentlyClosedTabManager sRecentlyClosedTabManagerForTests;', '', '    private final Profile mProfile;', '    private final Tab mTab;', '    private final Runnable mShowHistoryManager;', '', '    private @PromoState int mPromoState = PromoState.PROMO_NONE;', '    private FaviconHelper mFaviconHelper;', '    private ForeignSessionHelper mForeignSessionHelper;', '    private List<ForeignSession> mForeignSessions;', '    private List<RecentlyClosedTab> mRecentlyClosedTabs;', '    private RecentTabsPagePrefs mPrefs;', '    private RecentlyClosedTabManager mRecentlyClosedTabManager;', '    private SigninManager mSignInManager;', '    private UpdatedCallback mUpdatedCallback;', '    private boolean mIsDestroyed;', '', '    private final ProfileDataCache mProfileDataCache;', '    private final SigninPromoController mSigninPromoController;', '    @Nullable', '    private final SyncService mSyncService;', '', '    /**', '     * Create an RecentTabsManager to be used with RecentTabsPage and RecentTabsRowAdapter.', '     *', '     * @param tab The Tab that is showing this recent tabs page.', '     * @param profile Profile that is associated with the current session.', '     * @param context the Android context this manager will work in.', '     * @param showHistoryManager Runnable showing history manager UI.', '     */', '    public RecentTabsManager(', '            Tab tab, Profile profile, Context context, Runnable showHistoryManager) {', '        mProfile = profile;', '        mTab = tab;', '        mShowHistoryManager = showHistoryManager;', '        mForeignSessionHelper = new ForeignSessionHelper(profile);', '        mPrefs = new RecentTabsPagePrefs(profile);', '        mFaviconHelper = new FaviconHelper();', '        mRecentlyClosedTabManager = sRecentlyClosedTabManagerForTests != null', '                ? sRecentlyClosedTabManagerForTests', '                : new RecentlyClosedBridge(profile);', '        mSignInManager = IdentityServicesProvider.get().getSigninManager(mProfile);', '', '        mProfileDataCache = ProfileDataCache.createWithDefaultImageSizeAndNoBadge(context);', '        mSigninPromoController = new SigninPromoController(', '                SigninAccessPoint.RECENT_TABS, SyncConsentActivityLauncherImpl.get());', '        mSyncService = SyncService.get();']}, {'b': ['        updatePromoState();']}, {'ab': ['', '        mRecentlyClosedTabManager.setTabsUpdatedRunnable(() -> {', '            updateRecentlyClosedTabs();', '            postUpdate();', '        });', '', '        updateRecentlyClosedTabs();', '        registerForForeignSessionUpdates();', '        updateForeignSessions();', '        mForeignSessionHelper.triggerSessionSync();', '        registerObservers();']}, {'a': ['        updatePromoState();']}, {'ab': ['', '        SessionsInvalidationManager.get(mProfile).onRecentTabsPageOpened();', '    }', '', '    /**', '     * Should be called when this object is no longer needed. Performs necessary listener tear down.', '     */', '    public void destroy() {', '        mIsDestroyed = true;', '        if (mSyncService != null) {', '            mSyncService.removeSyncStateChangedListener(this);', '        }', '', '        mSignInManager.removeSignInStateObserver(this);', '        mSignInManager = null;', '', '        mProfileDataCache.removeObserver(this);', '        AccountManagerFacadeProvider.getInstance().removeObserver(this);', '', '        mFaviconHelper.destroy();', '        mFaviconHelper = null;', '', '        mRecentlyClosedTabManager.destroy();', '        mRecentlyClosedTabManager = null;', '', '', '        mUpdatedCallback = null;', '', '        mPrefs.destroy();', '        mPrefs = null;', '', '        SessionsInvalidationManager.get(mProfile).onRecentTabsPageClosed();', '', '        mForeignSessionHelper.destroy();', '        mForeignSessionHelper = null;', '    }', '', '    private void registerForForeignSessionUpdates() {', '        mForeignSessionHelper.setOnForeignSessionCallback(() -> {', '            updateForeignSessions();', '            postUpdate();', '        });', '    }', '', '    private void registerObservers() {', '        if (mSyncService != null) {', '            mSyncService.addSyncStateChangedListener(this);', '        }', '', '        mSignInManager.addSignInStateObserver(this);', '', '        mProfileDataCache.addObserver(this);', '        AccountManagerFacadeProvider.getInstance().addObserver(this);', '    }', '', '    private void updateRecentlyClosedTabs() {', '        mRecentlyClosedTabs =', '                mRecentlyClosedTabManager.getRecentlyClosedTabs(RECENTLY_CLOSED_MAX_TAB_COUNT);', '    }', '', '    private void updateForeignSessions() {', '        mForeignSessions = mForeignSessionHelper.getForeignSessions();', '        if (mForeignSessions == null) {', '            mForeignSessions = Collections.emptyList();', '        }', '    }', '', '    /**', '     * @return Most up-to-date list of foreign sessions.', '     */', '    public List<ForeignSession> getForeignSessions() {', '        return mForeignSessions;', '    }', '', '    /**', '     * @return Most up-to-date list of recently closed tabs.', '     */', '    public List<RecentlyClosedTab> getRecentlyClosedTabs() {', '        return mRecentlyClosedTabs;', '    }', '', '    /**', '     * Opens a new tab navigating to ForeignSessionTab.', '     *', '     * @param session The foreign session that the tab belongs to.', '     * @param tab The tab to open.', '     * @param windowDisposition The WindowOpenDisposition flag.', '     */', '    public void openForeignSessionTab(ForeignSession session, ForeignSessionTab tab,', '            int windowDisposition) {', '        if (mIsDestroyed) return;', '        RecordUserAction.record(""MobileRecentTabManagerTabFromOtherDeviceOpened"");', '        mForeignSessionHelper.openForeignSessionTab(mTab, session, tab, windowDisposition);', '    }', '', '    /**', '     * Restores a recently closed tab.', '     *', '     * @param tab The tab to open.', '     * @param windowDisposition The WindowOpenDisposition value specifying whether the tab should', '     *         be restored into the current tab or a new tab.', '     */', '    public void openRecentlyClosedTab(RecentlyClosedTab tab, int windowDisposition) {', '        if (mIsDestroyed) return;', '        RecordUserAction.record(""MobileRecentTabManagerRecentTabOpened"");', '        mRecentlyClosedTabManager.openRecentlyClosedTab(mTab, tab, windowDisposition);', '    }', '', '    /**', '     * Opens the history page.', '     */', '    public void openHistoryPage() {', '        if (mIsDestroyed) return;', '        mShowHistoryManager.run();', '    }', '', '    /**', '     * Return the managed tab.', '     * @return the tab instance being managed by this object.', '     */', '    public Tab activeTab() {', '        return mTab;', '    }', '', '    /**', '     * Returns a favicon for a given foreign url.', '     *', '     * @param url The url to fetch the favicon for.', '     * @param size the desired favicon size.', '     * @param faviconCallback the callback to be invoked when the favicon is available.', '     * @return favicon or null if favicon unavailable.', '     */', '    public boolean getForeignFaviconForUrl(', '            GURL url, int size, FaviconImageCallback faviconCallback) {', '        return mFaviconHelper.getForeignFaviconImageForURL(mProfile, url, size, faviconCallback);', '    }', '', '    /**', '     * Fetches a favicon for snapshot document url which is returned via callback.', '     *', '     * @param url The url to fetch a favicon for.', '     * @param size the desired favicon size.', '     * @param faviconCallback the callback to be invoked when the favicon is available.', '     *', '     * @return may return false if we could not fetch the favicon.', '     */', '    public boolean getLocalFaviconForUrl(GURL url, int size, FaviconImageCallback faviconCallback) {', '        return mFaviconHelper.getLocalFaviconImageForURL(mProfile, url, size, faviconCallback);', '    }', '', '    /**', '     * Sets a callback to be invoked when recently closed tabs or foreign sessions documents have', '     * been updated.', '     *', '     * @param updatedCallback the listener to be invoked.', '     */', '    public void setUpdatedCallback(UpdatedCallback updatedCallback) {', '        mUpdatedCallback = updatedCallback;', '    }', '', '    /**', '     * Sets the persistent expanded/collapsed state of a foreign session list.', '     *', '     * @param session foreign session to collapsed.', '     * @param isCollapsed Whether the session is collapsed or expanded.', '     */', '    public void setForeignSessionCollapsed(ForeignSession session, boolean isCollapsed) {', '        if (mIsDestroyed) return;', '        mPrefs.setForeignSessionCollapsed(session, isCollapsed);', '    }', '', '    /**', '     * Determine the expanded/collapsed state of a foreign session list.', '     *', '     * @param session foreign session whose state to obtain.', '     *', '     * @return Whether the session is collapsed.', '     */', '    public boolean getForeignSessionCollapsed(ForeignSession session) {', '        return mPrefs.getForeignSessionCollapsed(session);', '    }', '', '    /**', '     * Sets the persistent expanded/collapsed state of the recently closed tabs list.', '     *', '     * @param isCollapsed Whether the recently closed tabs list is collapsed.', '     */', '    public void setRecentlyClosedTabsCollapsed(boolean isCollapsed) {', '        if (mIsDestroyed) return;', '        mPrefs.setRecentlyClosedTabsCollapsed(isCollapsed);', '    }', '', '    /**', '     * Determine the expanded/collapsed state of the recently closed tabs list.', '     *', '     * @return Whether the recently closed tabs list is collapsed.', '     */', '    public boolean isRecentlyClosedTabsCollapsed() {', '        return mPrefs.getRecentlyClosedTabsCollapsed();', '    }', '', '    /**', '     * Remove Foreign session to display. Note that it might reappear during the next sync if the', '     * session is not orphaned.', '     *', '     * This is mainly for when user wants to delete an orphaned session.', '     * @param session Session to be deleted.', '     */', '    public void deleteForeignSession(ForeignSession session) {', '        if (mIsDestroyed) return;', '        mForeignSessionHelper.deleteForeignSession(session);', '    }', '', '    /**', '     * Clears the list of recently closed tabs.', '     */', '    public void clearRecentlyClosedTabs() {', '        if (mIsDestroyed) return;', '        mRecentlyClosedTabManager.clearRecentlyClosedTabs();', '    }', '', '    /**', '     * Collapse the promo.', '     *', '     * @param isCollapsed Whether the promo is collapsed.', '     */', '    public void setPromoCollapsed(boolean isCollapsed) {', '        if (mIsDestroyed) return;', '        mPrefs.setSyncPromoCollapsed(isCollapsed);', '    }', '', '    /**', '     * Determine whether the promo is collapsed.', '     *', '     * @return Whether the promo is collapsed.', '     */', '    public boolean isPromoCollapsed() {', '        return mPrefs.getSyncPromoCollapsed();', '    }', '', '    /** Returns the current promo state. */', '    @PromoState', '    int getPromoState() {', '        return mPromoState;', '    }', '', '    private @PromoState int calculatePromoState() {', '        if (!mSignInManager.getIdentityManager().hasPrimaryAccount(ConsentLevel.SYNC)) {', '            if (!mSignInManager.isSignInAllowed()) {', '                return PromoState.PROMO_NONE;', '            }', '            if (mSignInManager.getIdentityManager().hasPrimaryAccount(ConsentLevel.SIGNIN)) {', '                return PromoState.PROMO_SYNC_PERSONALIZED;', '            }', '            return PromoState.PROMO_SIGNIN_PERSONALIZED;', '        }', '', '        if (mSyncService == null) {', '            // |mSyncService| will remain null until the next browser startup, so no sense in', '            // offering any promo.', '            return PromoState.PROMO_NONE;', '        }', '']}, {'a': ['        if (mSyncService.isSyncRequested() && !mForeignSessions.isEmpty()) {'], 'b': ['        if (mSyncService.isSyncRequested() && mForeignSessions != null', '                && !mForeignSessions.isEmpty()) {']}, {'ab': ['            return PromoState.PROMO_NONE;', '        }', '        return PromoState.PROMO_SYNC;', '    }', '', '    private void updatePromoState() {', '        final @PromoState int newState = calculatePromoState();', '        if (newState == mPromoState) return;', '', '        final boolean hasSyncPromoStateChangedtoShown =', '                (mPromoState == PromoState.PROMO_NONE || mPromoState == PromoState.PROMO_SYNC)', '                && (newState == PromoState.PROMO_SIGNIN_PERSONALIZED', '                        || newState == PromoState.PROMO_SYNC_PERSONALIZED);', '        if (hasSyncPromoStateChangedtoShown) {', '            mSigninPromoController.increasePromoShowCount();', '        }', '        mPromoState = newState;', '    }', '', '    /**', '     * Sets up the sync promo view.', '     */', '    void setUpSyncPromoView(PersonalizedSigninPromoView view) {', '        mSigninPromoController.setUpSyncPromoView(mProfileDataCache, view, null);', '    }', '', '    // SignInStateObserver implementation.', '    @Override', '    public void onSignedIn() {', '        update();', '    }', '', '    @Override', '    public void onSignedOut() {', '        update();', '    }', '', '    // AccountsChangeObserver implementation.', '    @Override', '    public void onAccountsChanged() {', '        update();', '    }', '', '    // ProfileDataCache.Observer implementation.', '    @Override', '    public void onProfileDataUpdated(String accountEmail) {', '        update();', '    }', '', '    // SyncService.SyncStateChangedListener implementation.', '    @Override', '    public void syncStateChanged() {', '        update();', '    }', '', '    private void postUpdate() {', '        if (mUpdatedCallback != null) {', '            mUpdatedCallback.onUpdated();', '        }', '    }', '', '    private void update() {', '        updatePromoState();', ""        // TODO(crbug.com/1129853): Re-evaluate whether it's necessary to post"", '        // a task.', '        PostTask.runOrPostTask(UiThreadTaskTraits.DEFAULT, () -> {', '            if (mIsDestroyed) return;', '            updateForeignSessions();', '            postUpdate();', '        });', '    }', '', '    @VisibleForTesting', '    public static void setRecentlyClosedTabManagerForTests(RecentlyClosedTabManager manager) {', '        sRecentlyClosedTabManagerForTests = manager;', '    }', '}', '']}]",chromium%2Fsrc~main~I8c1ec9d2b63189464793281e35f2f5b6a8aa3243,22e946dadefb9c777a072553c1c6f831d2382e2d,chrome/android/java/src/org/chromium/chrome/browser/ntp/RecentTabsManager.java,dc75234d_557459ea_before.java,dc75234d_557459ea_after.java,RecentTabsManager::calculatePromoState,True,True
7,4889ba76_7b6f8367,391.0,Done,390.0,391.0,"[{'ab': ['// Copyright 2015 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ntp;', '', 'import android.content.Context;', '', 'import androidx.annotation.IntDef;', 'import androidx.annotation.Nullable;', 'import androidx.annotation.VisibleForTesting;', '', 'import org.chromium.base.metrics.RecordUserAction;', 'import org.chromium.base.task.PostTask;', 'import org.chromium.chrome.browser.invalidation.SessionsInvalidationManager;', 'import org.chromium.chrome.browser.ntp.ForeignSessionHelper.ForeignSession;', 'import org.chromium.chrome.browser.ntp.ForeignSessionHelper.ForeignSessionTab;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.signin.SyncConsentActivityLauncherImpl;', 'import org.chromium.chrome.browser.signin.services.IdentityServicesProvider;', 'import org.chromium.chrome.browser.signin.services.ProfileDataCache;', 'import org.chromium.chrome.browser.signin.services.SigninManager;', 'import org.chromium.chrome.browser.signin.services.SigninManager.SignInStateObserver;', 'import org.chromium.chrome.browser.signin.ui.PersonalizedSigninPromoView;', 'import org.chromium.chrome.browser.signin.ui.SigninPromoController;', 'import org.chromium.chrome.browser.sync.SyncService;', 'import org.chromium.chrome.browser.tab.Tab;', 'import org.chromium.chrome.browser.ui.favicon.FaviconHelper;', 'import org.chromium.chrome.browser.ui.favicon.FaviconHelper.FaviconImageCallback;', 'import org.chromium.components.signin.AccountManagerFacadeProvider;', 'import org.chromium.components.signin.AccountsChangeObserver;', 'import org.chromium.components.signin.identitymanager.ConsentLevel;', 'import org.chromium.components.signin.metrics.SigninAccessPoint;', 'import org.chromium.content_public.browser.UiThreadTaskTraits;', 'import org.chromium.url.GURL;', '', 'import java.lang.annotation.Retention;', 'import java.lang.annotation.RetentionPolicy;', 'import java.util.Collections;', 'import java.util.List;', '', '/**', ' * Provides the domain logic and data for RecentTabsPage and RecentTabsRowAdapter.', ' */', 'public class RecentTabsManager implements SyncService.SyncStateChangedListener, SignInStateObserver,', '                                          ProfileDataCache.Observer, AccountsChangeObserver {', '    /**', '     * Implement this to receive updates when the page contents change.', '     */', '    interface UpdatedCallback {', '        /**', '         * Called when the list of recently closed tabs or foreign sessions changes.', '         */', '        void onUpdated();', '    }', '    @Retention(RetentionPolicy.SOURCE)', '    @IntDef({PromoState.PROMO_NONE, PromoState.PROMO_SIGNIN_PERSONALIZED,', '            PromoState.PROMO_SYNC_PERSONALIZED, PromoState.PROMO_SYNC})', '    @interface PromoState {', '        int PROMO_NONE = 0;', '        int PROMO_SIGNIN_PERSONALIZED = 1;', '        int PROMO_SYNC_PERSONALIZED = 2;', '        int PROMO_SYNC = 3;', '    }', '', '    private static final int RECENTLY_CLOSED_MAX_TAB_COUNT = 5;', '', '    private static RecentlyClosedTabManager sRecentlyClosedTabManagerForTests;', '', '    private final Profile mProfile;', '    private final Tab mTab;', '    private final Runnable mShowHistoryManager;', '', '    private @PromoState int mPromoState = PromoState.PROMO_NONE;', '    private FaviconHelper mFaviconHelper;', '    private ForeignSessionHelper mForeignSessionHelper;', '    private List<ForeignSession> mForeignSessions;', '    private List<RecentlyClosedTab> mRecentlyClosedTabs;', '    private RecentTabsPagePrefs mPrefs;', '    private RecentlyClosedTabManager mRecentlyClosedTabManager;', '    private SigninManager mSignInManager;', '    private UpdatedCallback mUpdatedCallback;', '    private boolean mIsDestroyed;', '', '    private final ProfileDataCache mProfileDataCache;', '    private final SigninPromoController mSigninPromoController;', '    @Nullable', '    private final SyncService mSyncService;', '', '    /**', '     * Create an RecentTabsManager to be used with RecentTabsPage and RecentTabsRowAdapter.', '     *', '     * @param tab The Tab that is showing this recent tabs page.', '     * @param profile Profile that is associated with the current session.', '     * @param context the Android context this manager will work in.', '     * @param showHistoryManager Runnable showing history manager UI.', '     */', '    public RecentTabsManager(', '            Tab tab, Profile profile, Context context, Runnable showHistoryManager) {', '        mProfile = profile;', '        mTab = tab;', '        mShowHistoryManager = showHistoryManager;', '        mForeignSessionHelper = new ForeignSessionHelper(profile);', '        mPrefs = new RecentTabsPagePrefs(profile);', '        mFaviconHelper = new FaviconHelper();', '        mRecentlyClosedTabManager = sRecentlyClosedTabManagerForTests != null', '                ? sRecentlyClosedTabManagerForTests', '                : new RecentlyClosedBridge(profile);', '        mSignInManager = IdentityServicesProvider.get().getSigninManager(mProfile);', '', '        mProfileDataCache = ProfileDataCache.createWithDefaultImageSizeAndNoBadge(context);', '        mSigninPromoController = new SigninPromoController(', '                SigninAccessPoint.RECENT_TABS, SyncConsentActivityLauncherImpl.get());', '        mSyncService = SyncService.get();']}, {'b': ['        updatePromoState();']}, {'ab': ['', '        mRecentlyClosedTabManager.setTabsUpdatedRunnable(() -> {', '            updateRecentlyClosedTabs();', '            postUpdate();', '        });', '', '        updateRecentlyClosedTabs();', '        registerForForeignSessionUpdates();', '        updateForeignSessions();', '        mForeignSessionHelper.triggerSessionSync();', '        registerObservers();']}, {'a': ['        updatePromoState();']}, {'ab': ['', '        SessionsInvalidationManager.get(mProfile).onRecentTabsPageOpened();', '    }', '', '    /**', '     * Should be called when this object is no longer needed. Performs necessary listener tear down.', '     */', '    public void destroy() {', '        mIsDestroyed = true;', '        if (mSyncService != null) {', '            mSyncService.removeSyncStateChangedListener(this);', '        }', '', '        mSignInManager.removeSignInStateObserver(this);', '        mSignInManager = null;', '', '        mProfileDataCache.removeObserver(this);', '        AccountManagerFacadeProvider.getInstance().removeObserver(this);', '', '        mFaviconHelper.destroy();', '        mFaviconHelper = null;', '', '        mRecentlyClosedTabManager.destroy();', '        mRecentlyClosedTabManager = null;', '', '', '        mUpdatedCallback = null;', '', '        mPrefs.destroy();', '        mPrefs = null;', '', '        SessionsInvalidationManager.get(mProfile).onRecentTabsPageClosed();', '', '        mForeignSessionHelper.destroy();', '        mForeignSessionHelper = null;', '    }', '', '    private void registerForForeignSessionUpdates() {', '        mForeignSessionHelper.setOnForeignSessionCallback(() -> {', '            updateForeignSessions();', '            postUpdate();', '        });', '    }', '', '    private void registerObservers() {', '        if (mSyncService != null) {', '            mSyncService.addSyncStateChangedListener(this);', '        }', '', '        mSignInManager.addSignInStateObserver(this);', '', '        mProfileDataCache.addObserver(this);', '        AccountManagerFacadeProvider.getInstance().addObserver(this);', '    }', '', '    private void updateRecentlyClosedTabs() {', '        mRecentlyClosedTabs =', '                mRecentlyClosedTabManager.getRecentlyClosedTabs(RECENTLY_CLOSED_MAX_TAB_COUNT);', '    }', '', '    private void updateForeignSessions() {', '        mForeignSessions = mForeignSessionHelper.getForeignSessions();', '        if (mForeignSessions == null) {', '            mForeignSessions = Collections.emptyList();', '        }', '    }', '', '    /**', '     * @return Most up-to-date list of foreign sessions.', '     */', '    public List<ForeignSession> getForeignSessions() {', '        return mForeignSessions;', '    }', '', '    /**', '     * @return Most up-to-date list of recently closed tabs.', '     */', '    public List<RecentlyClosedTab> getRecentlyClosedTabs() {', '        return mRecentlyClosedTabs;', '    }', '', '    /**', '     * Opens a new tab navigating to ForeignSessionTab.', '     *', '     * @param session The foreign session that the tab belongs to.', '     * @param tab The tab to open.', '     * @param windowDisposition The WindowOpenDisposition flag.', '     */', '    public void openForeignSessionTab(ForeignSession session, ForeignSessionTab tab,', '            int windowDisposition) {', '        if (mIsDestroyed) return;', '        RecordUserAction.record(""MobileRecentTabManagerTabFromOtherDeviceOpened"");', '        mForeignSessionHelper.openForeignSessionTab(mTab, session, tab, windowDisposition);', '    }', '', '    /**', '     * Restores a recently closed tab.', '     *', '     * @param tab The tab to open.', '     * @param windowDisposition The WindowOpenDisposition value specifying whether the tab should', '     *         be restored into the current tab or a new tab.', '     */', '    public void openRecentlyClosedTab(RecentlyClosedTab tab, int windowDisposition) {', '        if (mIsDestroyed) return;', '        RecordUserAction.record(""MobileRecentTabManagerRecentTabOpened"");', '        mRecentlyClosedTabManager.openRecentlyClosedTab(mTab, tab, windowDisposition);', '    }', '', '    /**', '     * Opens the history page.', '     */', '    public void openHistoryPage() {', '        if (mIsDestroyed) return;', '        mShowHistoryManager.run();', '    }', '', '    /**', '     * Return the managed tab.', '     * @return the tab instance being managed by this object.', '     */', '    public Tab activeTab() {', '        return mTab;', '    }', '', '    /**', '     * Returns a favicon for a given foreign url.', '     *', '     * @param url The url to fetch the favicon for.', '     * @param size the desired favicon size.', '     * @param faviconCallback the callback to be invoked when the favicon is available.', '     * @return favicon or null if favicon unavailable.', '     */', '    public boolean getForeignFaviconForUrl(', '            GURL url, int size, FaviconImageCallback faviconCallback) {', '        return mFaviconHelper.getForeignFaviconImageForURL(mProfile, url, size, faviconCallback);', '    }', '', '    /**', '     * Fetches a favicon for snapshot document url which is returned via callback.', '     *', '     * @param url The url to fetch a favicon for.', '     * @param size the desired favicon size.', '     * @param faviconCallback the callback to be invoked when the favicon is available.', '     *', '     * @return may return false if we could not fetch the favicon.', '     */', '    public boolean getLocalFaviconForUrl(GURL url, int size, FaviconImageCallback faviconCallback) {', '        return mFaviconHelper.getLocalFaviconImageForURL(mProfile, url, size, faviconCallback);', '    }', '', '    /**', '     * Sets a callback to be invoked when recently closed tabs or foreign sessions documents have', '     * been updated.', '     *', '     * @param updatedCallback the listener to be invoked.', '     */', '    public void setUpdatedCallback(UpdatedCallback updatedCallback) {', '        mUpdatedCallback = updatedCallback;', '    }', '', '    /**', '     * Sets the persistent expanded/collapsed state of a foreign session list.', '     *', '     * @param session foreign session to collapsed.', '     * @param isCollapsed Whether the session is collapsed or expanded.', '     */', '    public void setForeignSessionCollapsed(ForeignSession session, boolean isCollapsed) {', '        if (mIsDestroyed) return;', '        mPrefs.setForeignSessionCollapsed(session, isCollapsed);', '    }', '', '    /**', '     * Determine the expanded/collapsed state of a foreign session list.', '     *', '     * @param session foreign session whose state to obtain.', '     *', '     * @return Whether the session is collapsed.', '     */', '    public boolean getForeignSessionCollapsed(ForeignSession session) {', '        return mPrefs.getForeignSessionCollapsed(session);', '    }', '', '    /**', '     * Sets the persistent expanded/collapsed state of the recently closed tabs list.', '     *', '     * @param isCollapsed Whether the recently closed tabs list is collapsed.', '     */', '    public void setRecentlyClosedTabsCollapsed(boolean isCollapsed) {', '        if (mIsDestroyed) return;', '        mPrefs.setRecentlyClosedTabsCollapsed(isCollapsed);', '    }', '', '    /**', '     * Determine the expanded/collapsed state of the recently closed tabs list.', '     *', '     * @return Whether the recently closed tabs list is collapsed.', '     */', '    public boolean isRecentlyClosedTabsCollapsed() {', '        return mPrefs.getRecentlyClosedTabsCollapsed();', '    }', '', '    /**', '     * Remove Foreign session to display. Note that it might reappear during the next sync if the', '     * session is not orphaned.', '     *', '     * This is mainly for when user wants to delete an orphaned session.', '     * @param session Session to be deleted.', '     */', '    public void deleteForeignSession(ForeignSession session) {', '        if (mIsDestroyed) return;', '        mForeignSessionHelper.deleteForeignSession(session);', '    }', '', '    /**', '     * Clears the list of recently closed tabs.', '     */', '    public void clearRecentlyClosedTabs() {', '        if (mIsDestroyed) return;', '        mRecentlyClosedTabManager.clearRecentlyClosedTabs();', '    }', '', '    /**', '     * Collapse the promo.', '     *', '     * @param isCollapsed Whether the promo is collapsed.', '     */', '    public void setPromoCollapsed(boolean isCollapsed) {', '        if (mIsDestroyed) return;', '        mPrefs.setSyncPromoCollapsed(isCollapsed);', '    }', '', '    /**', '     * Determine whether the promo is collapsed.', '     *', '     * @return Whether the promo is collapsed.', '     */', '    public boolean isPromoCollapsed() {', '        return mPrefs.getSyncPromoCollapsed();', '    }', '', '    /** Returns the current promo state. */', '    @PromoState', '    int getPromoState() {', '        return mPromoState;', '    }', '', '    private @PromoState int calculatePromoState() {', '        if (!mSignInManager.getIdentityManager().hasPrimaryAccount(ConsentLevel.SYNC)) {', '            if (!mSignInManager.isSignInAllowed()) {', '                return PromoState.PROMO_NONE;', '            }', '            if (mSignInManager.getIdentityManager().hasPrimaryAccount(ConsentLevel.SIGNIN)) {', '                return PromoState.PROMO_SYNC_PERSONALIZED;', '            }', '            return PromoState.PROMO_SIGNIN_PERSONALIZED;', '        }', '', '        if (mSyncService == null) {', '            // |mSyncService| will remain null until the next browser startup, so no sense in', '            // offering any promo.', '            return PromoState.PROMO_NONE;', '        }', '']}, {'a': ['        if (mSyncService.isSyncRequested() && !mForeignSessions.isEmpty()) {'], 'b': ['        if (mSyncService.isSyncRequested() && mForeignSessions != null', '                && !mForeignSessions.isEmpty()) {']}, {'ab': ['            return PromoState.PROMO_NONE;', '        }', '        return PromoState.PROMO_SYNC;', '    }', '', '    private void updatePromoState() {', '        final @PromoState int newState = calculatePromoState();', '        if (newState == mPromoState) return;', '', '        final boolean hasSyncPromoStateChangedtoShown =', '                (mPromoState == PromoState.PROMO_NONE || mPromoState == PromoState.PROMO_SYNC)', '                && (newState == PromoState.PROMO_SIGNIN_PERSONALIZED', '                        || newState == PromoState.PROMO_SYNC_PERSONALIZED);', '        if (hasSyncPromoStateChangedtoShown) {', '            mSigninPromoController.increasePromoShowCount();', '        }', '        mPromoState = newState;', '    }', '', '    /**', '     * Sets up the sync promo view.', '     */', '    void setUpSyncPromoView(PersonalizedSigninPromoView view) {', '        mSigninPromoController.setUpSyncPromoView(mProfileDataCache, view, null);', '    }', '', '    // SignInStateObserver implementation.', '    @Override', '    public void onSignedIn() {', '        update();', '    }', '', '    @Override', '    public void onSignedOut() {', '        update();', '    }', '', '    // AccountsChangeObserver implementation.', '    @Override', '    public void onAccountsChanged() {', '        update();', '    }', '', '    // ProfileDataCache.Observer implementation.', '    @Override', '    public void onProfileDataUpdated(String accountEmail) {', '        update();', '    }', '', '    // SyncService.SyncStateChangedListener implementation.', '    @Override', '    public void syncStateChanged() {', '        update();', '    }', '', '    private void postUpdate() {', '        if (mUpdatedCallback != null) {', '            mUpdatedCallback.onUpdated();', '        }', '    }', '', '    private void update() {', '        updatePromoState();', ""        // TODO(crbug.com/1129853): Re-evaluate whether it's necessary to post"", '        // a task.', '        PostTask.runOrPostTask(UiThreadTaskTraits.DEFAULT, () -> {', '            if (mIsDestroyed) return;', '            updateForeignSessions();', '            postUpdate();', '        });', '    }', '', '    @VisibleForTesting', '    public static void setRecentlyClosedTabManagerForTests(RecentlyClosedTabManager manager) {', '        sRecentlyClosedTabManagerForTests = manager;', '    }', '}', '']}]",chromium%2Fsrc~main~I8c1ec9d2b63189464793281e35f2f5b6a8aa3243,22e946dadefb9c777a072553c1c6f831d2382e2d,chrome/android/java/src/org/chromium/chrome/browser/ntp/RecentTabsManager.java,4889ba76_7b6f8367_before.java,4889ba76_7b6f8367_after.java,RecentTabsManager::calculatePromoState,True,True
14,6395c650_38152d5e,305.0,"Can you just reuse this field for mPromoShownAfterImpressionsHistogramName, somehow I think mImpressionCountName is easier to read and understand for its brevity.",305.0,305.0,"[{'ab': ['// Copyright 2017 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.signin.ui;', '', 'import android.accounts.Account;', 'import android.content.Context;', 'import android.graphics.drawable.Drawable;', 'import android.text.format.DateUtils;', 'import android.view.View;', 'import android.view.ViewGroup;', '', 'import androidx.annotation.DimenRes;', 'import androidx.annotation.Nullable;', 'import androidx.annotation.StringRes;', 'import androidx.annotation.VisibleForTesting;', '', 'import org.chromium.base.metrics.RecordHistogram;', 'import org.chromium.base.metrics.RecordUserAction;', 'import org.chromium.chrome.browser.flags.ChromeFeatureList;', 'import org.chromium.chrome.browser.preferences.ChromePreferenceKeys;', 'import org.chromium.chrome.browser.preferences.SharedPreferencesManager;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.signin.services.DisplayableProfileData;', 'import org.chromium.chrome.browser.signin.services.IdentityServicesProvider;', 'import org.chromium.chrome.browser.signin.services.ProfileDataCache;', 'import org.chromium.chrome.browser.signin.ui.SyncConsentActivityLauncher.AccessPoint;', 'import org.chromium.chrome.features.start_surface.StartSurfaceConfiguration;', 'import org.chromium.components.browser_ui.widget.impression.ImpressionTracker;', 'import org.chromium.components.browser_ui.widget.impression.OneShotImpressionListener;', 'import org.chromium.components.signin.AccountManagerFacade;', 'import org.chromium.components.signin.AccountManagerFacadeProvider;', 'import org.chromium.components.signin.AccountUtils;', 'import org.chromium.components.signin.base.CoreAccountInfo;', 'import org.chromium.components.signin.identitymanager.ConsentLevel;', 'import org.chromium.components.signin.identitymanager.IdentityManager;', 'import org.chromium.components.signin.metrics.SigninAccessPoint;', '', '/**', ' * A controller for configuring the sign in promo. It sets up the sign in promo depending on the', ' * context: whether there are any Google accounts on the device which have been previously signed in', ' * or not. The controller also takes care of counting impressions, recording signin related user', ' * actions and histograms.', ' */', 'public class SigninPromoController {', '    /**', '     * Receives notifications when user clicks close button in the promo.', '     */', '    public interface OnDismissListener {', '        /**', '         * Action to be performed when the promo is being dismissed.', '         */', '        void onDismiss();', '    }', '', '    private static final int MAX_TOTAL_PROMO_SHOW_COUNT = 100;', '    private static final int MAX_IMPRESSIONS_BOOKMARKS = 20;', '    private static final int MAX_IMPRESSIONS_SETTINGS = 20;', '', '    /** Suffix strings for promo shown count preference. */', '    private static final String BOOKMARKS = ""Bookmarks"";', '    private static final String NTP = ""Ntp"";']}, {'b': ['    private static final String RECENT_TABS = ""RecentTabs"";']}, {'ab': ['    private static final String SETTINGS = ""Settings"";', '', '    private @Nullable DisplayableProfileData mProfileData;', '    private @Nullable ImpressionTracker mImpressionTracker;', '    private final @AccessPoint int mAccessPoint;']}, {'a': ['    private final String mImpressionCountHistogramName;', '    private final String mContinuedAfterImpressionsHistogramName;', '    private final String mDismissedAfterImpressionsHistogramName;'], 'b': ['    private final String mPromoShownAfterImpressionsHistogramName;', '    private final String mSigninCompletedAfterImpressionsHistogramName;', '    private final String mPromoDismissedAfterImpressionsHistogramName;']}, {'ab': ['    // TODO(https://crbug.com/1254399): Remove this field. This is over counted.', '    private final @Nullable String mImpressionCountName;', '    private final String mImpressionUserActionName;', '    private final String mImpressionWithAccountUserActionName;', '    private final String mImpressionWithNoAccountUserActionName;', '    private final String mSigninWithDefaultUserActionName;', '    private final String mSigninNotDefaultUserActionName;', '    private final String mSigninNewAccountUserActionName;', '    private final @Nullable String mSyncPromoDismissedPreferenceTracker;']}, {'a': ['    // TODO(https://crbug.com/1254399): Remove these fields related to impressions.']}, {'ab': ['    private final @Nullable String mImpressionsTilDismissHistogramName;', '    private final @Nullable String mImpressionsTilSigninButtonsHistogramName;', '    private final @Nullable String mImpressionsTilXButtonHistogramName;', '    private final @StringRes int mDescriptionStringId;', '    private final @StringRes int mDescriptionStringIdNoAccount;', '    private final SyncConsentActivityLauncher mSyncConsentActivityLauncher;', '    private boolean mWasDisplayed;', '    private boolean mWasUsed;', '', '    /**', '     * Determines whether the Sync promo can be shown.', '     * @param accessPoint The access point for which the impression limit is being checked.', '     */', '    public static boolean canShowSyncPromo(@AccessPoint int accessPoint) {', '        switch (accessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                return canShowBookmarkPromo();', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                return canShowNTPPromo();', '            case SigninAccessPoint.RECENT_TABS:', '                // There is no impression limit or dismiss button in Recent Tabs promo.', '                return true;', '            case SigninAccessPoint.SETTINGS:', '                return canShowSettingsPromo();', '            default:', '                assert false : ""Unexpected value for access point: "" + accessPoint;', '                return false;', '        }', '    }', '', '    /**', '     * If the signin promo card has been hidden for longer than the {@link', '     * StartSurfaceConfiguration#SIGNIN_PROMO_NTP_RESET_AFTER_HOURS}, resets the impression counts,', '     * {@link ChromePreferenceKeys#SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME} and {@link', '     * ChromePreferenceKeys#SIGNIN_PROMO_NTP_LAST_SHOWN_TIME} to allow the promo card to show again.', '     */', '    public static void resetNTPSyncPromoLimitsIfHiddenForTooLong() {', '        final long currentTime = System.currentTimeMillis();', '        final long resetAfterMs =', '                StartSurfaceConfiguration.SIGNIN_PROMO_NTP_RESET_AFTER_HOURS.getValue()', '                * DateUtils.HOUR_IN_MILLIS;', '        final long lastShownTime = SharedPreferencesManager.getInstance().readLong(', '                ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME, 0L);', '        if (resetAfterMs <= 0 || lastShownTime <= 0) return;', '', '        if (currentTime - lastShownTime >= resetAfterMs) {', '            SharedPreferencesManager.getInstance().writeInt(', '                    getPromoShowCountPreferenceName(SigninAccessPoint.NTP_CONTENT_SUGGESTIONS), 0);', '            SharedPreferencesManager.getInstance().removeKey(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME);', '            SharedPreferencesManager.getInstance().removeKey(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME);', '        }', '    }', '', '    private static boolean canShowBookmarkPromo() {', '        boolean isPromoDismissed = SharedPreferencesManager.getInstance().readBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED, false);', '        return SharedPreferencesManager.getInstance().readInt(', '                       getPromoShowCountPreferenceName(SigninAccessPoint.BOOKMARK_MANAGER))', '                < MAX_IMPRESSIONS_BOOKMARKS', '                && !isPromoDismissed;', '    }', '', '    private static boolean timeElapsedSinceFirstShownExceedsLimit() {', '        final long timeSinceFirstShownLimitMs =', '                StartSurfaceConfiguration.SIGNIN_PROMO_NTP_SINCE_FIRST_TIME_SHOWN_LIMIT_HOURS', '                        .getValue()', '                * DateUtils.HOUR_IN_MILLIS;', '        if (timeSinceFirstShownLimitMs <= 0) return false;', '', '        final long currentTime = System.currentTimeMillis();', '        final long firstShownTime = SharedPreferencesManager.getInstance().readLong(', '                ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME, 0L);', '        return firstShownTime > 0 && currentTime - firstShownTime >= timeSinceFirstShownLimitMs;', '    }', '', '    private static boolean canShowNTPPromo() {', '        int maxImpressions = ChromeFeatureList.getFieldTrialParamByFeatureAsInt(', '                ChromeFeatureList.ENHANCED_PROTECTION_PROMO_CARD, ""MaxSigninPromoImpressions"",', '                Integer.MAX_VALUE);', '        if (SharedPreferencesManager.getInstance().readInt(', '                    getPromoShowCountPreferenceName(SigninAccessPoint.NTP_CONTENT_SUGGESTIONS))', '                        >= maxImpressions', '                || timeElapsedSinceFirstShownExceedsLimit()) {', '            return false;', '        }', '', '        if (SharedPreferencesManager.getInstance().readBoolean(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_PROMO_DISMISSED, false)) {', '            return false;', '        }', '', '        if (ChromeFeatureList.isEnabled(ChromeFeatureList.FORCE_DISABLE_EXTENDED_SYNC_PROMOS)) {', '            return false;', '        }', '        final @Nullable Account visibleAccount = getVisibleAccount();', '        final AccountManagerFacade accountManagerFacade =', '                AccountManagerFacadeProvider.getInstance();', '        return visibleAccount == null', '                || accountManagerFacade.canOfferExtendedSyncPromos(visibleAccount).or(false);', '    }', '', '    private static boolean canShowSettingsPromo() {', '        SharedPreferencesManager preferencesManager = SharedPreferencesManager.getInstance();', '        boolean isPromoDismissed = preferencesManager.readBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_SETTINGS_PERSONALIZED_DISMISSED, false);', '        return preferencesManager.readInt(', '                       getPromoShowCountPreferenceName(SigninAccessPoint.SETTINGS))', '                < MAX_IMPRESSIONS_SETTINGS', '                && !isPromoDismissed;', '    }', '', '    // Find the visible account for sync promos', '    private static @Nullable Account getVisibleAccount() {', '        final IdentityManager identityManager = IdentityServicesProvider.get().getIdentityManager(', '                Profile.getLastUsedRegularProfile());', '        @Nullable', '        Account visibleAccount = CoreAccountInfo.getAndroidAccountFrom(', '                identityManager.getPrimaryAccountInfo(ConsentLevel.SIGNIN));', '        final AccountManagerFacade accountManagerFacade =', '                AccountManagerFacadeProvider.getInstance();', '        if (visibleAccount == null) {', '            visibleAccount =', '                    AccountUtils.getDefaultAccountIfFulfilled(accountManagerFacade.getAccounts());', '        }', '        return visibleAccount;', '    }', '', '    @VisibleForTesting', '    public static String getPromoShowCountPreferenceName(@AccessPoint int accessPoint) {', '        switch (accessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(BOOKMARKS);', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(NTP);', '            case SigninAccessPoint.SETTINGS:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(SETTINGS);', '            default:', '                throw new IllegalArgumentException(', '                        ""Unexpected value for access point: "" + accessPoint);', '        }', '    }', '', '    /**', '     * Creates a new SigninPromoController.', '     * @param accessPoint Specifies the AccessPoint from which the promo is to be shown.', '     * @param syncConsentActivityLauncher Launcher of {@link SyncConsentActivity}.', '     */', '    public SigninPromoController(', '            @AccessPoint int accessPoint, SyncConsentActivityLauncher syncConsentActivityLauncher) {', '        mAccessPoint = accessPoint;', '        mSyncConsentActivityLauncher = syncConsentActivityLauncher;', '        switch (mAccessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:']}, {'a': ['                mImpressionCountHistogramName = ""Signin.Promo.Other.ShownAfterImpressions"";', '                mContinuedAfterImpressionsHistogramName ='], 'b': ['                mPromoShownAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.ShownAfterImpressions"";', '                mSigninCompletedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Other.CompletedAfterImpressions"";']}, {'a': ['                mDismissedAfterImpressionsHistogramName ='], 'b': ['                mPromoDismissedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Other.DismissedAfterImpressions"";', '                mImpressionCountName =', '                        ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_BOOKMARKS;', '                mImpressionUserActionName = ""Signin_Impression_FromBookmarkManager"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromBookmarkManager"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromBookmarkManager"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromBookmarkManager"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromBookmarkManager"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromBookmarkManager"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED;', '                mImpressionsTilDismissHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilDismiss"";', '                mImpressionsTilSigninButtonsHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilSigninButtons"";', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_bookmarks;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_bookmarks_no_account;', '                break;', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:']}, {'a': ['                mImpressionCountHistogramName = ""Signin.Promo.NTP.ShownAfterImpressions"";', '                mContinuedAfterImpressionsHistogramName ='], 'b': ['                mPromoShownAfterImpressionsHistogramName = ""Signin.Promo.NTP.ShownAfterImpressions"";', '                mSigninCompletedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.NTP.CompletedAfterImpressions"";']}, {'a': ['                mDismissedAfterImpressionsHistogramName ='], 'b': ['                mPromoDismissedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.NTP.DismissedAfterImpressions"";', '                mImpressionCountName = ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_NTP;', '                mImpressionUserActionName = ""Signin_Impression_FromNTPContentSuggestions"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromNTPContentSuggestions"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromNTPContentSuggestions"";', '                mSigninWithDefaultUserActionName =', '                        ""Signin_SigninWithDefault_FromNTPContentSuggestions"";', '                mSigninNotDefaultUserActionName =', '                        ""Signin_SigninNotDefault_FromNTPContentSuggestions"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromNTPContentSuggestions"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_PROMO_DISMISSED;', '                mImpressionsTilDismissHistogramName = null;', '                mImpressionsTilSigninButtonsHistogramName = null;', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.NTPContentSuggestions.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_ntp_content_suggestions;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_ntp_content_suggestions_no_account;', '                break;', '            case SigninAccessPoint.RECENT_TABS:']}, {'a': ['                mImpressionCountHistogramName = ""Signin.Promo.Other.ShownAfterImpressions"";', '                mContinuedAfterImpressionsHistogramName ='], 'b': ['                mPromoShownAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.ShownAfterImpressions"";', '                mSigninCompletedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Other.DismissedAfterImpressions"";']}, {'a': ['                mDismissedAfterImpressionsHistogramName = null;'], 'b': ['                mPromoDismissedAfterImpressionsHistogramName = null;']}, {'ab': ['                // There is no impression limit for Recent Tabs.', '                mImpressionCountName = null;', '                mImpressionUserActionName = ""Signin_Impression_FromRecentTabs"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromRecentTabs"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromRecentTabs"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromRecentTabs"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromRecentTabs"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromRecentTabs"";', '                mSyncPromoDismissedPreferenceTracker = null;', '                mImpressionsTilDismissHistogramName = null;', '                mImpressionsTilSigninButtonsHistogramName = null;', '                mImpressionsTilXButtonHistogramName = null;', '                mDescriptionStringId = R.string.signin_promo_description_recent_tabs;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_recent_tabs_no_account;', '                break;', '            case SigninAccessPoint.SETTINGS:']}, {'a': ['                mImpressionCountHistogramName = ""Signin.Promo.Settings.ShownAfterImpressions"";', '                mContinuedAfterImpressionsHistogramName ='], 'b': ['                mPromoShownAfterImpressionsHistogramName =', '                        ""Signin.Promo.Settings.ShownAfterImpressions"";', '                mSigninCompletedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Settings.CompletedAfterImpressions"";']}, {'a': ['                mDismissedAfterImpressionsHistogramName ='], 'b': ['                mPromoDismissedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Settings.DismissedAfterImpressions"";', '                mImpressionCountName = ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_SETTINGS;', '                mImpressionUserActionName = ""Signin_Impression_FromSettings"";', '                mImpressionWithAccountUserActionName = ""Signin_ImpressionWithAccount_FromSettings"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromSettings"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromSettings"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromSettings"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromSettings"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_SETTINGS_PERSONALIZED_DISMISSED;', '                mImpressionsTilDismissHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilDismiss"";', '                mImpressionsTilSigninButtonsHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilSigninButtons"";', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_settings;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_settings_no_account;', '                break;', '            default:', '                throw new IllegalArgumentException(', '                        ""Unexpected value for access point: "" + mAccessPoint);', '        }', '    }', '', '    /**', '     * Sets up the sync promo view.', '     * @param profileDataCache The {@link ProfileDataCache} that stores profile data.', '     * @param view The {@link PersonalizedSigninPromoView} that should be set up.', '     * @param listener The {@link SigninPromoController.OnDismissListener} to be set to the view.', '     */', '    public void setUpSyncPromoView(ProfileDataCache profileDataCache,', '            PersonalizedSigninPromoView view, SigninPromoController.OnDismissListener listener) {', '        final IdentityManager identityManager = IdentityServicesProvider.get().getIdentityManager(', '                Profile.getLastUsedRegularProfile());', '        assert !identityManager.hasPrimaryAccount(ConsentLevel.SYNC) : ""Sync is already enabled!"";', '', '        final @Nullable Account visibleAccount = getVisibleAccount();', '        // Set up the sync promo', '        if (visibleAccount == null) {', '            setupPromoView(view, /* profileData= */ null, listener);', '            return;', '        }', '        setupPromoView(', '                view, profileDataCache.getProfileDataOrDefault(visibleAccount.name), listener);', '    }', '', '    /**', '     * Called when the signin promo is destroyed.', '     */', '    public void onPromoDestroyed() {', '        if (!mWasDisplayed || mWasUsed || mImpressionsTilDismissHistogramName == null) {', '            return;', '        }', '        RecordHistogram.recordCount100Histogram(', '                mImpressionsTilDismissHistogramName, getNumImpressions());', '    }', '', '    /**', '     * Configures the signin promo view and resets the impression tracker. If this controller has', '     * been previously set up.', '     * @param view The view in which the promo will be added.', '     * @param profileData If not null, the promo will be configured to be in the hot state, using', '     *         the account image, email and full name of the user to set the picture and the text of', '     *         the promo appropriately. Otherwise, the promo will be in the cold state.', '     * @param onDismissListener Listener which handles the action of dismissing the promo. A null', '     *         onDismissListener marks that the promo is not dismissible and as a result the close', '     *         button is hidden.', '     */', '    private void setupPromoView(PersonalizedSigninPromoView view,', '            final @Nullable DisplayableProfileData profileData,', '            final @Nullable OnDismissListener onDismissListener) {', '        if (mImpressionTracker != null) {', '            mImpressionTracker.setListener(null);', '            mImpressionTracker = null;', '        }', '        mImpressionTracker = new ImpressionTracker(view);', '        mImpressionTracker.setListener(', '                new OneShotImpressionListener(this::recordSigninPromoImpression));', '', '        mProfileData = profileData;', '        mWasDisplayed = true;', '        if (mProfileData == null) {', '            setupColdState(view);', '        } else {', '            setupHotState(view);', '        }', '', '        if (onDismissListener != null) {', '            view.getDismissButton().setVisibility(View.VISIBLE);', '            view.getDismissButton().setOnClickListener(promoView -> {', '                assert mImpressionsTilXButtonHistogramName != null;', '                assert mSyncPromoDismissedPreferenceTracker != null;', '                mWasUsed = true;', '                RecordHistogram.recordCount100Histogram(', '                        mImpressionsTilXButtonHistogramName, getNumImpressions());', '                SharedPreferencesManager.getInstance().writeBoolean(', '                        mSyncPromoDismissedPreferenceTracker, true);']}, {'a': ['                RecordHistogram.recordExactLinearHistogram(mDismissedAfterImpressionsHistogramName,'], 'b': ['                RecordHistogram.recordExactLinearHistogram(', '                        mPromoDismissedAfterImpressionsHistogramName,']}, {'ab': ['                        SharedPreferencesManager.getInstance().readInt(', '                                ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT),', '                        MAX_TOTAL_PROMO_SHOW_COUNT);', '                onDismissListener.onDismiss();', '            });', '        } else {', '            view.getDismissButton().setVisibility(View.GONE);', '        }', '    }', '', '    /**', ""     * Should be called when the view is not in use anymore (e.g. it's being recycled)."", '     */', '    public void detach() {', '        if (mImpressionTracker != null) {', '            mImpressionTracker.setListener(null);', '            mImpressionTracker = null;', '        }', '    }', '']}, {'a': ['    /** Increases promo show count by one. */', '    public void increasePromoShowCount() {'], 'b': ['    /** Increments promo show count by one and records histogram. */', '    public void incrementAndRecordPromoShowCount() {']}, {'ab': ['        if (mAccessPoint != SigninAccessPoint.RECENT_TABS) {', '            SharedPreferencesManager.getInstance().incrementInt(', '                    getPromoShowCountPreferenceName(mAccessPoint));', '        }']}, {'a': ['        SharedPreferencesManager.getInstance().incrementInt('], 'b': ['        int totalPromoShowCount = SharedPreferencesManager.getInstance().incrementInt(']}, {'ab': ['                ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT);']}, {'a': ['        recordImpressionCountHistogram(mImpressionCountHistogramName);'], 'b': ['        RecordHistogram.recordExactLinearHistogram(mPromoShownAfterImpressionsHistogramName,', '                totalPromoShowCount, MAX_TOTAL_PROMO_SHOW_COUNT);']}, {'ab': ['', '        if (mAccessPoint == SigninAccessPoint.NTP_CONTENT_SUGGESTIONS) {', '            final long currentTime = System.currentTimeMillis();', '            if (SharedPreferencesManager.getInstance().readLong(', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME)', '                    == 0) {', '                SharedPreferencesManager.getInstance().writeLong(', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME, currentTime);', '            }', '            SharedPreferencesManager.getInstance().writeLong(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME, currentTime);', '        }', '    }', '', '    private void setupColdState(PersonalizedSigninPromoView view) {', '        final Context context = view.getContext();', '        view.getImage().setImageResource(R.drawable.chrome_sync_logo);', '        setImageSize(context, view, R.dimen.signin_promo_cold_state_image_size);', '', '        view.getDescription().setText(mDescriptionStringIdNoAccount);', '', '        view.getPrimaryButton().setText(R.string.sync_promo_turn_on_sync);', '        view.getPrimaryButton().setOnClickListener(v -> signinWithNewAccount(context));', '', '        view.getSecondaryButton().setVisibility(View.GONE);', '    }', '', '    private void setupHotState(PersonalizedSigninPromoView view) {', '        final Context context = view.getContext();', '        Drawable accountImage = mProfileData.getImage();', '        view.getImage().setImageDrawable(accountImage);', '        setImageSize(context, view, R.dimen.signin_promo_account_image_size);', '', '        view.getDescription().setText(mDescriptionStringId);', '', '        view.getPrimaryButton().setOnClickListener(v -> signinWithDefaultAccount(context));', '        if (IdentityServicesProvider.get()', '                        .getIdentityManager(Profile.getLastUsedRegularProfile())', '                        .hasPrimaryAccount(ConsentLevel.SIGNIN)) {', '            view.getPrimaryButton().setText(R.string.sync_promo_turn_on_sync);', '            view.getSecondaryButton().setVisibility(View.GONE);', '        } else {', '            final String primaryButtonText =', '                    ChromeFeatureList.isEnabled(', '                            ChromeFeatureList.MOBILE_IDENTITY_CONSISTENCY_PROMOS)', '                    ? context.getString(R.string.signin_promo_continue_as,', '                            mProfileData.getGivenNameOrFullNameOrEmail())', '                    : context.getString(R.string.sync_promo_turn_on_sync);', '            view.getPrimaryButton().setText(primaryButtonText);', '', '            view.getSecondaryButton().setText(R.string.signin_promo_choose_another_account);', '            view.getSecondaryButton().setOnClickListener(v -> signinWithNotDefaultAccount(context));', '            view.getSecondaryButton().setVisibility(View.VISIBLE);', '        }', '    }', '', '    private int getNumImpressions() {', '        return SharedPreferencesManager.getInstance().readInt(mImpressionCountName);', '    }', '', '    private void signinWithNewAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninNewAccountUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoAddAccountFlow(context, mAccessPoint);', '    }', '', '    private void signinWithDefaultAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninWithDefaultUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoDefaultFlow(', '                context, mAccessPoint, mProfileData.getAccountEmail());', '    }', '', '    private void signinWithNotDefaultAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninNotDefaultUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoChooseAccountFlow(', '                context, mAccessPoint, mProfileData.getAccountEmail());', '    }', '', '    private void recordSigninButtonUsed() {', '        mWasUsed = true;']}, {'a': ['        recordImpressionCountHistogram(mContinuedAfterImpressionsHistogramName);'], 'b': ['        RecordHistogram.recordExactLinearHistogram(mSigninCompletedAfterImpressionsHistogramName,', '                SharedPreferencesManager.getInstance().readInt(', '                        ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT),', '                MAX_TOTAL_PROMO_SHOW_COUNT);']}, {'ab': ['        if (mImpressionsTilSigninButtonsHistogramName != null) {', '            RecordHistogram.recordCount100Histogram(', '                    mImpressionsTilSigninButtonsHistogramName, getNumImpressions());', '        }', '    }', '']}, {'a': ['    private void recordImpressionCountHistogram(String histogramName) {', '        RecordHistogram.recordExactLinearHistogram(histogramName,', '                SharedPreferencesManager.getInstance().readInt(', '                        ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT),', '                MAX_TOTAL_PROMO_SHOW_COUNT);', '    }', '']}, {'ab': ['    private void setImageSize(', '            Context context, PersonalizedSigninPromoView view, @DimenRes int dimenResId) {', '        ViewGroup.LayoutParams layoutParams = view.getImage().getLayoutParams();', '        layoutParams.height = context.getResources().getDimensionPixelSize(dimenResId);', '        layoutParams.width = context.getResources().getDimensionPixelSize(dimenResId);', '        view.getImage().setLayoutParams(layoutParams);', '    }', '', '    private void recordSigninPromoImpression() {', '        RecordUserAction.record(mImpressionUserActionName);', '        if (mProfileData == null) {', '            RecordUserAction.record(mImpressionWithNoAccountUserActionName);', '        } else {', '            RecordUserAction.record(mImpressionWithAccountUserActionName);', '        }', '', '        // If mImpressionCountName is not null then we should record impressions.', '        if (mImpressionCountName != null) {', '            SharedPreferencesManager.getInstance().incrementInt(mImpressionCountName);', '        }', '    }', '', '    @VisibleForTesting', '    public static void setPrefSigninPromoDeclinedBookmarksForTests(boolean isDeclined) {', '        SharedPreferencesManager.getInstance().writeBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED, isDeclined);', '    }', '', '    @VisibleForTesting', '    public static int getMaxImpressionsBookmarksForTests() {', '        return MAX_IMPRESSIONS_BOOKMARKS;', '    }', '}', '']}]",chromium%2Fsrc~main~I23061b243395b039a3757d5b40679f388a32c23f,97363eb0c10c319576ce1a603edacd13f5a76464,chrome/browser/signin/ui/android/java/src/org/chromium/chrome/browser/signin/ui/SigninPromoController.java,6395c650_38152d5e_before.java,6395c650_38152d5e_after.java,SigninPromoController::SigninPromoController,True,True
15,3ab64ce2_e0a82ea8,305.0,I have renamed it to mImpressionCountHistogramName,305.0,305.0,"[{'ab': ['// Copyright 2017 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.signin.ui;', '', 'import android.accounts.Account;', 'import android.content.Context;', 'import android.graphics.drawable.Drawable;', 'import android.text.format.DateUtils;', 'import android.view.View;', 'import android.view.ViewGroup;', '', 'import androidx.annotation.DimenRes;', 'import androidx.annotation.Nullable;', 'import androidx.annotation.StringRes;', 'import androidx.annotation.VisibleForTesting;', '', 'import org.chromium.base.metrics.RecordHistogram;', 'import org.chromium.base.metrics.RecordUserAction;', 'import org.chromium.chrome.browser.flags.ChromeFeatureList;', 'import org.chromium.chrome.browser.preferences.ChromePreferenceKeys;', 'import org.chromium.chrome.browser.preferences.SharedPreferencesManager;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.signin.services.DisplayableProfileData;', 'import org.chromium.chrome.browser.signin.services.IdentityServicesProvider;', 'import org.chromium.chrome.browser.signin.services.ProfileDataCache;', 'import org.chromium.chrome.browser.signin.ui.SyncConsentActivityLauncher.AccessPoint;', 'import org.chromium.chrome.features.start_surface.StartSurfaceConfiguration;', 'import org.chromium.components.browser_ui.widget.impression.ImpressionTracker;', 'import org.chromium.components.browser_ui.widget.impression.OneShotImpressionListener;', 'import org.chromium.components.signin.AccountManagerFacade;', 'import org.chromium.components.signin.AccountManagerFacadeProvider;', 'import org.chromium.components.signin.AccountUtils;', 'import org.chromium.components.signin.base.CoreAccountInfo;', 'import org.chromium.components.signin.identitymanager.ConsentLevel;', 'import org.chromium.components.signin.identitymanager.IdentityManager;', 'import org.chromium.components.signin.metrics.SigninAccessPoint;', '', '/**', ' * A controller for configuring the sign in promo. It sets up the sign in promo depending on the', ' * context: whether there are any Google accounts on the device which have been previously signed in', ' * or not. The controller also takes care of counting impressions, recording signin related user', ' * actions and histograms.', ' */', 'public class SigninPromoController {', '    /**', '     * Receives notifications when user clicks close button in the promo.', '     */', '    public interface OnDismissListener {', '        /**', '         * Action to be performed when the promo is being dismissed.', '         */', '        void onDismiss();', '    }', '', '    private static final int MAX_TOTAL_PROMO_SHOW_COUNT = 100;', '    private static final int MAX_IMPRESSIONS_BOOKMARKS = 20;', '    private static final int MAX_IMPRESSIONS_SETTINGS = 20;', '', '    /** Suffix strings for promo shown count preference. */', '    private static final String BOOKMARKS = ""Bookmarks"";', '    private static final String NTP = ""Ntp"";']}, {'b': ['    private static final String RECENT_TABS = ""RecentTabs"";']}, {'ab': ['    private static final String SETTINGS = ""Settings"";', '', '    private @Nullable DisplayableProfileData mProfileData;', '    private @Nullable ImpressionTracker mImpressionTracker;', '    private final @AccessPoint int mAccessPoint;']}, {'a': ['    private final String mImpressionCountHistogramName;', '    private final String mContinuedAfterImpressionsHistogramName;', '    private final String mDismissedAfterImpressionsHistogramName;'], 'b': ['    private final String mPromoShownAfterImpressionsHistogramName;', '    private final String mSigninCompletedAfterImpressionsHistogramName;', '    private final String mPromoDismissedAfterImpressionsHistogramName;']}, {'ab': ['    // TODO(https://crbug.com/1254399): Remove this field. This is over counted.', '    private final @Nullable String mImpressionCountName;', '    private final String mImpressionUserActionName;', '    private final String mImpressionWithAccountUserActionName;', '    private final String mImpressionWithNoAccountUserActionName;', '    private final String mSigninWithDefaultUserActionName;', '    private final String mSigninNotDefaultUserActionName;', '    private final String mSigninNewAccountUserActionName;', '    private final @Nullable String mSyncPromoDismissedPreferenceTracker;']}, {'a': ['    // TODO(https://crbug.com/1254399): Remove these fields related to impressions.']}, {'ab': ['    private final @Nullable String mImpressionsTilDismissHistogramName;', '    private final @Nullable String mImpressionsTilSigninButtonsHistogramName;', '    private final @Nullable String mImpressionsTilXButtonHistogramName;', '    private final @StringRes int mDescriptionStringId;', '    private final @StringRes int mDescriptionStringIdNoAccount;', '    private final SyncConsentActivityLauncher mSyncConsentActivityLauncher;', '    private boolean mWasDisplayed;', '    private boolean mWasUsed;', '', '    /**', '     * Determines whether the Sync promo can be shown.', '     * @param accessPoint The access point for which the impression limit is being checked.', '     */', '    public static boolean canShowSyncPromo(@AccessPoint int accessPoint) {', '        switch (accessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                return canShowBookmarkPromo();', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                return canShowNTPPromo();', '            case SigninAccessPoint.RECENT_TABS:', '                // There is no impression limit or dismiss button in Recent Tabs promo.', '                return true;', '            case SigninAccessPoint.SETTINGS:', '                return canShowSettingsPromo();', '            default:', '                assert false : ""Unexpected value for access point: "" + accessPoint;', '                return false;', '        }', '    }', '', '    /**', '     * If the signin promo card has been hidden for longer than the {@link', '     * StartSurfaceConfiguration#SIGNIN_PROMO_NTP_RESET_AFTER_HOURS}, resets the impression counts,', '     * {@link ChromePreferenceKeys#SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME} and {@link', '     * ChromePreferenceKeys#SIGNIN_PROMO_NTP_LAST_SHOWN_TIME} to allow the promo card to show again.', '     */', '    public static void resetNTPSyncPromoLimitsIfHiddenForTooLong() {', '        final long currentTime = System.currentTimeMillis();', '        final long resetAfterMs =', '                StartSurfaceConfiguration.SIGNIN_PROMO_NTP_RESET_AFTER_HOURS.getValue()', '                * DateUtils.HOUR_IN_MILLIS;', '        final long lastShownTime = SharedPreferencesManager.getInstance().readLong(', '                ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME, 0L);', '        if (resetAfterMs <= 0 || lastShownTime <= 0) return;', '', '        if (currentTime - lastShownTime >= resetAfterMs) {', '            SharedPreferencesManager.getInstance().writeInt(', '                    getPromoShowCountPreferenceName(SigninAccessPoint.NTP_CONTENT_SUGGESTIONS), 0);', '            SharedPreferencesManager.getInstance().removeKey(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME);', '            SharedPreferencesManager.getInstance().removeKey(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME);', '        }', '    }', '', '    private static boolean canShowBookmarkPromo() {', '        boolean isPromoDismissed = SharedPreferencesManager.getInstance().readBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED, false);', '        return SharedPreferencesManager.getInstance().readInt(', '                       getPromoShowCountPreferenceName(SigninAccessPoint.BOOKMARK_MANAGER))', '                < MAX_IMPRESSIONS_BOOKMARKS', '                && !isPromoDismissed;', '    }', '', '    private static boolean timeElapsedSinceFirstShownExceedsLimit() {', '        final long timeSinceFirstShownLimitMs =', '                StartSurfaceConfiguration.SIGNIN_PROMO_NTP_SINCE_FIRST_TIME_SHOWN_LIMIT_HOURS', '                        .getValue()', '                * DateUtils.HOUR_IN_MILLIS;', '        if (timeSinceFirstShownLimitMs <= 0) return false;', '', '        final long currentTime = System.currentTimeMillis();', '        final long firstShownTime = SharedPreferencesManager.getInstance().readLong(', '                ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME, 0L);', '        return firstShownTime > 0 && currentTime - firstShownTime >= timeSinceFirstShownLimitMs;', '    }', '', '    private static boolean canShowNTPPromo() {', '        int maxImpressions = ChromeFeatureList.getFieldTrialParamByFeatureAsInt(', '                ChromeFeatureList.ENHANCED_PROTECTION_PROMO_CARD, ""MaxSigninPromoImpressions"",', '                Integer.MAX_VALUE);', '        if (SharedPreferencesManager.getInstance().readInt(', '                    getPromoShowCountPreferenceName(SigninAccessPoint.NTP_CONTENT_SUGGESTIONS))', '                        >= maxImpressions', '                || timeElapsedSinceFirstShownExceedsLimit()) {', '            return false;', '        }', '', '        if (SharedPreferencesManager.getInstance().readBoolean(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_PROMO_DISMISSED, false)) {', '            return false;', '        }', '', '        if (ChromeFeatureList.isEnabled(ChromeFeatureList.FORCE_DISABLE_EXTENDED_SYNC_PROMOS)) {', '            return false;', '        }', '        final @Nullable Account visibleAccount = getVisibleAccount();', '        final AccountManagerFacade accountManagerFacade =', '                AccountManagerFacadeProvider.getInstance();', '        return visibleAccount == null', '                || accountManagerFacade.canOfferExtendedSyncPromos(visibleAccount).or(false);', '    }', '', '    private static boolean canShowSettingsPromo() {', '        SharedPreferencesManager preferencesManager = SharedPreferencesManager.getInstance();', '        boolean isPromoDismissed = preferencesManager.readBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_SETTINGS_PERSONALIZED_DISMISSED, false);', '        return preferencesManager.readInt(', '                       getPromoShowCountPreferenceName(SigninAccessPoint.SETTINGS))', '                < MAX_IMPRESSIONS_SETTINGS', '                && !isPromoDismissed;', '    }', '', '    // Find the visible account for sync promos', '    private static @Nullable Account getVisibleAccount() {', '        final IdentityManager identityManager = IdentityServicesProvider.get().getIdentityManager(', '                Profile.getLastUsedRegularProfile());', '        @Nullable', '        Account visibleAccount = CoreAccountInfo.getAndroidAccountFrom(', '                identityManager.getPrimaryAccountInfo(ConsentLevel.SIGNIN));', '        final AccountManagerFacade accountManagerFacade =', '                AccountManagerFacadeProvider.getInstance();', '        if (visibleAccount == null) {', '            visibleAccount =', '                    AccountUtils.getDefaultAccountIfFulfilled(accountManagerFacade.getAccounts());', '        }', '        return visibleAccount;', '    }', '', '    @VisibleForTesting', '    public static String getPromoShowCountPreferenceName(@AccessPoint int accessPoint) {', '        switch (accessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(BOOKMARKS);', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(NTP);', '            case SigninAccessPoint.SETTINGS:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(SETTINGS);', '            default:', '                throw new IllegalArgumentException(', '                        ""Unexpected value for access point: "" + accessPoint);', '        }', '    }', '', '    /**', '     * Creates a new SigninPromoController.', '     * @param accessPoint Specifies the AccessPoint from which the promo is to be shown.', '     * @param syncConsentActivityLauncher Launcher of {@link SyncConsentActivity}.', '     */', '    public SigninPromoController(', '            @AccessPoint int accessPoint, SyncConsentActivityLauncher syncConsentActivityLauncher) {', '        mAccessPoint = accessPoint;', '        mSyncConsentActivityLauncher = syncConsentActivityLauncher;', '        switch (mAccessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:']}, {'a': ['                mImpressionCountHistogramName = ""Signin.Promo.Other.ShownAfterImpressions"";', '                mContinuedAfterImpressionsHistogramName ='], 'b': ['                mPromoShownAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.ShownAfterImpressions"";', '                mSigninCompletedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Other.CompletedAfterImpressions"";']}, {'a': ['                mDismissedAfterImpressionsHistogramName ='], 'b': ['                mPromoDismissedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Other.DismissedAfterImpressions"";', '                mImpressionCountName =', '                        ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_BOOKMARKS;', '                mImpressionUserActionName = ""Signin_Impression_FromBookmarkManager"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromBookmarkManager"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromBookmarkManager"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromBookmarkManager"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromBookmarkManager"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromBookmarkManager"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED;', '                mImpressionsTilDismissHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilDismiss"";', '                mImpressionsTilSigninButtonsHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilSigninButtons"";', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_bookmarks;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_bookmarks_no_account;', '                break;', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:']}, {'a': ['                mImpressionCountHistogramName = ""Signin.Promo.NTP.ShownAfterImpressions"";', '                mContinuedAfterImpressionsHistogramName ='], 'b': ['                mPromoShownAfterImpressionsHistogramName = ""Signin.Promo.NTP.ShownAfterImpressions"";', '                mSigninCompletedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.NTP.CompletedAfterImpressions"";']}, {'a': ['                mDismissedAfterImpressionsHistogramName ='], 'b': ['                mPromoDismissedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.NTP.DismissedAfterImpressions"";', '                mImpressionCountName = ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_NTP;', '                mImpressionUserActionName = ""Signin_Impression_FromNTPContentSuggestions"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromNTPContentSuggestions"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromNTPContentSuggestions"";', '                mSigninWithDefaultUserActionName =', '                        ""Signin_SigninWithDefault_FromNTPContentSuggestions"";', '                mSigninNotDefaultUserActionName =', '                        ""Signin_SigninNotDefault_FromNTPContentSuggestions"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromNTPContentSuggestions"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_PROMO_DISMISSED;', '                mImpressionsTilDismissHistogramName = null;', '                mImpressionsTilSigninButtonsHistogramName = null;', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.NTPContentSuggestions.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_ntp_content_suggestions;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_ntp_content_suggestions_no_account;', '                break;', '            case SigninAccessPoint.RECENT_TABS:']}, {'a': ['                mImpressionCountHistogramName = ""Signin.Promo.Other.ShownAfterImpressions"";', '                mContinuedAfterImpressionsHistogramName ='], 'b': ['                mPromoShownAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.ShownAfterImpressions"";', '                mSigninCompletedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Other.DismissedAfterImpressions"";']}, {'a': ['                mDismissedAfterImpressionsHistogramName = null;'], 'b': ['                mPromoDismissedAfterImpressionsHistogramName = null;']}, {'ab': ['                // There is no impression limit for Recent Tabs.', '                mImpressionCountName = null;', '                mImpressionUserActionName = ""Signin_Impression_FromRecentTabs"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromRecentTabs"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromRecentTabs"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromRecentTabs"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromRecentTabs"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromRecentTabs"";', '                mSyncPromoDismissedPreferenceTracker = null;', '                mImpressionsTilDismissHistogramName = null;', '                mImpressionsTilSigninButtonsHistogramName = null;', '                mImpressionsTilXButtonHistogramName = null;', '                mDescriptionStringId = R.string.signin_promo_description_recent_tabs;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_recent_tabs_no_account;', '                break;', '            case SigninAccessPoint.SETTINGS:']}, {'a': ['                mImpressionCountHistogramName = ""Signin.Promo.Settings.ShownAfterImpressions"";', '                mContinuedAfterImpressionsHistogramName ='], 'b': ['                mPromoShownAfterImpressionsHistogramName =', '                        ""Signin.Promo.Settings.ShownAfterImpressions"";', '                mSigninCompletedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Settings.CompletedAfterImpressions"";']}, {'a': ['                mDismissedAfterImpressionsHistogramName ='], 'b': ['                mPromoDismissedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Settings.DismissedAfterImpressions"";', '                mImpressionCountName = ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_SETTINGS;', '                mImpressionUserActionName = ""Signin_Impression_FromSettings"";', '                mImpressionWithAccountUserActionName = ""Signin_ImpressionWithAccount_FromSettings"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromSettings"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromSettings"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromSettings"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromSettings"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_SETTINGS_PERSONALIZED_DISMISSED;', '                mImpressionsTilDismissHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilDismiss"";', '                mImpressionsTilSigninButtonsHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilSigninButtons"";', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_settings;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_settings_no_account;', '                break;', '            default:', '                throw new IllegalArgumentException(', '                        ""Unexpected value for access point: "" + mAccessPoint);', '        }', '    }', '', '    /**', '     * Sets up the sync promo view.', '     * @param profileDataCache The {@link ProfileDataCache} that stores profile data.', '     * @param view The {@link PersonalizedSigninPromoView} that should be set up.', '     * @param listener The {@link SigninPromoController.OnDismissListener} to be set to the view.', '     */', '    public void setUpSyncPromoView(ProfileDataCache profileDataCache,', '            PersonalizedSigninPromoView view, SigninPromoController.OnDismissListener listener) {', '        final IdentityManager identityManager = IdentityServicesProvider.get().getIdentityManager(', '                Profile.getLastUsedRegularProfile());', '        assert !identityManager.hasPrimaryAccount(ConsentLevel.SYNC) : ""Sync is already enabled!"";', '', '        final @Nullable Account visibleAccount = getVisibleAccount();', '        // Set up the sync promo', '        if (visibleAccount == null) {', '            setupPromoView(view, /* profileData= */ null, listener);', '            return;', '        }', '        setupPromoView(', '                view, profileDataCache.getProfileDataOrDefault(visibleAccount.name), listener);', '    }', '', '    /**', '     * Called when the signin promo is destroyed.', '     */', '    public void onPromoDestroyed() {', '        if (!mWasDisplayed || mWasUsed || mImpressionsTilDismissHistogramName == null) {', '            return;', '        }', '        RecordHistogram.recordCount100Histogram(', '                mImpressionsTilDismissHistogramName, getNumImpressions());', '    }', '', '    /**', '     * Configures the signin promo view and resets the impression tracker. If this controller has', '     * been previously set up.', '     * @param view The view in which the promo will be added.', '     * @param profileData If not null, the promo will be configured to be in the hot state, using', '     *         the account image, email and full name of the user to set the picture and the text of', '     *         the promo appropriately. Otherwise, the promo will be in the cold state.', '     * @param onDismissListener Listener which handles the action of dismissing the promo. A null', '     *         onDismissListener marks that the promo is not dismissible and as a result the close', '     *         button is hidden.', '     */', '    private void setupPromoView(PersonalizedSigninPromoView view,', '            final @Nullable DisplayableProfileData profileData,', '            final @Nullable OnDismissListener onDismissListener) {', '        if (mImpressionTracker != null) {', '            mImpressionTracker.setListener(null);', '            mImpressionTracker = null;', '        }', '        mImpressionTracker = new ImpressionTracker(view);', '        mImpressionTracker.setListener(', '                new OneShotImpressionListener(this::recordSigninPromoImpression));', '', '        mProfileData = profileData;', '        mWasDisplayed = true;', '        if (mProfileData == null) {', '            setupColdState(view);', '        } else {', '            setupHotState(view);', '        }', '', '        if (onDismissListener != null) {', '            view.getDismissButton().setVisibility(View.VISIBLE);', '            view.getDismissButton().setOnClickListener(promoView -> {', '                assert mImpressionsTilXButtonHistogramName != null;', '                assert mSyncPromoDismissedPreferenceTracker != null;', '                mWasUsed = true;', '                RecordHistogram.recordCount100Histogram(', '                        mImpressionsTilXButtonHistogramName, getNumImpressions());', '                SharedPreferencesManager.getInstance().writeBoolean(', '                        mSyncPromoDismissedPreferenceTracker, true);']}, {'a': ['                RecordHistogram.recordExactLinearHistogram(mDismissedAfterImpressionsHistogramName,'], 'b': ['                RecordHistogram.recordExactLinearHistogram(', '                        mPromoDismissedAfterImpressionsHistogramName,']}, {'ab': ['                        SharedPreferencesManager.getInstance().readInt(', '                                ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT),', '                        MAX_TOTAL_PROMO_SHOW_COUNT);', '                onDismissListener.onDismiss();', '            });', '        } else {', '            view.getDismissButton().setVisibility(View.GONE);', '        }', '    }', '', '    /**', ""     * Should be called when the view is not in use anymore (e.g. it's being recycled)."", '     */', '    public void detach() {', '        if (mImpressionTracker != null) {', '            mImpressionTracker.setListener(null);', '            mImpressionTracker = null;', '        }', '    }', '']}, {'a': ['    /** Increases promo show count by one. */', '    public void increasePromoShowCount() {'], 'b': ['    /** Increments promo show count by one and records histogram. */', '    public void incrementAndRecordPromoShowCount() {']}, {'ab': ['        if (mAccessPoint != SigninAccessPoint.RECENT_TABS) {', '            SharedPreferencesManager.getInstance().incrementInt(', '                    getPromoShowCountPreferenceName(mAccessPoint));', '        }']}, {'a': ['        SharedPreferencesManager.getInstance().incrementInt('], 'b': ['        int totalPromoShowCount = SharedPreferencesManager.getInstance().incrementInt(']}, {'ab': ['                ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT);']}, {'a': ['        recordImpressionCountHistogram(mImpressionCountHistogramName);'], 'b': ['        RecordHistogram.recordExactLinearHistogram(mPromoShownAfterImpressionsHistogramName,', '                totalPromoShowCount, MAX_TOTAL_PROMO_SHOW_COUNT);']}, {'ab': ['', '        if (mAccessPoint == SigninAccessPoint.NTP_CONTENT_SUGGESTIONS) {', '            final long currentTime = System.currentTimeMillis();', '            if (SharedPreferencesManager.getInstance().readLong(', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME)', '                    == 0) {', '                SharedPreferencesManager.getInstance().writeLong(', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME, currentTime);', '            }', '            SharedPreferencesManager.getInstance().writeLong(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME, currentTime);', '        }', '    }', '', '    private void setupColdState(PersonalizedSigninPromoView view) {', '        final Context context = view.getContext();', '        view.getImage().setImageResource(R.drawable.chrome_sync_logo);', '        setImageSize(context, view, R.dimen.signin_promo_cold_state_image_size);', '', '        view.getDescription().setText(mDescriptionStringIdNoAccount);', '', '        view.getPrimaryButton().setText(R.string.sync_promo_turn_on_sync);', '        view.getPrimaryButton().setOnClickListener(v -> signinWithNewAccount(context));', '', '        view.getSecondaryButton().setVisibility(View.GONE);', '    }', '', '    private void setupHotState(PersonalizedSigninPromoView view) {', '        final Context context = view.getContext();', '        Drawable accountImage = mProfileData.getImage();', '        view.getImage().setImageDrawable(accountImage);', '        setImageSize(context, view, R.dimen.signin_promo_account_image_size);', '', '        view.getDescription().setText(mDescriptionStringId);', '', '        view.getPrimaryButton().setOnClickListener(v -> signinWithDefaultAccount(context));', '        if (IdentityServicesProvider.get()', '                        .getIdentityManager(Profile.getLastUsedRegularProfile())', '                        .hasPrimaryAccount(ConsentLevel.SIGNIN)) {', '            view.getPrimaryButton().setText(R.string.sync_promo_turn_on_sync);', '            view.getSecondaryButton().setVisibility(View.GONE);', '        } else {', '            final String primaryButtonText =', '                    ChromeFeatureList.isEnabled(', '                            ChromeFeatureList.MOBILE_IDENTITY_CONSISTENCY_PROMOS)', '                    ? context.getString(R.string.signin_promo_continue_as,', '                            mProfileData.getGivenNameOrFullNameOrEmail())', '                    : context.getString(R.string.sync_promo_turn_on_sync);', '            view.getPrimaryButton().setText(primaryButtonText);', '', '            view.getSecondaryButton().setText(R.string.signin_promo_choose_another_account);', '            view.getSecondaryButton().setOnClickListener(v -> signinWithNotDefaultAccount(context));', '            view.getSecondaryButton().setVisibility(View.VISIBLE);', '        }', '    }', '', '    private int getNumImpressions() {', '        return SharedPreferencesManager.getInstance().readInt(mImpressionCountName);', '    }', '', '    private void signinWithNewAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninNewAccountUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoAddAccountFlow(context, mAccessPoint);', '    }', '', '    private void signinWithDefaultAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninWithDefaultUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoDefaultFlow(', '                context, mAccessPoint, mProfileData.getAccountEmail());', '    }', '', '    private void signinWithNotDefaultAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninNotDefaultUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoChooseAccountFlow(', '                context, mAccessPoint, mProfileData.getAccountEmail());', '    }', '', '    private void recordSigninButtonUsed() {', '        mWasUsed = true;']}, {'a': ['        recordImpressionCountHistogram(mContinuedAfterImpressionsHistogramName);'], 'b': ['        RecordHistogram.recordExactLinearHistogram(mSigninCompletedAfterImpressionsHistogramName,', '                SharedPreferencesManager.getInstance().readInt(', '                        ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT),', '                MAX_TOTAL_PROMO_SHOW_COUNT);']}, {'ab': ['        if (mImpressionsTilSigninButtonsHistogramName != null) {', '            RecordHistogram.recordCount100Histogram(', '                    mImpressionsTilSigninButtonsHistogramName, getNumImpressions());', '        }', '    }', '']}, {'a': ['    private void recordImpressionCountHistogram(String histogramName) {', '        RecordHistogram.recordExactLinearHistogram(histogramName,', '                SharedPreferencesManager.getInstance().readInt(', '                        ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT),', '                MAX_TOTAL_PROMO_SHOW_COUNT);', '    }', '']}, {'ab': ['    private void setImageSize(', '            Context context, PersonalizedSigninPromoView view, @DimenRes int dimenResId) {', '        ViewGroup.LayoutParams layoutParams = view.getImage().getLayoutParams();', '        layoutParams.height = context.getResources().getDimensionPixelSize(dimenResId);', '        layoutParams.width = context.getResources().getDimensionPixelSize(dimenResId);', '        view.getImage().setLayoutParams(layoutParams);', '    }', '', '    private void recordSigninPromoImpression() {', '        RecordUserAction.record(mImpressionUserActionName);', '        if (mProfileData == null) {', '            RecordUserAction.record(mImpressionWithNoAccountUserActionName);', '        } else {', '            RecordUserAction.record(mImpressionWithAccountUserActionName);', '        }', '', '        // If mImpressionCountName is not null then we should record impressions.', '        if (mImpressionCountName != null) {', '            SharedPreferencesManager.getInstance().incrementInt(mImpressionCountName);', '        }', '    }', '', '    @VisibleForTesting', '    public static void setPrefSigninPromoDeclinedBookmarksForTests(boolean isDeclined) {', '        SharedPreferencesManager.getInstance().writeBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED, isDeclined);', '    }', '', '    @VisibleForTesting', '    public static int getMaxImpressionsBookmarksForTests() {', '        return MAX_IMPRESSIONS_BOOKMARKS;', '    }', '}', '']}]",chromium%2Fsrc~main~I23061b243395b039a3757d5b40679f388a32c23f,97363eb0c10c319576ce1a603edacd13f5a76464,chrome/browser/signin/ui/android/java/src/org/chromium/chrome/browser/signin/ui/SigninPromoController.java,3ab64ce2_e0a82ea8_before.java,3ab64ce2_e0a82ea8_after.java,SigninPromoController::SigninPromoController,True,True
23,17fd13c1_5c295a5b,239.0,Should we also change the histogram name to Continued..?,239.0,239.0,"[{'ab': ['// Copyright 2017 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.signin.ui;', '', 'import android.accounts.Account;', 'import android.content.Context;', 'import android.graphics.drawable.Drawable;', 'import android.text.format.DateUtils;', 'import android.view.View;', 'import android.view.ViewGroup;', '', 'import androidx.annotation.DimenRes;', 'import androidx.annotation.Nullable;', 'import androidx.annotation.StringRes;', 'import androidx.annotation.VisibleForTesting;', '', 'import org.chromium.base.metrics.RecordHistogram;', 'import org.chromium.base.metrics.RecordUserAction;', 'import org.chromium.chrome.browser.flags.ChromeFeatureList;', 'import org.chromium.chrome.browser.preferences.ChromePreferenceKeys;', 'import org.chromium.chrome.browser.preferences.SharedPreferencesManager;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.signin.services.DisplayableProfileData;', 'import org.chromium.chrome.browser.signin.services.IdentityServicesProvider;', 'import org.chromium.chrome.browser.signin.services.ProfileDataCache;', 'import org.chromium.chrome.browser.signin.ui.SyncConsentActivityLauncher.AccessPoint;', 'import org.chromium.chrome.features.start_surface.StartSurfaceConfiguration;', 'import org.chromium.components.browser_ui.widget.impression.ImpressionTracker;', 'import org.chromium.components.browser_ui.widget.impression.OneShotImpressionListener;', 'import org.chromium.components.signin.AccountManagerFacade;', 'import org.chromium.components.signin.AccountManagerFacadeProvider;', 'import org.chromium.components.signin.AccountUtils;', 'import org.chromium.components.signin.base.CoreAccountInfo;', 'import org.chromium.components.signin.identitymanager.ConsentLevel;', 'import org.chromium.components.signin.identitymanager.IdentityManager;', 'import org.chromium.components.signin.metrics.SigninAccessPoint;', '', '/**', ' * A controller for configuring the sign in promo. It sets up the sign in promo depending on the', ' * context: whether there are any Google accounts on the device which have been previously signed in', ' * or not. The controller also takes care of counting impressions, recording signin related user', ' * actions and histograms.', ' */', 'public class SigninPromoController {', '    /**', '     * Receives notifications when user clicks close button in the promo.', '     */', '    public interface OnDismissListener {', '        /**', '         * Action to be performed when the promo is being dismissed.', '         */', '        void onDismiss();', '    }', '', '    private static final int MAX_TOTAL_PROMO_SHOW_COUNT = 100;', '    private static final int MAX_IMPRESSIONS_BOOKMARKS = 20;', '    private static final int MAX_IMPRESSIONS_SETTINGS = 20;', '', '    /** Suffix strings for promo shown count preference. */', '    private static final String BOOKMARKS = ""Bookmarks"";', '    private static final String NTP = ""Ntp"";', '    private static final String SETTINGS = ""Settings"";', '', '    private @Nullable DisplayableProfileData mProfileData;', '    private @Nullable ImpressionTracker mImpressionTracker;', '    private final @AccessPoint int mAccessPoint;', '    private final String mImpressionCountHistogramName;']}, {'a': ['    private final String mSigninAfterImpressionsHistogramName;'], 'b': ['    private final String mContinuedAfterImpressionsHistogramName;']}, {'ab': ['    private final String mDismissedAfterImpressionsHistogramName;', '    // TODO(https://crbug.com/1254399): Remove this field. This is over counted.', '    private final @Nullable String mImpressionCountName;', '    private final String mImpressionUserActionName;', '    private final String mImpressionWithAccountUserActionName;', '    private final String mImpressionWithNoAccountUserActionName;', '    private final String mSigninWithDefaultUserActionName;', '    private final String mSigninNotDefaultUserActionName;', '    private final String mSigninNewAccountUserActionName;', '    private final @Nullable String mSyncPromoDismissedPreferenceTracker;', '    // TODO(https://crbug.com/1254399): Remove these fields related to impressions.', '    private final @Nullable String mImpressionsTilDismissHistogramName;', '    private final @Nullable String mImpressionsTilSigninButtonsHistogramName;', '    private final @Nullable String mImpressionsTilXButtonHistogramName;', '    private final @StringRes int mDescriptionStringId;', '    private final @StringRes int mDescriptionStringIdNoAccount;', '    private final SyncConsentActivityLauncher mSyncConsentActivityLauncher;', '    private boolean mWasDisplayed;', '    private boolean mWasUsed;', '', '    /**', '     * Determines whether the Sync promo can be shown.', '     * @param accessPoint The access point for which the impression limit is being checked.', '     */', '    public static boolean canShowSyncPromo(@AccessPoint int accessPoint) {', '        switch (accessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                return canShowBookmarkPromo();', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                return canShowNTPPromo();', '            case SigninAccessPoint.RECENT_TABS:', '                // There is no impression limit or dismiss button in Recent Tabs promo.', '                return true;', '            case SigninAccessPoint.SETTINGS:', '                return canShowSettingsPromo();', '            default:', '                assert false : ""Unexpected value for access point: "" + accessPoint;', '                return false;', '        }', '    }', '', '    /**', '     * If the signin promo card has been hidden for longer than the {@link', '     * StartSurfaceConfiguration#SIGNIN_PROMO_NTP_RESET_AFTER_HOURS}, resets the impression counts,', '     * {@link ChromePreferenceKeys#SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME} and {@link', '     * ChromePreferenceKeys#SIGNIN_PROMO_NTP_LAST_SHOWN_TIME} to allow the promo card to show again.', '     */', '    public static void resetNTPSyncPromoLimitsIfHiddenForTooLong() {', '        final long currentTime = System.currentTimeMillis();', '        final long resetAfterMs =', '                StartSurfaceConfiguration.SIGNIN_PROMO_NTP_RESET_AFTER_HOURS.getValue()', '                * DateUtils.HOUR_IN_MILLIS;', '        final long lastShownTime = SharedPreferencesManager.getInstance().readLong(', '                ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME, 0L);', '        if (resetAfterMs <= 0 || lastShownTime <= 0) return;', '', '        if (currentTime - lastShownTime >= resetAfterMs) {', '            SharedPreferencesManager.getInstance().writeInt(', '                    getPromoShowCountPreferenceName(SigninAccessPoint.NTP_CONTENT_SUGGESTIONS), 0);', '            SharedPreferencesManager.getInstance().removeKey(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME);', '            SharedPreferencesManager.getInstance().removeKey(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME);', '        }', '    }', '', '    private static boolean canShowBookmarkPromo() {', '        boolean isPromoDismissed = SharedPreferencesManager.getInstance().readBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED, false);', '        return SharedPreferencesManager.getInstance().readInt(', '                       getPromoShowCountPreferenceName(SigninAccessPoint.BOOKMARK_MANAGER))', '                < MAX_IMPRESSIONS_BOOKMARKS', '                && !isPromoDismissed;', '    }', '', '    private static boolean timeElapsedSinceFirstShownExceedsLimit() {', '        final long timeSinceFirstShownLimitMs =', '                StartSurfaceConfiguration.SIGNIN_PROMO_NTP_SINCE_FIRST_TIME_SHOWN_LIMIT_HOURS', '                        .getValue()', '                * DateUtils.HOUR_IN_MILLIS;', '        if (timeSinceFirstShownLimitMs <= 0) return false;', '', '        final long currentTime = System.currentTimeMillis();', '        final long firstShownTime = SharedPreferencesManager.getInstance().readLong(', '                ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME, 0L);', '        return firstShownTime > 0 && currentTime - firstShownTime >= timeSinceFirstShownLimitMs;', '    }', '', '    private static boolean canShowNTPPromo() {', '        int maxImpressions = ChromeFeatureList.getFieldTrialParamByFeatureAsInt(', '                ChromeFeatureList.ENHANCED_PROTECTION_PROMO_CARD, ""MaxSigninPromoImpressions"",', '                Integer.MAX_VALUE);', '        if (SharedPreferencesManager.getInstance().readInt(', '                    getPromoShowCountPreferenceName(SigninAccessPoint.NTP_CONTENT_SUGGESTIONS))', '                        >= maxImpressions', '                || timeElapsedSinceFirstShownExceedsLimit()) {', '            return false;', '        }', '', '        if (SharedPreferencesManager.getInstance().readBoolean(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_PROMO_DISMISSED, false)) {', '            return false;', '        }', '', '        if (ChromeFeatureList.isEnabled(ChromeFeatureList.FORCE_DISABLE_EXTENDED_SYNC_PROMOS)) {', '            return false;', '        }', '        final @Nullable Account visibleAccount = getVisibleAccount();', '        final AccountManagerFacade accountManagerFacade =', '                AccountManagerFacadeProvider.getInstance();', '        return visibleAccount == null', '                || accountManagerFacade.canOfferExtendedSyncPromos(visibleAccount).or(false);', '    }', '', '    private static boolean canShowSettingsPromo() {', '        SharedPreferencesManager preferencesManager = SharedPreferencesManager.getInstance();', '        boolean isPromoDismissed = preferencesManager.readBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_SETTINGS_PERSONALIZED_DISMISSED, false);', '        return preferencesManager.readInt(', '                       getPromoShowCountPreferenceName(SigninAccessPoint.SETTINGS))', '                < MAX_IMPRESSIONS_SETTINGS', '                && !isPromoDismissed;', '    }', '', '    // Find the visible account for sync promos', '    private static @Nullable Account getVisibleAccount() {', '        final IdentityManager identityManager = IdentityServicesProvider.get().getIdentityManager(', '                Profile.getLastUsedRegularProfile());', '        @Nullable', '        Account visibleAccount = CoreAccountInfo.getAndroidAccountFrom(', '                identityManager.getPrimaryAccountInfo(ConsentLevel.SIGNIN));', '        final AccountManagerFacade accountManagerFacade =', '                AccountManagerFacadeProvider.getInstance();', '        if (visibleAccount == null) {', '            visibleAccount =', '                    AccountUtils.getDefaultAccountIfFulfilled(accountManagerFacade.getAccounts());', '        }', '        return visibleAccount;', '    }', '', '    @VisibleForTesting', '    public static String getPromoShowCountPreferenceName(@AccessPoint int accessPoint) {', '        switch (accessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(BOOKMARKS);', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(NTP);', '            case SigninAccessPoint.SETTINGS:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(SETTINGS);', '            default:', '                throw new IllegalArgumentException(', '                        ""Unexpected value for access point: "" + accessPoint);', '        }', '    }', '', '    /**', '     * Creates a new SigninPromoController.', '     * @param accessPoint Specifies the AccessPoint from which the promo is to be shown.', '     * @param syncConsentActivityLauncher Launcher of {@link SyncConsentActivity}.', '     */', '    public SigninPromoController(', '            @AccessPoint int accessPoint, SyncConsentActivityLauncher syncConsentActivityLauncher) {', '        mAccessPoint = accessPoint;', '        mSyncConsentActivityLauncher = syncConsentActivityLauncher;', '        switch (mAccessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                mImpressionCountHistogramName = ""Signin.Promo.Other.ShownAfterImpressions"";']}, {'a': ['                mSigninAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.ContinuedAfterImpressions"";'], 'b': ['                mContinuedAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.CompletedAfterImpressions"";']}, {'ab': ['                mDismissedAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.DismissedAfterImpressions"";', '                mImpressionCountName =', '                        ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_BOOKMARKS;', '                mImpressionUserActionName = ""Signin_Impression_FromBookmarkManager"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromBookmarkManager"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromBookmarkManager"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromBookmarkManager"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromBookmarkManager"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromBookmarkManager"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED;', '                mImpressionsTilDismissHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilDismiss"";', '                mImpressionsTilSigninButtonsHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilSigninButtons"";', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_bookmarks;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_bookmarks_no_account;', '                break;', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                mImpressionCountHistogramName = ""Signin.Promo.NTP.ShownAfterImpressions"";']}, {'a': ['                mSigninAfterImpressionsHistogramName = ""Signin.Promo.NTP.ContinuedAfterImpressions"";'], 'b': ['                mContinuedAfterImpressionsHistogramName =', '                        ""Signin.Promo.NTP.CompletedAfterImpressions"";']}, {'ab': ['                mDismissedAfterImpressionsHistogramName =', '                        ""Signin.Promo.NTP.DismissedAfterImpressions"";', '                mImpressionCountName = ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_NTP;', '                mImpressionUserActionName = ""Signin_Impression_FromNTPContentSuggestions"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromNTPContentSuggestions"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromNTPContentSuggestions"";', '                mSigninWithDefaultUserActionName =', '                        ""Signin_SigninWithDefault_FromNTPContentSuggestions"";', '                mSigninNotDefaultUserActionName =', '                        ""Signin_SigninNotDefault_FromNTPContentSuggestions"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromNTPContentSuggestions"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_PROMO_DISMISSED;', '                mImpressionsTilDismissHistogramName = null;', '                mImpressionsTilSigninButtonsHistogramName = null;', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.NTPContentSuggestions.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_ntp_content_suggestions;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_ntp_content_suggestions_no_account;', '                break;', '            case SigninAccessPoint.RECENT_TABS:', '                mImpressionCountHistogramName = ""Signin.Promo.Other.ShownAfterImpressions"";']}, {'a': ['                mSigninAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.ContinuedAfterImpressions"";', ""                // Recent Tabs promos can't be dismissed.""], 'b': ['                mContinuedAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.DismissedAfterImpressions"";']}, {'ab': ['                mDismissedAfterImpressionsHistogramName = null;', '                // There is no impression limit for Recent Tabs.', '                mImpressionCountName = null;', '                mImpressionUserActionName = ""Signin_Impression_FromRecentTabs"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromRecentTabs"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromRecentTabs"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromRecentTabs"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromRecentTabs"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromRecentTabs"";', '                mSyncPromoDismissedPreferenceTracker = null;', '                mImpressionsTilDismissHistogramName = null;', '                mImpressionsTilSigninButtonsHistogramName = null;', '                mImpressionsTilXButtonHistogramName = null;', '                mDescriptionStringId = R.string.signin_promo_description_recent_tabs;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_recent_tabs_no_account;', '                break;', '            case SigninAccessPoint.SETTINGS:', '                mImpressionCountHistogramName = ""Signin.Promo.Settings.ShownAfterImpressions"";']}, {'a': ['                mSigninAfterImpressionsHistogramName =', '                        ""Signin.Promo.Settings.ContinuedAfterImpressions"";'], 'b': ['                mContinuedAfterImpressionsHistogramName =', '                        ""Signin.Promo.Settings.CompletedAfterImpressions"";']}, {'ab': ['                mDismissedAfterImpressionsHistogramName =', '                        ""Signin.Promo.Settings.DismissedAfterImpressions"";', '                mImpressionCountName = ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_SETTINGS;', '                mImpressionUserActionName = ""Signin_Impression_FromSettings"";', '                mImpressionWithAccountUserActionName = ""Signin_ImpressionWithAccount_FromSettings"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromSettings"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromSettings"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromSettings"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromSettings"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_SETTINGS_PERSONALIZED_DISMISSED;', '                mImpressionsTilDismissHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilDismiss"";', '                mImpressionsTilSigninButtonsHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilSigninButtons"";', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_settings;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_settings_no_account;', '                break;', '            default:', '                throw new IllegalArgumentException(', '                        ""Unexpected value for access point: "" + mAccessPoint);', '        }', '    }', '', '    /**', '     * Sets up the sync promo view.', '     * @param profileDataCache The {@link ProfileDataCache} that stores profile data.', '     * @param view The {@link PersonalizedSigninPromoView} that should be set up.', '     * @param listener The {@link SigninPromoController.OnDismissListener} to be set to the view.', '     */', '    public void setUpSyncPromoView(ProfileDataCache profileDataCache,', '            PersonalizedSigninPromoView view, SigninPromoController.OnDismissListener listener) {', '        final IdentityManager identityManager = IdentityServicesProvider.get().getIdentityManager(', '                Profile.getLastUsedRegularProfile());', '        assert !identityManager.hasPrimaryAccount(ConsentLevel.SYNC) : ""Sync is already enabled!"";', '', '        final @Nullable Account visibleAccount = getVisibleAccount();', '        // Set up the sync promo', '        if (visibleAccount == null) {', '            setupPromoView(view, /* profileData= */ null, listener);', '            return;', '        }', '        setupPromoView(', '                view, profileDataCache.getProfileDataOrDefault(visibleAccount.name), listener);', '    }', '', '    /**', '     * Called when the signin promo is destroyed.', '     */', '    public void onPromoDestroyed() {', '        if (!mWasDisplayed || mWasUsed || mImpressionsTilDismissHistogramName == null) {', '            return;', '        }', '        RecordHistogram.recordCount100Histogram(', '                mImpressionsTilDismissHistogramName, getNumImpressions());', '    }', '', '    /**', '     * Configures the signin promo view and resets the impression tracker. If this controller has', '     * been previously set up.', '     * @param view The view in which the promo will be added.', '     * @param profileData If not null, the promo will be configured to be in the hot state, using', '     *         the account image, email and full name of the user to set the picture and the text of', '     *         the promo appropriately. Otherwise, the promo will be in the cold state.', '     * @param onDismissListener Listener which handles the action of dismissing the promo. A null', '     *         onDismissListener marks that the promo is not dismissible and as a result the close', '     *         button is hidden.', '     */', '    private void setupPromoView(PersonalizedSigninPromoView view,', '            final @Nullable DisplayableProfileData profileData,', '            final @Nullable OnDismissListener onDismissListener) {', '        if (mImpressionTracker != null) {', '            mImpressionTracker.setListener(null);', '            mImpressionTracker = null;', '        }', '        mImpressionTracker = new ImpressionTracker(view);', '        mImpressionTracker.setListener(', '                new OneShotImpressionListener(this::recordSigninPromoImpression));', '', '        mProfileData = profileData;', '        mWasDisplayed = true;', '        if (mProfileData == null) {', '            setupColdState(view);', '        } else {', '            setupHotState(view);', '        }', '', '        if (onDismissListener != null) {', '            view.getDismissButton().setVisibility(View.VISIBLE);', '            view.getDismissButton().setOnClickListener(promoView -> {', '                assert mImpressionsTilXButtonHistogramName != null;', '                assert mSyncPromoDismissedPreferenceTracker != null;', '                mWasUsed = true;', '                RecordHistogram.recordCount100Histogram(', '                        mImpressionsTilXButtonHistogramName, getNumImpressions());', '                SharedPreferencesManager.getInstance().writeBoolean(', '                        mSyncPromoDismissedPreferenceTracker, true);']}, {'a': ['                recordImpressionCountHistogram(mDismissedAfterImpressionsHistogramName);'], 'b': ['                RecordHistogram.recordExactLinearHistogram(mDismissedAfterImpressionsHistogramName,', '                        SharedPreferencesManager.getInstance().readInt(', '                                ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT),', '                        MAX_TOTAL_PROMO_SHOW_COUNT);']}, {'ab': ['                onDismissListener.onDismiss();', '            });', '        } else {', '            view.getDismissButton().setVisibility(View.GONE);', '        }', '    }', '', '    /**', ""     * Should be called when the view is not in use anymore (e.g. it's being recycled)."", '     */', '    public void detach() {', '        if (mImpressionTracker != null) {', '            mImpressionTracker.setListener(null);', '            mImpressionTracker = null;', '        }', '    }', '', '    /** Increases promo show count by one. */', '    public void increasePromoShowCount() {', '        if (mAccessPoint != SigninAccessPoint.RECENT_TABS) {', '            SharedPreferencesManager.getInstance().incrementInt(', '                    getPromoShowCountPreferenceName(mAccessPoint));', '        }', '        SharedPreferencesManager.getInstance().incrementInt(', '                ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT);', '        recordImpressionCountHistogram(mImpressionCountHistogramName);', '', '        if (mAccessPoint == SigninAccessPoint.NTP_CONTENT_SUGGESTIONS) {', '            final long currentTime = System.currentTimeMillis();', '            if (SharedPreferencesManager.getInstance().readLong(', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME)', '                    == 0) {', '                SharedPreferencesManager.getInstance().writeLong(', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME, currentTime);', '            }', '            SharedPreferencesManager.getInstance().writeLong(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME, currentTime);', '        }', '    }', '', '    private void setupColdState(PersonalizedSigninPromoView view) {', '        final Context context = view.getContext();', '        view.getImage().setImageResource(R.drawable.chrome_sync_logo);', '        setImageSize(context, view, R.dimen.signin_promo_cold_state_image_size);', '', '        view.getDescription().setText(mDescriptionStringIdNoAccount);', '', '        view.getPrimaryButton().setText(R.string.sync_promo_turn_on_sync);', '        view.getPrimaryButton().setOnClickListener(v -> signinWithNewAccount(context));', '', '        view.getSecondaryButton().setVisibility(View.GONE);', '    }', '', '    private void setupHotState(PersonalizedSigninPromoView view) {', '        final Context context = view.getContext();', '        Drawable accountImage = mProfileData.getImage();', '        view.getImage().setImageDrawable(accountImage);', '        setImageSize(context, view, R.dimen.signin_promo_account_image_size);', '', '        view.getDescription().setText(mDescriptionStringId);', '', '        view.getPrimaryButton().setOnClickListener(v -> signinWithDefaultAccount(context));', '        if (IdentityServicesProvider.get()', '                        .getIdentityManager(Profile.getLastUsedRegularProfile())', '                        .hasPrimaryAccount(ConsentLevel.SIGNIN)) {', '            view.getPrimaryButton().setText(R.string.sync_promo_turn_on_sync);', '            view.getSecondaryButton().setVisibility(View.GONE);', '        } else {', '            final String primaryButtonText =', '                    ChromeFeatureList.isEnabled(', '                            ChromeFeatureList.MOBILE_IDENTITY_CONSISTENCY_PROMOS)', '                    ? context.getString(R.string.signin_promo_continue_as,', '                            mProfileData.getGivenNameOrFullNameOrEmail())', '                    : context.getString(R.string.sync_promo_turn_on_sync);', '            view.getPrimaryButton().setText(primaryButtonText);', '', '            view.getSecondaryButton().setText(R.string.signin_promo_choose_another_account);', '            view.getSecondaryButton().setOnClickListener(v -> signinWithNotDefaultAccount(context));', '            view.getSecondaryButton().setVisibility(View.VISIBLE);', '        }', '    }', '', '    private int getNumImpressions() {', '        return SharedPreferencesManager.getInstance().readInt(mImpressionCountName);', '    }', '', '    private void signinWithNewAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninNewAccountUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoAddAccountFlow(context, mAccessPoint);', '    }', '', '    private void signinWithDefaultAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninWithDefaultUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoDefaultFlow(', '                context, mAccessPoint, mProfileData.getAccountEmail());', '    }', '', '    private void signinWithNotDefaultAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninNotDefaultUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoChooseAccountFlow(', '                context, mAccessPoint, mProfileData.getAccountEmail());', '    }', '', '    private void recordSigninButtonUsed() {', '        mWasUsed = true;']}, {'a': ['        recordImpressionCountHistogram(mSigninAfterImpressionsHistogramName);'], 'b': ['        recordImpressionCountHistogram(mContinuedAfterImpressionsHistogramName);']}, {'ab': ['        if (mImpressionsTilSigninButtonsHistogramName != null) {', '            RecordHistogram.recordCount100Histogram(', '                    mImpressionsTilSigninButtonsHistogramName, getNumImpressions());', '        }', '    }', '', '    private void recordImpressionCountHistogram(String histogramName) {', '        RecordHistogram.recordExactLinearHistogram(histogramName,', '                SharedPreferencesManager.getInstance().readInt(', '                        ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT),', '                MAX_TOTAL_PROMO_SHOW_COUNT);', '    }', '', '    private void setImageSize(', '            Context context, PersonalizedSigninPromoView view, @DimenRes int dimenResId) {', '        ViewGroup.LayoutParams layoutParams = view.getImage().getLayoutParams();', '        layoutParams.height = context.getResources().getDimensionPixelSize(dimenResId);', '        layoutParams.width = context.getResources().getDimensionPixelSize(dimenResId);', '        view.getImage().setLayoutParams(layoutParams);', '    }', '', '    private void recordSigninPromoImpression() {', '        RecordUserAction.record(mImpressionUserActionName);', '        if (mProfileData == null) {', '            RecordUserAction.record(mImpressionWithNoAccountUserActionName);', '        } else {', '            RecordUserAction.record(mImpressionWithAccountUserActionName);', '        }', '', '        // If mImpressionCountName is not null then we should record impressions.', '        if (mImpressionCountName != null) {', '            SharedPreferencesManager.getInstance().incrementInt(mImpressionCountName);', '        }', '    }', '', '    @VisibleForTesting', '    public static void setPrefSigninPromoDeclinedBookmarksForTests(boolean isDeclined) {', '        SharedPreferencesManager.getInstance().writeBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED, isDeclined);', '    }', '', '    @VisibleForTesting', '    public static int getMaxImpressionsBookmarksForTests() {', '        return MAX_IMPRESSIONS_BOOKMARKS;', '    }', '}', '']}]",chromium%2Fsrc~main~I23061b243395b039a3757d5b40679f388a32c23f,5f2b5ec993951ca0e5215ca0e3464dd173b2176e,chrome/browser/signin/ui/android/java/src/org/chromium/chrome/browser/signin/ui/SigninPromoController.java,17fd13c1_5c295a5b_before.java,17fd13c1_5c295a5b_after.java,SigninPromoController::SigninPromoController,True,True
24,667f3941_7034dd1b,239.0,Done,239.0,239.0,"[{'ab': ['// Copyright 2017 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.signin.ui;', '', 'import android.accounts.Account;', 'import android.content.Context;', 'import android.graphics.drawable.Drawable;', 'import android.text.format.DateUtils;', 'import android.view.View;', 'import android.view.ViewGroup;', '', 'import androidx.annotation.DimenRes;', 'import androidx.annotation.Nullable;', 'import androidx.annotation.StringRes;', 'import androidx.annotation.VisibleForTesting;', '', 'import org.chromium.base.metrics.RecordHistogram;', 'import org.chromium.base.metrics.RecordUserAction;', 'import org.chromium.chrome.browser.flags.ChromeFeatureList;', 'import org.chromium.chrome.browser.preferences.ChromePreferenceKeys;', 'import org.chromium.chrome.browser.preferences.SharedPreferencesManager;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.signin.services.DisplayableProfileData;', 'import org.chromium.chrome.browser.signin.services.IdentityServicesProvider;', 'import org.chromium.chrome.browser.signin.services.ProfileDataCache;', 'import org.chromium.chrome.browser.signin.ui.SyncConsentActivityLauncher.AccessPoint;', 'import org.chromium.chrome.features.start_surface.StartSurfaceConfiguration;', 'import org.chromium.components.browser_ui.widget.impression.ImpressionTracker;', 'import org.chromium.components.browser_ui.widget.impression.OneShotImpressionListener;', 'import org.chromium.components.signin.AccountManagerFacade;', 'import org.chromium.components.signin.AccountManagerFacadeProvider;', 'import org.chromium.components.signin.AccountUtils;', 'import org.chromium.components.signin.base.CoreAccountInfo;', 'import org.chromium.components.signin.identitymanager.ConsentLevel;', 'import org.chromium.components.signin.identitymanager.IdentityManager;', 'import org.chromium.components.signin.metrics.SigninAccessPoint;', '', '/**', ' * A controller for configuring the sign in promo. It sets up the sign in promo depending on the', ' * context: whether there are any Google accounts on the device which have been previously signed in', ' * or not. The controller also takes care of counting impressions, recording signin related user', ' * actions and histograms.', ' */', 'public class SigninPromoController {', '    /**', '     * Receives notifications when user clicks close button in the promo.', '     */', '    public interface OnDismissListener {', '        /**', '         * Action to be performed when the promo is being dismissed.', '         */', '        void onDismiss();', '    }', '', '    private static final int MAX_TOTAL_PROMO_SHOW_COUNT = 100;', '    private static final int MAX_IMPRESSIONS_BOOKMARKS = 20;', '    private static final int MAX_IMPRESSIONS_SETTINGS = 20;', '', '    /** Suffix strings for promo shown count preference. */', '    private static final String BOOKMARKS = ""Bookmarks"";', '    private static final String NTP = ""Ntp"";', '    private static final String SETTINGS = ""Settings"";', '', '    private @Nullable DisplayableProfileData mProfileData;', '    private @Nullable ImpressionTracker mImpressionTracker;', '    private final @AccessPoint int mAccessPoint;', '    private final String mImpressionCountHistogramName;']}, {'a': ['    private final String mSigninAfterImpressionsHistogramName;'], 'b': ['    private final String mContinuedAfterImpressionsHistogramName;']}, {'ab': ['    private final String mDismissedAfterImpressionsHistogramName;', '    // TODO(https://crbug.com/1254399): Remove this field. This is over counted.', '    private final @Nullable String mImpressionCountName;', '    private final String mImpressionUserActionName;', '    private final String mImpressionWithAccountUserActionName;', '    private final String mImpressionWithNoAccountUserActionName;', '    private final String mSigninWithDefaultUserActionName;', '    private final String mSigninNotDefaultUserActionName;', '    private final String mSigninNewAccountUserActionName;', '    private final @Nullable String mSyncPromoDismissedPreferenceTracker;', '    // TODO(https://crbug.com/1254399): Remove these fields related to impressions.', '    private final @Nullable String mImpressionsTilDismissHistogramName;', '    private final @Nullable String mImpressionsTilSigninButtonsHistogramName;', '    private final @Nullable String mImpressionsTilXButtonHistogramName;', '    private final @StringRes int mDescriptionStringId;', '    private final @StringRes int mDescriptionStringIdNoAccount;', '    private final SyncConsentActivityLauncher mSyncConsentActivityLauncher;', '    private boolean mWasDisplayed;', '    private boolean mWasUsed;', '', '    /**', '     * Determines whether the Sync promo can be shown.', '     * @param accessPoint The access point for which the impression limit is being checked.', '     */', '    public static boolean canShowSyncPromo(@AccessPoint int accessPoint) {', '        switch (accessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                return canShowBookmarkPromo();', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                return canShowNTPPromo();', '            case SigninAccessPoint.RECENT_TABS:', '                // There is no impression limit or dismiss button in Recent Tabs promo.', '                return true;', '            case SigninAccessPoint.SETTINGS:', '                return canShowSettingsPromo();', '            default:', '                assert false : ""Unexpected value for access point: "" + accessPoint;', '                return false;', '        }', '    }', '', '    /**', '     * If the signin promo card has been hidden for longer than the {@link', '     * StartSurfaceConfiguration#SIGNIN_PROMO_NTP_RESET_AFTER_HOURS}, resets the impression counts,', '     * {@link ChromePreferenceKeys#SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME} and {@link', '     * ChromePreferenceKeys#SIGNIN_PROMO_NTP_LAST_SHOWN_TIME} to allow the promo card to show again.', '     */', '    public static void resetNTPSyncPromoLimitsIfHiddenForTooLong() {', '        final long currentTime = System.currentTimeMillis();', '        final long resetAfterMs =', '                StartSurfaceConfiguration.SIGNIN_PROMO_NTP_RESET_AFTER_HOURS.getValue()', '                * DateUtils.HOUR_IN_MILLIS;', '        final long lastShownTime = SharedPreferencesManager.getInstance().readLong(', '                ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME, 0L);', '        if (resetAfterMs <= 0 || lastShownTime <= 0) return;', '', '        if (currentTime - lastShownTime >= resetAfterMs) {', '            SharedPreferencesManager.getInstance().writeInt(', '                    getPromoShowCountPreferenceName(SigninAccessPoint.NTP_CONTENT_SUGGESTIONS), 0);', '            SharedPreferencesManager.getInstance().removeKey(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME);', '            SharedPreferencesManager.getInstance().removeKey(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME);', '        }', '    }', '', '    private static boolean canShowBookmarkPromo() {', '        boolean isPromoDismissed = SharedPreferencesManager.getInstance().readBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED, false);', '        return SharedPreferencesManager.getInstance().readInt(', '                       getPromoShowCountPreferenceName(SigninAccessPoint.BOOKMARK_MANAGER))', '                < MAX_IMPRESSIONS_BOOKMARKS', '                && !isPromoDismissed;', '    }', '', '    private static boolean timeElapsedSinceFirstShownExceedsLimit() {', '        final long timeSinceFirstShownLimitMs =', '                StartSurfaceConfiguration.SIGNIN_PROMO_NTP_SINCE_FIRST_TIME_SHOWN_LIMIT_HOURS', '                        .getValue()', '                * DateUtils.HOUR_IN_MILLIS;', '        if (timeSinceFirstShownLimitMs <= 0) return false;', '', '        final long currentTime = System.currentTimeMillis();', '        final long firstShownTime = SharedPreferencesManager.getInstance().readLong(', '                ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME, 0L);', '        return firstShownTime > 0 && currentTime - firstShownTime >= timeSinceFirstShownLimitMs;', '    }', '', '    private static boolean canShowNTPPromo() {', '        int maxImpressions = ChromeFeatureList.getFieldTrialParamByFeatureAsInt(', '                ChromeFeatureList.ENHANCED_PROTECTION_PROMO_CARD, ""MaxSigninPromoImpressions"",', '                Integer.MAX_VALUE);', '        if (SharedPreferencesManager.getInstance().readInt(', '                    getPromoShowCountPreferenceName(SigninAccessPoint.NTP_CONTENT_SUGGESTIONS))', '                        >= maxImpressions', '                || timeElapsedSinceFirstShownExceedsLimit()) {', '            return false;', '        }', '', '        if (SharedPreferencesManager.getInstance().readBoolean(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_PROMO_DISMISSED, false)) {', '            return false;', '        }', '', '        if (ChromeFeatureList.isEnabled(ChromeFeatureList.FORCE_DISABLE_EXTENDED_SYNC_PROMOS)) {', '            return false;', '        }', '        final @Nullable Account visibleAccount = getVisibleAccount();', '        final AccountManagerFacade accountManagerFacade =', '                AccountManagerFacadeProvider.getInstance();', '        return visibleAccount == null', '                || accountManagerFacade.canOfferExtendedSyncPromos(visibleAccount).or(false);', '    }', '', '    private static boolean canShowSettingsPromo() {', '        SharedPreferencesManager preferencesManager = SharedPreferencesManager.getInstance();', '        boolean isPromoDismissed = preferencesManager.readBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_SETTINGS_PERSONALIZED_DISMISSED, false);', '        return preferencesManager.readInt(', '                       getPromoShowCountPreferenceName(SigninAccessPoint.SETTINGS))', '                < MAX_IMPRESSIONS_SETTINGS', '                && !isPromoDismissed;', '    }', '', '    // Find the visible account for sync promos', '    private static @Nullable Account getVisibleAccount() {', '        final IdentityManager identityManager = IdentityServicesProvider.get().getIdentityManager(', '                Profile.getLastUsedRegularProfile());', '        @Nullable', '        Account visibleAccount = CoreAccountInfo.getAndroidAccountFrom(', '                identityManager.getPrimaryAccountInfo(ConsentLevel.SIGNIN));', '        final AccountManagerFacade accountManagerFacade =', '                AccountManagerFacadeProvider.getInstance();', '        if (visibleAccount == null) {', '            visibleAccount =', '                    AccountUtils.getDefaultAccountIfFulfilled(accountManagerFacade.getAccounts());', '        }', '        return visibleAccount;', '    }', '', '    @VisibleForTesting', '    public static String getPromoShowCountPreferenceName(@AccessPoint int accessPoint) {', '        switch (accessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(BOOKMARKS);', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(NTP);', '            case SigninAccessPoint.SETTINGS:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(SETTINGS);', '            default:', '                throw new IllegalArgumentException(', '                        ""Unexpected value for access point: "" + accessPoint);', '        }', '    }', '', '    /**', '     * Creates a new SigninPromoController.', '     * @param accessPoint Specifies the AccessPoint from which the promo is to be shown.', '     * @param syncConsentActivityLauncher Launcher of {@link SyncConsentActivity}.', '     */', '    public SigninPromoController(', '            @AccessPoint int accessPoint, SyncConsentActivityLauncher syncConsentActivityLauncher) {', '        mAccessPoint = accessPoint;', '        mSyncConsentActivityLauncher = syncConsentActivityLauncher;', '        switch (mAccessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                mImpressionCountHistogramName = ""Signin.Promo.Other.ShownAfterImpressions"";']}, {'a': ['                mSigninAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.ContinuedAfterImpressions"";'], 'b': ['                mContinuedAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.CompletedAfterImpressions"";']}, {'ab': ['                mDismissedAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.DismissedAfterImpressions"";', '                mImpressionCountName =', '                        ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_BOOKMARKS;', '                mImpressionUserActionName = ""Signin_Impression_FromBookmarkManager"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromBookmarkManager"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromBookmarkManager"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromBookmarkManager"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromBookmarkManager"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromBookmarkManager"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED;', '                mImpressionsTilDismissHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilDismiss"";', '                mImpressionsTilSigninButtonsHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilSigninButtons"";', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_bookmarks;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_bookmarks_no_account;', '                break;', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                mImpressionCountHistogramName = ""Signin.Promo.NTP.ShownAfterImpressions"";']}, {'a': ['                mSigninAfterImpressionsHistogramName = ""Signin.Promo.NTP.ContinuedAfterImpressions"";'], 'b': ['                mContinuedAfterImpressionsHistogramName =', '                        ""Signin.Promo.NTP.CompletedAfterImpressions"";']}, {'ab': ['                mDismissedAfterImpressionsHistogramName =', '                        ""Signin.Promo.NTP.DismissedAfterImpressions"";', '                mImpressionCountName = ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_NTP;', '                mImpressionUserActionName = ""Signin_Impression_FromNTPContentSuggestions"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromNTPContentSuggestions"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromNTPContentSuggestions"";', '                mSigninWithDefaultUserActionName =', '                        ""Signin_SigninWithDefault_FromNTPContentSuggestions"";', '                mSigninNotDefaultUserActionName =', '                        ""Signin_SigninNotDefault_FromNTPContentSuggestions"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromNTPContentSuggestions"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_PROMO_DISMISSED;', '                mImpressionsTilDismissHistogramName = null;', '                mImpressionsTilSigninButtonsHistogramName = null;', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.NTPContentSuggestions.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_ntp_content_suggestions;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_ntp_content_suggestions_no_account;', '                break;', '            case SigninAccessPoint.RECENT_TABS:', '                mImpressionCountHistogramName = ""Signin.Promo.Other.ShownAfterImpressions"";']}, {'a': ['                mSigninAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.ContinuedAfterImpressions"";', ""                // Recent Tabs promos can't be dismissed.""], 'b': ['                mContinuedAfterImpressionsHistogramName =', '                        ""Signin.Promo.Other.DismissedAfterImpressions"";']}, {'ab': ['                mDismissedAfterImpressionsHistogramName = null;', '                // There is no impression limit for Recent Tabs.', '                mImpressionCountName = null;', '                mImpressionUserActionName = ""Signin_Impression_FromRecentTabs"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromRecentTabs"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromRecentTabs"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromRecentTabs"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromRecentTabs"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromRecentTabs"";', '                mSyncPromoDismissedPreferenceTracker = null;', '                mImpressionsTilDismissHistogramName = null;', '                mImpressionsTilSigninButtonsHistogramName = null;', '                mImpressionsTilXButtonHistogramName = null;', '                mDescriptionStringId = R.string.signin_promo_description_recent_tabs;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_recent_tabs_no_account;', '                break;', '            case SigninAccessPoint.SETTINGS:', '                mImpressionCountHistogramName = ""Signin.Promo.Settings.ShownAfterImpressions"";']}, {'a': ['                mSigninAfterImpressionsHistogramName =', '                        ""Signin.Promo.Settings.ContinuedAfterImpressions"";'], 'b': ['                mContinuedAfterImpressionsHistogramName =', '                        ""Signin.Promo.Settings.CompletedAfterImpressions"";']}, {'ab': ['                mDismissedAfterImpressionsHistogramName =', '                        ""Signin.Promo.Settings.DismissedAfterImpressions"";', '                mImpressionCountName = ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_SETTINGS;', '                mImpressionUserActionName = ""Signin_Impression_FromSettings"";', '                mImpressionWithAccountUserActionName = ""Signin_ImpressionWithAccount_FromSettings"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromSettings"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromSettings"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromSettings"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromSettings"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_SETTINGS_PERSONALIZED_DISMISSED;', '                mImpressionsTilDismissHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilDismiss"";', '                mImpressionsTilSigninButtonsHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilSigninButtons"";', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_settings;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_settings_no_account;', '                break;', '            default:', '                throw new IllegalArgumentException(', '                        ""Unexpected value for access point: "" + mAccessPoint);', '        }', '    }', '', '    /**', '     * Sets up the sync promo view.', '     * @param profileDataCache The {@link ProfileDataCache} that stores profile data.', '     * @param view The {@link PersonalizedSigninPromoView} that should be set up.', '     * @param listener The {@link SigninPromoController.OnDismissListener} to be set to the view.', '     */', '    public void setUpSyncPromoView(ProfileDataCache profileDataCache,', '            PersonalizedSigninPromoView view, SigninPromoController.OnDismissListener listener) {', '        final IdentityManager identityManager = IdentityServicesProvider.get().getIdentityManager(', '                Profile.getLastUsedRegularProfile());', '        assert !identityManager.hasPrimaryAccount(ConsentLevel.SYNC) : ""Sync is already enabled!"";', '', '        final @Nullable Account visibleAccount = getVisibleAccount();', '        // Set up the sync promo', '        if (visibleAccount == null) {', '            setupPromoView(view, /* profileData= */ null, listener);', '            return;', '        }', '        setupPromoView(', '                view, profileDataCache.getProfileDataOrDefault(visibleAccount.name), listener);', '    }', '', '    /**', '     * Called when the signin promo is destroyed.', '     */', '    public void onPromoDestroyed() {', '        if (!mWasDisplayed || mWasUsed || mImpressionsTilDismissHistogramName == null) {', '            return;', '        }', '        RecordHistogram.recordCount100Histogram(', '                mImpressionsTilDismissHistogramName, getNumImpressions());', '    }', '', '    /**', '     * Configures the signin promo view and resets the impression tracker. If this controller has', '     * been previously set up.', '     * @param view The view in which the promo will be added.', '     * @param profileData If not null, the promo will be configured to be in the hot state, using', '     *         the account image, email and full name of the user to set the picture and the text of', '     *         the promo appropriately. Otherwise, the promo will be in the cold state.', '     * @param onDismissListener Listener which handles the action of dismissing the promo. A null', '     *         onDismissListener marks that the promo is not dismissible and as a result the close', '     *         button is hidden.', '     */', '    private void setupPromoView(PersonalizedSigninPromoView view,', '            final @Nullable DisplayableProfileData profileData,', '            final @Nullable OnDismissListener onDismissListener) {', '        if (mImpressionTracker != null) {', '            mImpressionTracker.setListener(null);', '            mImpressionTracker = null;', '        }', '        mImpressionTracker = new ImpressionTracker(view);', '        mImpressionTracker.setListener(', '                new OneShotImpressionListener(this::recordSigninPromoImpression));', '', '        mProfileData = profileData;', '        mWasDisplayed = true;', '        if (mProfileData == null) {', '            setupColdState(view);', '        } else {', '            setupHotState(view);', '        }', '', '        if (onDismissListener != null) {', '            view.getDismissButton().setVisibility(View.VISIBLE);', '            view.getDismissButton().setOnClickListener(promoView -> {', '                assert mImpressionsTilXButtonHistogramName != null;', '                assert mSyncPromoDismissedPreferenceTracker != null;', '                mWasUsed = true;', '                RecordHistogram.recordCount100Histogram(', '                        mImpressionsTilXButtonHistogramName, getNumImpressions());', '                SharedPreferencesManager.getInstance().writeBoolean(', '                        mSyncPromoDismissedPreferenceTracker, true);']}, {'a': ['                recordImpressionCountHistogram(mDismissedAfterImpressionsHistogramName);'], 'b': ['                RecordHistogram.recordExactLinearHistogram(mDismissedAfterImpressionsHistogramName,', '                        SharedPreferencesManager.getInstance().readInt(', '                                ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT),', '                        MAX_TOTAL_PROMO_SHOW_COUNT);']}, {'ab': ['                onDismissListener.onDismiss();', '            });', '        } else {', '            view.getDismissButton().setVisibility(View.GONE);', '        }', '    }', '', '    /**', ""     * Should be called when the view is not in use anymore (e.g. it's being recycled)."", '     */', '    public void detach() {', '        if (mImpressionTracker != null) {', '            mImpressionTracker.setListener(null);', '            mImpressionTracker = null;', '        }', '    }', '', '    /** Increases promo show count by one. */', '    public void increasePromoShowCount() {', '        if (mAccessPoint != SigninAccessPoint.RECENT_TABS) {', '            SharedPreferencesManager.getInstance().incrementInt(', '                    getPromoShowCountPreferenceName(mAccessPoint));', '        }', '        SharedPreferencesManager.getInstance().incrementInt(', '                ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT);', '        recordImpressionCountHistogram(mImpressionCountHistogramName);', '', '        if (mAccessPoint == SigninAccessPoint.NTP_CONTENT_SUGGESTIONS) {', '            final long currentTime = System.currentTimeMillis();', '            if (SharedPreferencesManager.getInstance().readLong(', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME)', '                    == 0) {', '                SharedPreferencesManager.getInstance().writeLong(', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME, currentTime);', '            }', '            SharedPreferencesManager.getInstance().writeLong(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME, currentTime);', '        }', '    }', '', '    private void setupColdState(PersonalizedSigninPromoView view) {', '        final Context context = view.getContext();', '        view.getImage().setImageResource(R.drawable.chrome_sync_logo);', '        setImageSize(context, view, R.dimen.signin_promo_cold_state_image_size);', '', '        view.getDescription().setText(mDescriptionStringIdNoAccount);', '', '        view.getPrimaryButton().setText(R.string.sync_promo_turn_on_sync);', '        view.getPrimaryButton().setOnClickListener(v -> signinWithNewAccount(context));', '', '        view.getSecondaryButton().setVisibility(View.GONE);', '    }', '', '    private void setupHotState(PersonalizedSigninPromoView view) {', '        final Context context = view.getContext();', '        Drawable accountImage = mProfileData.getImage();', '        view.getImage().setImageDrawable(accountImage);', '        setImageSize(context, view, R.dimen.signin_promo_account_image_size);', '', '        view.getDescription().setText(mDescriptionStringId);', '', '        view.getPrimaryButton().setOnClickListener(v -> signinWithDefaultAccount(context));', '        if (IdentityServicesProvider.get()', '                        .getIdentityManager(Profile.getLastUsedRegularProfile())', '                        .hasPrimaryAccount(ConsentLevel.SIGNIN)) {', '            view.getPrimaryButton().setText(R.string.sync_promo_turn_on_sync);', '            view.getSecondaryButton().setVisibility(View.GONE);', '        } else {', '            final String primaryButtonText =', '                    ChromeFeatureList.isEnabled(', '                            ChromeFeatureList.MOBILE_IDENTITY_CONSISTENCY_PROMOS)', '                    ? context.getString(R.string.signin_promo_continue_as,', '                            mProfileData.getGivenNameOrFullNameOrEmail())', '                    : context.getString(R.string.sync_promo_turn_on_sync);', '            view.getPrimaryButton().setText(primaryButtonText);', '', '            view.getSecondaryButton().setText(R.string.signin_promo_choose_another_account);', '            view.getSecondaryButton().setOnClickListener(v -> signinWithNotDefaultAccount(context));', '            view.getSecondaryButton().setVisibility(View.VISIBLE);', '        }', '    }', '', '    private int getNumImpressions() {', '        return SharedPreferencesManager.getInstance().readInt(mImpressionCountName);', '    }', '', '    private void signinWithNewAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninNewAccountUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoAddAccountFlow(context, mAccessPoint);', '    }', '', '    private void signinWithDefaultAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninWithDefaultUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoDefaultFlow(', '                context, mAccessPoint, mProfileData.getAccountEmail());', '    }', '', '    private void signinWithNotDefaultAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninNotDefaultUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoChooseAccountFlow(', '                context, mAccessPoint, mProfileData.getAccountEmail());', '    }', '', '    private void recordSigninButtonUsed() {', '        mWasUsed = true;']}, {'a': ['        recordImpressionCountHistogram(mSigninAfterImpressionsHistogramName);'], 'b': ['        recordImpressionCountHistogram(mContinuedAfterImpressionsHistogramName);']}, {'ab': ['        if (mImpressionsTilSigninButtonsHistogramName != null) {', '            RecordHistogram.recordCount100Histogram(', '                    mImpressionsTilSigninButtonsHistogramName, getNumImpressions());', '        }', '    }', '', '    private void recordImpressionCountHistogram(String histogramName) {', '        RecordHistogram.recordExactLinearHistogram(histogramName,', '                SharedPreferencesManager.getInstance().readInt(', '                        ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT),', '                MAX_TOTAL_PROMO_SHOW_COUNT);', '    }', '', '    private void setImageSize(', '            Context context, PersonalizedSigninPromoView view, @DimenRes int dimenResId) {', '        ViewGroup.LayoutParams layoutParams = view.getImage().getLayoutParams();', '        layoutParams.height = context.getResources().getDimensionPixelSize(dimenResId);', '        layoutParams.width = context.getResources().getDimensionPixelSize(dimenResId);', '        view.getImage().setLayoutParams(layoutParams);', '    }', '', '    private void recordSigninPromoImpression() {', '        RecordUserAction.record(mImpressionUserActionName);', '        if (mProfileData == null) {', '            RecordUserAction.record(mImpressionWithNoAccountUserActionName);', '        } else {', '            RecordUserAction.record(mImpressionWithAccountUserActionName);', '        }', '', '        // If mImpressionCountName is not null then we should record impressions.', '        if (mImpressionCountName != null) {', '            SharedPreferencesManager.getInstance().incrementInt(mImpressionCountName);', '        }', '    }', '', '    @VisibleForTesting', '    public static void setPrefSigninPromoDeclinedBookmarksForTests(boolean isDeclined) {', '        SharedPreferencesManager.getInstance().writeBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED, isDeclined);', '    }', '', '    @VisibleForTesting', '    public static int getMaxImpressionsBookmarksForTests() {', '        return MAX_IMPRESSIONS_BOOKMARKS;', '    }', '}', '']}]",chromium%2Fsrc~main~I23061b243395b039a3757d5b40679f388a32c23f,5f2b5ec993951ca0e5215ca0e3464dd173b2176e,chrome/browser/signin/ui/android/java/src/org/chromium/chrome/browser/signin/ui/SigninPromoController.java,667f3941_7034dd1b_before.java,667f3941_7034dd1b_after.java,SigninPromoController::SigninPromoController,True,True
27,21e86f2d_5016db6c,241.0,"I wonder if this will be easier if we can just move ""Other"" to the end and treat it as a suffix, then we don't need to add three fields for everyone, can just decide which suffix to add on the fly according to the access point.",237.0,241.0,"[{'ab': ['// Copyright 2017 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.signin.ui;', '', 'import android.accounts.Account;', 'import android.content.Context;', 'import android.graphics.drawable.Drawable;', 'import android.text.format.DateUtils;', 'import android.view.View;', 'import android.view.ViewGroup;', '', 'import androidx.annotation.DimenRes;', 'import androidx.annotation.Nullable;', 'import androidx.annotation.StringRes;', 'import androidx.annotation.VisibleForTesting;', '', 'import org.chromium.base.metrics.RecordHistogram;', 'import org.chromium.base.metrics.RecordUserAction;', 'import org.chromium.chrome.browser.flags.ChromeFeatureList;', 'import org.chromium.chrome.browser.preferences.ChromePreferenceKeys;', 'import org.chromium.chrome.browser.preferences.SharedPreferencesManager;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.signin.services.DisplayableProfileData;', 'import org.chromium.chrome.browser.signin.services.IdentityServicesProvider;', 'import org.chromium.chrome.browser.signin.services.ProfileDataCache;', 'import org.chromium.chrome.browser.signin.ui.SyncConsentActivityLauncher.AccessPoint;', 'import org.chromium.chrome.features.start_surface.StartSurfaceConfiguration;', 'import org.chromium.components.browser_ui.widget.impression.ImpressionTracker;', 'import org.chromium.components.browser_ui.widget.impression.OneShotImpressionListener;', 'import org.chromium.components.signin.AccountManagerFacade;', 'import org.chromium.components.signin.AccountManagerFacadeProvider;', 'import org.chromium.components.signin.AccountUtils;', 'import org.chromium.components.signin.base.CoreAccountInfo;', 'import org.chromium.components.signin.identitymanager.ConsentLevel;', 'import org.chromium.components.signin.identitymanager.IdentityManager;', 'import org.chromium.components.signin.metrics.SigninAccessPoint;', '', '/**', ' * A controller for configuring the sign in promo. It sets up the sign in promo depending on the', ' * context: whether there are any Google accounts on the device which have been previously signed in', ' * or not. The controller also takes care of counting impressions, recording signin related user', ' * actions and histograms.', ' */', 'public class SigninPromoController {', '    /**', '     * Receives notifications when user clicks close button in the promo.', '     */', '    public interface OnDismissListener {', '        /**', '         * Action to be performed when the promo is being dismissed.', '         */', '        void onDismiss();', '    }', '', '    private static final int MAX_TOTAL_PROMO_SHOW_COUNT = 100;', '    private static final int MAX_IMPRESSIONS_BOOKMARKS = 20;', '    private static final int MAX_IMPRESSIONS_SETTINGS = 20;', '', '    /** Suffix strings for promo shown count preference. */', '    private static final String BOOKMARKS = ""Bookmarks"";', '    private static final String NTP = ""Ntp"";', '    private static final String SETTINGS = ""Settings"";', '', '    private @Nullable DisplayableProfileData mProfileData;', '    private @Nullable ImpressionTracker mImpressionTracker;', '    private final @AccessPoint int mAccessPoint;', '    private final String mImpressionCountHistogramName;']}, {'a': ['    private final String mContinuedAfterImpressionCountHistogramName;', '    private final String mDismissedAfterImpressionCountHistogramName;'], 'b': ['    private final String mSigninAfterImpressionsHistogramName;', '    private final String mDismissedAfterImpressionsHistogramName;']}, {'ab': ['    // TODO(https://crbug.com/1254399): Remove this field. This is over counted.', '    private final @Nullable String mImpressionCountName;', '    private final String mImpressionUserActionName;', '    private final String mImpressionWithAccountUserActionName;', '    private final String mImpressionWithNoAccountUserActionName;', '    private final String mSigninWithDefaultUserActionName;', '    private final String mSigninNotDefaultUserActionName;', '    private final String mSigninNewAccountUserActionName;', '    private final @Nullable String mSyncPromoDismissedPreferenceTracker;', '    // TODO(https://crbug.com/1254399): Remove these fields related to impressions.', '    private final @Nullable String mImpressionsTilDismissHistogramName;', '    private final @Nullable String mImpressionsTilSigninButtonsHistogramName;', '    private final @Nullable String mImpressionsTilXButtonHistogramName;', '    private final @StringRes int mDescriptionStringId;', '    private final @StringRes int mDescriptionStringIdNoAccount;', '    private final SyncConsentActivityLauncher mSyncConsentActivityLauncher;', '    private boolean mWasDisplayed;', '    private boolean mWasUsed;', '', '    /**', '     * Determines whether the Sync promo can be shown.', '     * @param accessPoint The access point for which the impression limit is being checked.', '     */', '    public static boolean canShowSyncPromo(@AccessPoint int accessPoint) {', '        switch (accessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                return canShowBookmarkPromo();', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                return canShowNTPPromo();', '            case SigninAccessPoint.RECENT_TABS:', '                // There is no impression limit or dismiss button in Recent Tabs promo.', '                return true;', '            case SigninAccessPoint.SETTINGS:', '                return canShowSettingsPromo();', '            default:', '                assert false : ""Unexpected value for access point: "" + accessPoint;', '                return false;', '        }', '    }', '', '    /**', '     * If the signin promo card has been hidden for longer than the {@link', '     * StartSurfaceConfiguration#SIGNIN_PROMO_NTP_RESET_AFTER_HOURS}, resets the impression counts,', '     * {@link ChromePreferenceKeys#SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME} and {@link', '     * ChromePreferenceKeys#SIGNIN_PROMO_NTP_LAST_SHOWN_TIME} to allow the promo card to show again.', '     */', '    public static void resetNTPSyncPromoLimitsIfHiddenForTooLong() {', '        final long currentTime = System.currentTimeMillis();', '        final long resetAfterMs =', '                StartSurfaceConfiguration.SIGNIN_PROMO_NTP_RESET_AFTER_HOURS.getValue()', '                * DateUtils.HOUR_IN_MILLIS;', '        final long lastShownTime = SharedPreferencesManager.getInstance().readLong(', '                ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME, 0L);', '        if (resetAfterMs <= 0 || lastShownTime <= 0) return;', '', '        if (currentTime - lastShownTime >= resetAfterMs) {', '            SharedPreferencesManager.getInstance().writeInt(', '                    getPromoShowCountPreferenceName(SigninAccessPoint.NTP_CONTENT_SUGGESTIONS), 0);', '            SharedPreferencesManager.getInstance().removeKey(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME);', '            SharedPreferencesManager.getInstance().removeKey(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME);', '        }', '    }', '', '    private static boolean canShowBookmarkPromo() {', '        boolean isPromoDismissed = SharedPreferencesManager.getInstance().readBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED, false);', '        return SharedPreferencesManager.getInstance().readInt(', '                       getPromoShowCountPreferenceName(SigninAccessPoint.BOOKMARK_MANAGER))', '                < MAX_IMPRESSIONS_BOOKMARKS', '                && !isPromoDismissed;', '    }', '', '    private static boolean timeElapsedSinceFirstShownExceedsLimit() {', '        final long timeSinceFirstShownLimitMs =', '                StartSurfaceConfiguration.SIGNIN_PROMO_NTP_SINCE_FIRST_TIME_SHOWN_LIMIT_HOURS', '                        .getValue()', '                * DateUtils.HOUR_IN_MILLIS;', '        if (timeSinceFirstShownLimitMs <= 0) return false;', '', '        final long currentTime = System.currentTimeMillis();', '        final long firstShownTime = SharedPreferencesManager.getInstance().readLong(', '                ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME, 0L);', '        return firstShownTime > 0 && currentTime - firstShownTime >= timeSinceFirstShownLimitMs;', '    }', '', '    private static boolean canShowNTPPromo() {', '        int maxImpressions = ChromeFeatureList.getFieldTrialParamByFeatureAsInt(', '                ChromeFeatureList.ENHANCED_PROTECTION_PROMO_CARD, ""MaxSigninPromoImpressions"",', '                Integer.MAX_VALUE);', '        if (SharedPreferencesManager.getInstance().readInt(', '                    getPromoShowCountPreferenceName(SigninAccessPoint.NTP_CONTENT_SUGGESTIONS))', '                        >= maxImpressions', '                || timeElapsedSinceFirstShownExceedsLimit()) {', '            return false;', '        }', '', '        if (SharedPreferencesManager.getInstance().readBoolean(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_PROMO_DISMISSED, false)) {', '            return false;', '        }', '', '        if (ChromeFeatureList.isEnabled(ChromeFeatureList.FORCE_DISABLE_EXTENDED_SYNC_PROMOS)) {', '            return false;', '        }', '        final @Nullable Account visibleAccount = getVisibleAccount();', '        final AccountManagerFacade accountManagerFacade =', '                AccountManagerFacadeProvider.getInstance();', '        return visibleAccount == null', '                || accountManagerFacade.canOfferExtendedSyncPromos(visibleAccount).or(false);', '    }', '', '    private static boolean canShowSettingsPromo() {', '        SharedPreferencesManager preferencesManager = SharedPreferencesManager.getInstance();', '        boolean isPromoDismissed = preferencesManager.readBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_SETTINGS_PERSONALIZED_DISMISSED, false);', '        return preferencesManager.readInt(', '                       getPromoShowCountPreferenceName(SigninAccessPoint.SETTINGS))', '                < MAX_IMPRESSIONS_SETTINGS', '                && !isPromoDismissed;', '    }', '', '    // Find the visible account for sync promos', '    private static @Nullable Account getVisibleAccount() {', '        final IdentityManager identityManager = IdentityServicesProvider.get().getIdentityManager(', '                Profile.getLastUsedRegularProfile());', '        @Nullable', '        Account visibleAccount = CoreAccountInfo.getAndroidAccountFrom(', '                identityManager.getPrimaryAccountInfo(ConsentLevel.SIGNIN));', '        final AccountManagerFacade accountManagerFacade =', '                AccountManagerFacadeProvider.getInstance();', '        if (visibleAccount == null) {', '            visibleAccount =', '                    AccountUtils.getDefaultAccountIfFulfilled(accountManagerFacade.getAccounts());', '        }', '        return visibleAccount;', '    }', '', '    @VisibleForTesting', '    public static String getPromoShowCountPreferenceName(@AccessPoint int accessPoint) {', '        switch (accessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(BOOKMARKS);', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(NTP);', '            case SigninAccessPoint.SETTINGS:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(SETTINGS);', '            default:', '                throw new IllegalArgumentException(', '                        ""Unexpected value for access point: "" + accessPoint);', '        }', '    }', '', '    /**', '     * Creates a new SigninPromoController.', '     * @param accessPoint Specifies the AccessPoint from which the promo is to be shown.', '     * @param syncConsentActivityLauncher Launcher of {@link SyncConsentActivity}.', '     */', '    public SigninPromoController(', '            @AccessPoint int accessPoint, SyncConsentActivityLauncher syncConsentActivityLauncher) {', '        mAccessPoint = accessPoint;', '        mSyncConsentActivityLauncher = syncConsentActivityLauncher;', '        switch (mAccessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                mImpressionCountHistogramName = ""Signin.Promo.Other.ShownAfterImpressions"";']}, {'a': ['                mContinuedAfterImpressionCountHistogramName ='], 'b': ['                mSigninAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Other.ContinuedAfterImpressions"";']}, {'a': ['                mDismissedAfterImpressionCountHistogramName ='], 'b': ['                mDismissedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Other.DismissedAfterImpressions"";', '                mImpressionCountName =', '                        ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_BOOKMARKS;', '                mImpressionUserActionName = ""Signin_Impression_FromBookmarkManager"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromBookmarkManager"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromBookmarkManager"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromBookmarkManager"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromBookmarkManager"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromBookmarkManager"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED;', '                mImpressionsTilDismissHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilDismiss"";', '                mImpressionsTilSigninButtonsHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilSigninButtons"";', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_bookmarks;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_bookmarks_no_account;', '                break;', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                mImpressionCountHistogramName = ""Signin.Promo.NTP.ShownAfterImpressions"";']}, {'a': ['                mContinuedAfterImpressionCountHistogramName =', '                        ""Signin.Promo.NTP.ContinuedAfterImpressions"";', '                mDismissedAfterImpressionCountHistogramName ='], 'b': ['                mSigninAfterImpressionsHistogramName = ""Signin.Promo.NTP.ContinuedAfterImpressions"";', '                mDismissedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.NTP.DismissedAfterImpressions"";', '                mImpressionCountName = ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_NTP;', '                mImpressionUserActionName = ""Signin_Impression_FromNTPContentSuggestions"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromNTPContentSuggestions"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromNTPContentSuggestions"";', '                mSigninWithDefaultUserActionName =', '                        ""Signin_SigninWithDefault_FromNTPContentSuggestions"";', '                mSigninNotDefaultUserActionName =', '                        ""Signin_SigninNotDefault_FromNTPContentSuggestions"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromNTPContentSuggestions"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_PROMO_DISMISSED;', '                mImpressionsTilDismissHistogramName = null;', '                mImpressionsTilSigninButtonsHistogramName = null;', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.NTPContentSuggestions.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_ntp_content_suggestions;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_ntp_content_suggestions_no_account;', '                break;', '            case SigninAccessPoint.RECENT_TABS:', '                mImpressionCountHistogramName = ""Signin.Promo.Other.ShownAfterImpressions"";']}, {'a': ['                mContinuedAfterImpressionCountHistogramName ='], 'b': ['                mSigninAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Other.ContinuedAfterImpressions"";', ""                // Recent Tabs promos can't be dismissed.""]}, {'a': ['                mDismissedAfterImpressionCountHistogramName = null;'], 'b': ['                mDismissedAfterImpressionsHistogramName = null;']}, {'ab': ['                // There is no impression limit for Recent Tabs.', '                mImpressionCountName = null;', '                mImpressionUserActionName = ""Signin_Impression_FromRecentTabs"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromRecentTabs"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromRecentTabs"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromRecentTabs"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromRecentTabs"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromRecentTabs"";', '                mSyncPromoDismissedPreferenceTracker = null;', '                mImpressionsTilDismissHistogramName = null;', '                mImpressionsTilSigninButtonsHistogramName = null;', '                mImpressionsTilXButtonHistogramName = null;', '                mDescriptionStringId = R.string.signin_promo_description_recent_tabs;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_recent_tabs_no_account;', '                break;', '            case SigninAccessPoint.SETTINGS:', '                mImpressionCountHistogramName = ""Signin.Promo.Settings.ShownAfterImpressions"";']}, {'a': ['                mContinuedAfterImpressionCountHistogramName ='], 'b': ['                mSigninAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Settings.ContinuedAfterImpressions"";']}, {'a': ['                mDismissedAfterImpressionCountHistogramName ='], 'b': ['                mDismissedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Settings.DismissedAfterImpressions"";', '                mImpressionCountName = ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_SETTINGS;', '                mImpressionUserActionName = ""Signin_Impression_FromSettings"";', '                mImpressionWithAccountUserActionName = ""Signin_ImpressionWithAccount_FromSettings"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromSettings"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromSettings"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromSettings"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromSettings"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_SETTINGS_PERSONALIZED_DISMISSED;', '                mImpressionsTilDismissHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilDismiss"";', '                mImpressionsTilSigninButtonsHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilSigninButtons"";', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_settings;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_settings_no_account;', '                break;', '            default:', '                throw new IllegalArgumentException(', '                        ""Unexpected value for access point: "" + mAccessPoint);', '        }', '    }', '', '    /**', '     * Sets up the sync promo view.', '     * @param profileDataCache The {@link ProfileDataCache} that stores profile data.', '     * @param view The {@link PersonalizedSigninPromoView} that should be set up.', '     * @param listener The {@link SigninPromoController.OnDismissListener} to be set to the view.', '     */', '    public void setUpSyncPromoView(ProfileDataCache profileDataCache,', '            PersonalizedSigninPromoView view, SigninPromoController.OnDismissListener listener) {', '        final IdentityManager identityManager = IdentityServicesProvider.get().getIdentityManager(', '                Profile.getLastUsedRegularProfile());', '        assert !identityManager.hasPrimaryAccount(ConsentLevel.SYNC) : ""Sync is already enabled!"";', '', '        final @Nullable Account visibleAccount = getVisibleAccount();', '        // Set up the sync promo', '        if (visibleAccount == null) {', '            setupPromoView(view, /* profileData= */ null, listener);', '            return;', '        }', '        setupPromoView(', '                view, profileDataCache.getProfileDataOrDefault(visibleAccount.name), listener);', '    }', '', '    /**', '     * Called when the signin promo is destroyed.', '     */', '    public void onPromoDestroyed() {', '        if (!mWasDisplayed || mWasUsed || mImpressionsTilDismissHistogramName == null) {', '            return;', '        }', '        RecordHistogram.recordCount100Histogram(', '                mImpressionsTilDismissHistogramName, getNumImpressions());', '    }', '', '    /**', '     * Configures the signin promo view and resets the impression tracker. If this controller has', '     * been previously set up.', '     * @param view The view in which the promo will be added.', '     * @param profileData If not null, the promo will be configured to be in the hot state, using', '     *         the account image, email and full name of the user to set the picture and the text of', '     *         the promo appropriately. Otherwise, the promo will be in the cold state.', '     * @param onDismissListener Listener which handles the action of dismissing the promo. A null', '     *         onDismissListener marks that the promo is not dismissible and as a result the close', '     *         button is hidden.', '     */', '    private void setupPromoView(PersonalizedSigninPromoView view,', '            final @Nullable DisplayableProfileData profileData,', '            final @Nullable OnDismissListener onDismissListener) {', '        if (mImpressionTracker != null) {', '            mImpressionTracker.setListener(null);', '            mImpressionTracker = null;', '        }', '        mImpressionTracker = new ImpressionTracker(view);', '        mImpressionTracker.setListener(', '                new OneShotImpressionListener(this::recordSigninPromoImpression));', '', '        mProfileData = profileData;', '        mWasDisplayed = true;', '        if (mProfileData == null) {', '            setupColdState(view);', '        } else {', '            setupHotState(view);', '        }', '', '        if (onDismissListener != null) {', '            view.getDismissButton().setVisibility(View.VISIBLE);', '            view.getDismissButton().setOnClickListener(promoView -> {', '                assert mImpressionsTilXButtonHistogramName != null;', '                assert mSyncPromoDismissedPreferenceTracker != null;', '                mWasUsed = true;', '                RecordHistogram.recordCount100Histogram(', '                        mImpressionsTilXButtonHistogramName, getNumImpressions());', '                SharedPreferencesManager.getInstance().writeBoolean(', '                        mSyncPromoDismissedPreferenceTracker, true);']}, {'a': ['                recordImpressionCountHistogram(mDismissedAfterImpressionCountHistogramName);'], 'b': ['                recordImpressionCountHistogram(mDismissedAfterImpressionsHistogramName);']}, {'ab': ['                onDismissListener.onDismiss();', '            });', '        } else {', '            view.getDismissButton().setVisibility(View.GONE);', '        }', '    }', '', '    /**', ""     * Should be called when the view is not in use anymore (e.g. it's being recycled)."", '     */', '    public void detach() {', '        if (mImpressionTracker != null) {', '            mImpressionTracker.setListener(null);', '            mImpressionTracker = null;', '        }', '    }', '', '    /** Increases promo show count by one. */', '    public void increasePromoShowCount() {', '        if (mAccessPoint != SigninAccessPoint.RECENT_TABS) {', '            SharedPreferencesManager.getInstance().incrementInt(', '                    getPromoShowCountPreferenceName(mAccessPoint));', '        }', '        SharedPreferencesManager.getInstance().incrementInt(', '                ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT);', '        recordImpressionCountHistogram(mImpressionCountHistogramName);', '', '        if (mAccessPoint == SigninAccessPoint.NTP_CONTENT_SUGGESTIONS) {', '            final long currentTime = System.currentTimeMillis();', '            if (SharedPreferencesManager.getInstance().readLong(', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME)', '                    == 0) {', '                SharedPreferencesManager.getInstance().writeLong(', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME, currentTime);', '            }', '            SharedPreferencesManager.getInstance().writeLong(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME, currentTime);', '        }', '    }', '', '    private void setupColdState(PersonalizedSigninPromoView view) {', '        final Context context = view.getContext();', '        view.getImage().setImageResource(R.drawable.chrome_sync_logo);', '        setImageSize(context, view, R.dimen.signin_promo_cold_state_image_size);', '', '        view.getDescription().setText(mDescriptionStringIdNoAccount);', '', '        view.getPrimaryButton().setText(R.string.sync_promo_turn_on_sync);', '        view.getPrimaryButton().setOnClickListener(v -> signinWithNewAccount(context));', '', '        view.getSecondaryButton().setVisibility(View.GONE);', '    }', '', '    private void setupHotState(PersonalizedSigninPromoView view) {', '        final Context context = view.getContext();', '        Drawable accountImage = mProfileData.getImage();', '        view.getImage().setImageDrawable(accountImage);', '        setImageSize(context, view, R.dimen.signin_promo_account_image_size);', '', '        view.getDescription().setText(mDescriptionStringId);', '', '        view.getPrimaryButton().setOnClickListener(v -> signinWithDefaultAccount(context));', '        if (IdentityServicesProvider.get()', '                        .getIdentityManager(Profile.getLastUsedRegularProfile())', '                        .hasPrimaryAccount(ConsentLevel.SIGNIN)) {', '            view.getPrimaryButton().setText(R.string.sync_promo_turn_on_sync);', '            view.getSecondaryButton().setVisibility(View.GONE);', '        } else {', '            final String primaryButtonText =', '                    ChromeFeatureList.isEnabled(', '                            ChromeFeatureList.MOBILE_IDENTITY_CONSISTENCY_PROMOS)', '                    ? context.getString(R.string.signin_promo_continue_as,', '                            mProfileData.getGivenNameOrFullNameOrEmail())', '                    : context.getString(R.string.sync_promo_turn_on_sync);', '            view.getPrimaryButton().setText(primaryButtonText);', '', '            view.getSecondaryButton().setText(R.string.signin_promo_choose_another_account);', '            view.getSecondaryButton().setOnClickListener(v -> signinWithNotDefaultAccount(context));', '            view.getSecondaryButton().setVisibility(View.VISIBLE);', '        }', '    }', '', '    private int getNumImpressions() {', '        return SharedPreferencesManager.getInstance().readInt(mImpressionCountName);', '    }', '', '    private void signinWithNewAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninNewAccountUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoAddAccountFlow(context, mAccessPoint);', '    }', '', '    private void signinWithDefaultAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninWithDefaultUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoDefaultFlow(', '                context, mAccessPoint, mProfileData.getAccountEmail());', '    }', '', '    private void signinWithNotDefaultAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninNotDefaultUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoChooseAccountFlow(', '                context, mAccessPoint, mProfileData.getAccountEmail());', '    }', '', '    private void recordSigninButtonUsed() {', '        mWasUsed = true;']}, {'a': ['        recordImpressionCountHistogram(mContinuedAfterImpressionCountHistogramName);'], 'b': ['        recordImpressionCountHistogram(mSigninAfterImpressionsHistogramName);']}, {'ab': ['        if (mImpressionsTilSigninButtonsHistogramName != null) {', '            RecordHistogram.recordCount100Histogram(', '                    mImpressionsTilSigninButtonsHistogramName, getNumImpressions());', '        }', '    }', '', '    private void recordImpressionCountHistogram(String histogramName) {', '        RecordHistogram.recordExactLinearHistogram(histogramName,', '                SharedPreferencesManager.getInstance().readInt(', '                        ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT),', '                MAX_TOTAL_PROMO_SHOW_COUNT);', '    }', '', '    private void setImageSize(', '            Context context, PersonalizedSigninPromoView view, @DimenRes int dimenResId) {', '        ViewGroup.LayoutParams layoutParams = view.getImage().getLayoutParams();', '        layoutParams.height = context.getResources().getDimensionPixelSize(dimenResId);', '        layoutParams.width = context.getResources().getDimensionPixelSize(dimenResId);', '        view.getImage().setLayoutParams(layoutParams);', '    }', '', '    private void recordSigninPromoImpression() {', '        RecordUserAction.record(mImpressionUserActionName);', '        if (mProfileData == null) {', '            RecordUserAction.record(mImpressionWithNoAccountUserActionName);', '        } else {', '            RecordUserAction.record(mImpressionWithAccountUserActionName);', '        }', '', '        // If mImpressionCountName is not null then we should record impressions.', '        if (mImpressionCountName != null) {', '            SharedPreferencesManager.getInstance().incrementInt(mImpressionCountName);', '        }', '    }', '', '    @VisibleForTesting', '    public static void setPrefSigninPromoDeclinedBookmarksForTests(boolean isDeclined) {', '        SharedPreferencesManager.getInstance().writeBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED, isDeclined);', '    }', '', '    @VisibleForTesting', '    public static int getMaxImpressionsBookmarksForTests() {', '        return MAX_IMPRESSIONS_BOOKMARKS;', '    }', '}', '']}]",chromium%2Fsrc~main~I23061b243395b039a3757d5b40679f388a32c23f,2c6d8db935d052a5ccac1cdbbba574f7c342219a,chrome/browser/signin/ui/android/java/src/org/chromium/chrome/browser/signin/ui/SigninPromoController.java,21e86f2d_5016db6c_before.java,21e86f2d_5016db6c_after.java,SigninPromoController::SigninPromoController,True,True
28,6bed6b34_e7d40185,241.0,"From a coding perspective it would be easier. But I wonder if it would be a bit of anti-pattern to name histograms like that.
+Alex, Can you please comment on this?",237.0,241.0,"[{'ab': ['// Copyright 2017 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.signin.ui;', '', 'import android.accounts.Account;', 'import android.content.Context;', 'import android.graphics.drawable.Drawable;', 'import android.text.format.DateUtils;', 'import android.view.View;', 'import android.view.ViewGroup;', '', 'import androidx.annotation.DimenRes;', 'import androidx.annotation.Nullable;', 'import androidx.annotation.StringRes;', 'import androidx.annotation.VisibleForTesting;', '', 'import org.chromium.base.metrics.RecordHistogram;', 'import org.chromium.base.metrics.RecordUserAction;', 'import org.chromium.chrome.browser.flags.ChromeFeatureList;', 'import org.chromium.chrome.browser.preferences.ChromePreferenceKeys;', 'import org.chromium.chrome.browser.preferences.SharedPreferencesManager;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.signin.services.DisplayableProfileData;', 'import org.chromium.chrome.browser.signin.services.IdentityServicesProvider;', 'import org.chromium.chrome.browser.signin.services.ProfileDataCache;', 'import org.chromium.chrome.browser.signin.ui.SyncConsentActivityLauncher.AccessPoint;', 'import org.chromium.chrome.features.start_surface.StartSurfaceConfiguration;', 'import org.chromium.components.browser_ui.widget.impression.ImpressionTracker;', 'import org.chromium.components.browser_ui.widget.impression.OneShotImpressionListener;', 'import org.chromium.components.signin.AccountManagerFacade;', 'import org.chromium.components.signin.AccountManagerFacadeProvider;', 'import org.chromium.components.signin.AccountUtils;', 'import org.chromium.components.signin.base.CoreAccountInfo;', 'import org.chromium.components.signin.identitymanager.ConsentLevel;', 'import org.chromium.components.signin.identitymanager.IdentityManager;', 'import org.chromium.components.signin.metrics.SigninAccessPoint;', '', '/**', ' * A controller for configuring the sign in promo. It sets up the sign in promo depending on the', ' * context: whether there are any Google accounts on the device which have been previously signed in', ' * or not. The controller also takes care of counting impressions, recording signin related user', ' * actions and histograms.', ' */', 'public class SigninPromoController {', '    /**', '     * Receives notifications when user clicks close button in the promo.', '     */', '    public interface OnDismissListener {', '        /**', '         * Action to be performed when the promo is being dismissed.', '         */', '        void onDismiss();', '    }', '', '    private static final int MAX_TOTAL_PROMO_SHOW_COUNT = 100;', '    private static final int MAX_IMPRESSIONS_BOOKMARKS = 20;', '    private static final int MAX_IMPRESSIONS_SETTINGS = 20;', '', '    /** Suffix strings for promo shown count preference. */', '    private static final String BOOKMARKS = ""Bookmarks"";', '    private static final String NTP = ""Ntp"";', '    private static final String SETTINGS = ""Settings"";', '', '    private @Nullable DisplayableProfileData mProfileData;', '    private @Nullable ImpressionTracker mImpressionTracker;', '    private final @AccessPoint int mAccessPoint;', '    private final String mImpressionCountHistogramName;']}, {'a': ['    private final String mContinuedAfterImpressionCountHistogramName;', '    private final String mDismissedAfterImpressionCountHistogramName;'], 'b': ['    private final String mSigninAfterImpressionsHistogramName;', '    private final String mDismissedAfterImpressionsHistogramName;']}, {'ab': ['    // TODO(https://crbug.com/1254399): Remove this field. This is over counted.', '    private final @Nullable String mImpressionCountName;', '    private final String mImpressionUserActionName;', '    private final String mImpressionWithAccountUserActionName;', '    private final String mImpressionWithNoAccountUserActionName;', '    private final String mSigninWithDefaultUserActionName;', '    private final String mSigninNotDefaultUserActionName;', '    private final String mSigninNewAccountUserActionName;', '    private final @Nullable String mSyncPromoDismissedPreferenceTracker;', '    // TODO(https://crbug.com/1254399): Remove these fields related to impressions.', '    private final @Nullable String mImpressionsTilDismissHistogramName;', '    private final @Nullable String mImpressionsTilSigninButtonsHistogramName;', '    private final @Nullable String mImpressionsTilXButtonHistogramName;', '    private final @StringRes int mDescriptionStringId;', '    private final @StringRes int mDescriptionStringIdNoAccount;', '    private final SyncConsentActivityLauncher mSyncConsentActivityLauncher;', '    private boolean mWasDisplayed;', '    private boolean mWasUsed;', '', '    /**', '     * Determines whether the Sync promo can be shown.', '     * @param accessPoint The access point for which the impression limit is being checked.', '     */', '    public static boolean canShowSyncPromo(@AccessPoint int accessPoint) {', '        switch (accessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                return canShowBookmarkPromo();', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                return canShowNTPPromo();', '            case SigninAccessPoint.RECENT_TABS:', '                // There is no impression limit or dismiss button in Recent Tabs promo.', '                return true;', '            case SigninAccessPoint.SETTINGS:', '                return canShowSettingsPromo();', '            default:', '                assert false : ""Unexpected value for access point: "" + accessPoint;', '                return false;', '        }', '    }', '', '    /**', '     * If the signin promo card has been hidden for longer than the {@link', '     * StartSurfaceConfiguration#SIGNIN_PROMO_NTP_RESET_AFTER_HOURS}, resets the impression counts,', '     * {@link ChromePreferenceKeys#SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME} and {@link', '     * ChromePreferenceKeys#SIGNIN_PROMO_NTP_LAST_SHOWN_TIME} to allow the promo card to show again.', '     */', '    public static void resetNTPSyncPromoLimitsIfHiddenForTooLong() {', '        final long currentTime = System.currentTimeMillis();', '        final long resetAfterMs =', '                StartSurfaceConfiguration.SIGNIN_PROMO_NTP_RESET_AFTER_HOURS.getValue()', '                * DateUtils.HOUR_IN_MILLIS;', '        final long lastShownTime = SharedPreferencesManager.getInstance().readLong(', '                ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME, 0L);', '        if (resetAfterMs <= 0 || lastShownTime <= 0) return;', '', '        if (currentTime - lastShownTime >= resetAfterMs) {', '            SharedPreferencesManager.getInstance().writeInt(', '                    getPromoShowCountPreferenceName(SigninAccessPoint.NTP_CONTENT_SUGGESTIONS), 0);', '            SharedPreferencesManager.getInstance().removeKey(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME);', '            SharedPreferencesManager.getInstance().removeKey(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME);', '        }', '    }', '', '    private static boolean canShowBookmarkPromo() {', '        boolean isPromoDismissed = SharedPreferencesManager.getInstance().readBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED, false);', '        return SharedPreferencesManager.getInstance().readInt(', '                       getPromoShowCountPreferenceName(SigninAccessPoint.BOOKMARK_MANAGER))', '                < MAX_IMPRESSIONS_BOOKMARKS', '                && !isPromoDismissed;', '    }', '', '    private static boolean timeElapsedSinceFirstShownExceedsLimit() {', '        final long timeSinceFirstShownLimitMs =', '                StartSurfaceConfiguration.SIGNIN_PROMO_NTP_SINCE_FIRST_TIME_SHOWN_LIMIT_HOURS', '                        .getValue()', '                * DateUtils.HOUR_IN_MILLIS;', '        if (timeSinceFirstShownLimitMs <= 0) return false;', '', '        final long currentTime = System.currentTimeMillis();', '        final long firstShownTime = SharedPreferencesManager.getInstance().readLong(', '                ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME, 0L);', '        return firstShownTime > 0 && currentTime - firstShownTime >= timeSinceFirstShownLimitMs;', '    }', '', '    private static boolean canShowNTPPromo() {', '        int maxImpressions = ChromeFeatureList.getFieldTrialParamByFeatureAsInt(', '                ChromeFeatureList.ENHANCED_PROTECTION_PROMO_CARD, ""MaxSigninPromoImpressions"",', '                Integer.MAX_VALUE);', '        if (SharedPreferencesManager.getInstance().readInt(', '                    getPromoShowCountPreferenceName(SigninAccessPoint.NTP_CONTENT_SUGGESTIONS))', '                        >= maxImpressions', '                || timeElapsedSinceFirstShownExceedsLimit()) {', '            return false;', '        }', '', '        if (SharedPreferencesManager.getInstance().readBoolean(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_PROMO_DISMISSED, false)) {', '            return false;', '        }', '', '        if (ChromeFeatureList.isEnabled(ChromeFeatureList.FORCE_DISABLE_EXTENDED_SYNC_PROMOS)) {', '            return false;', '        }', '        final @Nullable Account visibleAccount = getVisibleAccount();', '        final AccountManagerFacade accountManagerFacade =', '                AccountManagerFacadeProvider.getInstance();', '        return visibleAccount == null', '                || accountManagerFacade.canOfferExtendedSyncPromos(visibleAccount).or(false);', '    }', '', '    private static boolean canShowSettingsPromo() {', '        SharedPreferencesManager preferencesManager = SharedPreferencesManager.getInstance();', '        boolean isPromoDismissed = preferencesManager.readBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_SETTINGS_PERSONALIZED_DISMISSED, false);', '        return preferencesManager.readInt(', '                       getPromoShowCountPreferenceName(SigninAccessPoint.SETTINGS))', '                < MAX_IMPRESSIONS_SETTINGS', '                && !isPromoDismissed;', '    }', '', '    // Find the visible account for sync promos', '    private static @Nullable Account getVisibleAccount() {', '        final IdentityManager identityManager = IdentityServicesProvider.get().getIdentityManager(', '                Profile.getLastUsedRegularProfile());', '        @Nullable', '        Account visibleAccount = CoreAccountInfo.getAndroidAccountFrom(', '                identityManager.getPrimaryAccountInfo(ConsentLevel.SIGNIN));', '        final AccountManagerFacade accountManagerFacade =', '                AccountManagerFacadeProvider.getInstance();', '        if (visibleAccount == null) {', '            visibleAccount =', '                    AccountUtils.getDefaultAccountIfFulfilled(accountManagerFacade.getAccounts());', '        }', '        return visibleAccount;', '    }', '', '    @VisibleForTesting', '    public static String getPromoShowCountPreferenceName(@AccessPoint int accessPoint) {', '        switch (accessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(BOOKMARKS);', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(NTP);', '            case SigninAccessPoint.SETTINGS:', '                return ChromePreferenceKeys.SYNC_PROMO_SHOW_COUNT.createKey(SETTINGS);', '            default:', '                throw new IllegalArgumentException(', '                        ""Unexpected value for access point: "" + accessPoint);', '        }', '    }', '', '    /**', '     * Creates a new SigninPromoController.', '     * @param accessPoint Specifies the AccessPoint from which the promo is to be shown.', '     * @param syncConsentActivityLauncher Launcher of {@link SyncConsentActivity}.', '     */', '    public SigninPromoController(', '            @AccessPoint int accessPoint, SyncConsentActivityLauncher syncConsentActivityLauncher) {', '        mAccessPoint = accessPoint;', '        mSyncConsentActivityLauncher = syncConsentActivityLauncher;', '        switch (mAccessPoint) {', '            case SigninAccessPoint.BOOKMARK_MANAGER:', '                mImpressionCountHistogramName = ""Signin.Promo.Other.ShownAfterImpressions"";']}, {'a': ['                mContinuedAfterImpressionCountHistogramName ='], 'b': ['                mSigninAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Other.ContinuedAfterImpressions"";']}, {'a': ['                mDismissedAfterImpressionCountHistogramName ='], 'b': ['                mDismissedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Other.DismissedAfterImpressions"";', '                mImpressionCountName =', '                        ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_BOOKMARKS;', '                mImpressionUserActionName = ""Signin_Impression_FromBookmarkManager"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromBookmarkManager"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromBookmarkManager"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromBookmarkManager"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromBookmarkManager"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromBookmarkManager"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED;', '                mImpressionsTilDismissHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilDismiss"";', '                mImpressionsTilSigninButtonsHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilSigninButtons"";', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.BookmarkManager.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_bookmarks;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_bookmarks_no_account;', '                break;', '            case SigninAccessPoint.NTP_CONTENT_SUGGESTIONS:', '                mImpressionCountHistogramName = ""Signin.Promo.NTP.ShownAfterImpressions"";']}, {'a': ['                mContinuedAfterImpressionCountHistogramName =', '                        ""Signin.Promo.NTP.ContinuedAfterImpressions"";', '                mDismissedAfterImpressionCountHistogramName ='], 'b': ['                mSigninAfterImpressionsHistogramName = ""Signin.Promo.NTP.ContinuedAfterImpressions"";', '                mDismissedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.NTP.DismissedAfterImpressions"";', '                mImpressionCountName = ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_NTP;', '                mImpressionUserActionName = ""Signin_Impression_FromNTPContentSuggestions"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromNTPContentSuggestions"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromNTPContentSuggestions"";', '                mSigninWithDefaultUserActionName =', '                        ""Signin_SigninWithDefault_FromNTPContentSuggestions"";', '                mSigninNotDefaultUserActionName =', '                        ""Signin_SigninNotDefault_FromNTPContentSuggestions"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromNTPContentSuggestions"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_PROMO_DISMISSED;', '                mImpressionsTilDismissHistogramName = null;', '                mImpressionsTilSigninButtonsHistogramName = null;', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.NTPContentSuggestions.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_ntp_content_suggestions;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_ntp_content_suggestions_no_account;', '                break;', '            case SigninAccessPoint.RECENT_TABS:', '                mImpressionCountHistogramName = ""Signin.Promo.Other.ShownAfterImpressions"";']}, {'a': ['                mContinuedAfterImpressionCountHistogramName ='], 'b': ['                mSigninAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Other.ContinuedAfterImpressions"";', ""                // Recent Tabs promos can't be dismissed.""]}, {'a': ['                mDismissedAfterImpressionCountHistogramName = null;'], 'b': ['                mDismissedAfterImpressionsHistogramName = null;']}, {'ab': ['                // There is no impression limit for Recent Tabs.', '                mImpressionCountName = null;', '                mImpressionUserActionName = ""Signin_Impression_FromRecentTabs"";', '                mImpressionWithAccountUserActionName =', '                        ""Signin_ImpressionWithAccount_FromRecentTabs"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromRecentTabs"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromRecentTabs"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromRecentTabs"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromRecentTabs"";', '                mSyncPromoDismissedPreferenceTracker = null;', '                mImpressionsTilDismissHistogramName = null;', '                mImpressionsTilSigninButtonsHistogramName = null;', '                mImpressionsTilXButtonHistogramName = null;', '                mDescriptionStringId = R.string.signin_promo_description_recent_tabs;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_recent_tabs_no_account;', '                break;', '            case SigninAccessPoint.SETTINGS:', '                mImpressionCountHistogramName = ""Signin.Promo.Settings.ShownAfterImpressions"";']}, {'a': ['                mContinuedAfterImpressionCountHistogramName ='], 'b': ['                mSigninAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Settings.ContinuedAfterImpressions"";']}, {'a': ['                mDismissedAfterImpressionCountHistogramName ='], 'b': ['                mDismissedAfterImpressionsHistogramName =']}, {'ab': ['                        ""Signin.Promo.Settings.DismissedAfterImpressions"";', '                mImpressionCountName = ChromePreferenceKeys.SIGNIN_PROMO_IMPRESSIONS_COUNT_SETTINGS;', '                mImpressionUserActionName = ""Signin_Impression_FromSettings"";', '                mImpressionWithAccountUserActionName = ""Signin_ImpressionWithAccount_FromSettings"";', '                mSigninWithDefaultUserActionName = ""Signin_SigninWithDefault_FromSettings"";', '                mSigninNotDefaultUserActionName = ""Signin_SigninNotDefault_FromSettings"";', '                // On Android, the promo does not have a button to add and account when there is', '                // already an account on the device. Always use the NoExistingAccount variant.', '                mSigninNewAccountUserActionName =', '                        ""Signin_SigninNewAccountNoExistingAccount_FromSettings"";', '                mImpressionWithNoAccountUserActionName =', '                        ""Signin_ImpressionWithNoAccount_FromSettings"";', '                mSyncPromoDismissedPreferenceTracker =', '                        ChromePreferenceKeys.SIGNIN_PROMO_SETTINGS_PERSONALIZED_DISMISSED;', '                mImpressionsTilDismissHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilDismiss"";', '                mImpressionsTilSigninButtonsHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilSigninButtons"";', '                mImpressionsTilXButtonHistogramName =', '                        ""MobileSignInPromo.SettingsManager.ImpressionsTilXButton"";', '                mDescriptionStringId = R.string.signin_promo_description_settings;', '                mDescriptionStringIdNoAccount =', '                        R.string.signin_promo_description_settings_no_account;', '                break;', '            default:', '                throw new IllegalArgumentException(', '                        ""Unexpected value for access point: "" + mAccessPoint);', '        }', '    }', '', '    /**', '     * Sets up the sync promo view.', '     * @param profileDataCache The {@link ProfileDataCache} that stores profile data.', '     * @param view The {@link PersonalizedSigninPromoView} that should be set up.', '     * @param listener The {@link SigninPromoController.OnDismissListener} to be set to the view.', '     */', '    public void setUpSyncPromoView(ProfileDataCache profileDataCache,', '            PersonalizedSigninPromoView view, SigninPromoController.OnDismissListener listener) {', '        final IdentityManager identityManager = IdentityServicesProvider.get().getIdentityManager(', '                Profile.getLastUsedRegularProfile());', '        assert !identityManager.hasPrimaryAccount(ConsentLevel.SYNC) : ""Sync is already enabled!"";', '', '        final @Nullable Account visibleAccount = getVisibleAccount();', '        // Set up the sync promo', '        if (visibleAccount == null) {', '            setupPromoView(view, /* profileData= */ null, listener);', '            return;', '        }', '        setupPromoView(', '                view, profileDataCache.getProfileDataOrDefault(visibleAccount.name), listener);', '    }', '', '    /**', '     * Called when the signin promo is destroyed.', '     */', '    public void onPromoDestroyed() {', '        if (!mWasDisplayed || mWasUsed || mImpressionsTilDismissHistogramName == null) {', '            return;', '        }', '        RecordHistogram.recordCount100Histogram(', '                mImpressionsTilDismissHistogramName, getNumImpressions());', '    }', '', '    /**', '     * Configures the signin promo view and resets the impression tracker. If this controller has', '     * been previously set up.', '     * @param view The view in which the promo will be added.', '     * @param profileData If not null, the promo will be configured to be in the hot state, using', '     *         the account image, email and full name of the user to set the picture and the text of', '     *         the promo appropriately. Otherwise, the promo will be in the cold state.', '     * @param onDismissListener Listener which handles the action of dismissing the promo. A null', '     *         onDismissListener marks that the promo is not dismissible and as a result the close', '     *         button is hidden.', '     */', '    private void setupPromoView(PersonalizedSigninPromoView view,', '            final @Nullable DisplayableProfileData profileData,', '            final @Nullable OnDismissListener onDismissListener) {', '        if (mImpressionTracker != null) {', '            mImpressionTracker.setListener(null);', '            mImpressionTracker = null;', '        }', '        mImpressionTracker = new ImpressionTracker(view);', '        mImpressionTracker.setListener(', '                new OneShotImpressionListener(this::recordSigninPromoImpression));', '', '        mProfileData = profileData;', '        mWasDisplayed = true;', '        if (mProfileData == null) {', '            setupColdState(view);', '        } else {', '            setupHotState(view);', '        }', '', '        if (onDismissListener != null) {', '            view.getDismissButton().setVisibility(View.VISIBLE);', '            view.getDismissButton().setOnClickListener(promoView -> {', '                assert mImpressionsTilXButtonHistogramName != null;', '                assert mSyncPromoDismissedPreferenceTracker != null;', '                mWasUsed = true;', '                RecordHistogram.recordCount100Histogram(', '                        mImpressionsTilXButtonHistogramName, getNumImpressions());', '                SharedPreferencesManager.getInstance().writeBoolean(', '                        mSyncPromoDismissedPreferenceTracker, true);']}, {'a': ['                recordImpressionCountHistogram(mDismissedAfterImpressionCountHistogramName);'], 'b': ['                recordImpressionCountHistogram(mDismissedAfterImpressionsHistogramName);']}, {'ab': ['                onDismissListener.onDismiss();', '            });', '        } else {', '            view.getDismissButton().setVisibility(View.GONE);', '        }', '    }', '', '    /**', ""     * Should be called when the view is not in use anymore (e.g. it's being recycled)."", '     */', '    public void detach() {', '        if (mImpressionTracker != null) {', '            mImpressionTracker.setListener(null);', '            mImpressionTracker = null;', '        }', '    }', '', '    /** Increases promo show count by one. */', '    public void increasePromoShowCount() {', '        if (mAccessPoint != SigninAccessPoint.RECENT_TABS) {', '            SharedPreferencesManager.getInstance().incrementInt(', '                    getPromoShowCountPreferenceName(mAccessPoint));', '        }', '        SharedPreferencesManager.getInstance().incrementInt(', '                ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT);', '        recordImpressionCountHistogram(mImpressionCountHistogramName);', '', '        if (mAccessPoint == SigninAccessPoint.NTP_CONTENT_SUGGESTIONS) {', '            final long currentTime = System.currentTimeMillis();', '            if (SharedPreferencesManager.getInstance().readLong(', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME)', '                    == 0) {', '                SharedPreferencesManager.getInstance().writeLong(', '                        ChromePreferenceKeys.SIGNIN_PROMO_NTP_FIRST_SHOWN_TIME, currentTime);', '            }', '            SharedPreferencesManager.getInstance().writeLong(', '                    ChromePreferenceKeys.SIGNIN_PROMO_NTP_LAST_SHOWN_TIME, currentTime);', '        }', '    }', '', '    private void setupColdState(PersonalizedSigninPromoView view) {', '        final Context context = view.getContext();', '        view.getImage().setImageResource(R.drawable.chrome_sync_logo);', '        setImageSize(context, view, R.dimen.signin_promo_cold_state_image_size);', '', '        view.getDescription().setText(mDescriptionStringIdNoAccount);', '', '        view.getPrimaryButton().setText(R.string.sync_promo_turn_on_sync);', '        view.getPrimaryButton().setOnClickListener(v -> signinWithNewAccount(context));', '', '        view.getSecondaryButton().setVisibility(View.GONE);', '    }', '', '    private void setupHotState(PersonalizedSigninPromoView view) {', '        final Context context = view.getContext();', '        Drawable accountImage = mProfileData.getImage();', '        view.getImage().setImageDrawable(accountImage);', '        setImageSize(context, view, R.dimen.signin_promo_account_image_size);', '', '        view.getDescription().setText(mDescriptionStringId);', '', '        view.getPrimaryButton().setOnClickListener(v -> signinWithDefaultAccount(context));', '        if (IdentityServicesProvider.get()', '                        .getIdentityManager(Profile.getLastUsedRegularProfile())', '                        .hasPrimaryAccount(ConsentLevel.SIGNIN)) {', '            view.getPrimaryButton().setText(R.string.sync_promo_turn_on_sync);', '            view.getSecondaryButton().setVisibility(View.GONE);', '        } else {', '            final String primaryButtonText =', '                    ChromeFeatureList.isEnabled(', '                            ChromeFeatureList.MOBILE_IDENTITY_CONSISTENCY_PROMOS)', '                    ? context.getString(R.string.signin_promo_continue_as,', '                            mProfileData.getGivenNameOrFullNameOrEmail())', '                    : context.getString(R.string.sync_promo_turn_on_sync);', '            view.getPrimaryButton().setText(primaryButtonText);', '', '            view.getSecondaryButton().setText(R.string.signin_promo_choose_another_account);', '            view.getSecondaryButton().setOnClickListener(v -> signinWithNotDefaultAccount(context));', '            view.getSecondaryButton().setVisibility(View.VISIBLE);', '        }', '    }', '', '    private int getNumImpressions() {', '        return SharedPreferencesManager.getInstance().readInt(mImpressionCountName);', '    }', '', '    private void signinWithNewAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninNewAccountUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoAddAccountFlow(context, mAccessPoint);', '    }', '', '    private void signinWithDefaultAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninWithDefaultUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoDefaultFlow(', '                context, mAccessPoint, mProfileData.getAccountEmail());', '    }', '', '    private void signinWithNotDefaultAccount(Context context) {', '        recordSigninButtonUsed();', '        RecordUserAction.record(mSigninNotDefaultUserActionName);', '        mSyncConsentActivityLauncher.launchActivityForPromoChooseAccountFlow(', '                context, mAccessPoint, mProfileData.getAccountEmail());', '    }', '', '    private void recordSigninButtonUsed() {', '        mWasUsed = true;']}, {'a': ['        recordImpressionCountHistogram(mContinuedAfterImpressionCountHistogramName);'], 'b': ['        recordImpressionCountHistogram(mSigninAfterImpressionsHistogramName);']}, {'ab': ['        if (mImpressionsTilSigninButtonsHistogramName != null) {', '            RecordHistogram.recordCount100Histogram(', '                    mImpressionsTilSigninButtonsHistogramName, getNumImpressions());', '        }', '    }', '', '    private void recordImpressionCountHistogram(String histogramName) {', '        RecordHistogram.recordExactLinearHistogram(histogramName,', '                SharedPreferencesManager.getInstance().readInt(', '                        ChromePreferenceKeys.SYNC_PROMO_TOTAL_SHOW_COUNT),', '                MAX_TOTAL_PROMO_SHOW_COUNT);', '    }', '', '    private void setImageSize(', '            Context context, PersonalizedSigninPromoView view, @DimenRes int dimenResId) {', '        ViewGroup.LayoutParams layoutParams = view.getImage().getLayoutParams();', '        layoutParams.height = context.getResources().getDimensionPixelSize(dimenResId);', '        layoutParams.width = context.getResources().getDimensionPixelSize(dimenResId);', '        view.getImage().setLayoutParams(layoutParams);', '    }', '', '    private void recordSigninPromoImpression() {', '        RecordUserAction.record(mImpressionUserActionName);', '        if (mProfileData == null) {', '            RecordUserAction.record(mImpressionWithNoAccountUserActionName);', '        } else {', '            RecordUserAction.record(mImpressionWithAccountUserActionName);', '        }', '', '        // If mImpressionCountName is not null then we should record impressions.', '        if (mImpressionCountName != null) {', '            SharedPreferencesManager.getInstance().incrementInt(mImpressionCountName);', '        }', '    }', '', '    @VisibleForTesting', '    public static void setPrefSigninPromoDeclinedBookmarksForTests(boolean isDeclined) {', '        SharedPreferencesManager.getInstance().writeBoolean(', '                ChromePreferenceKeys.SIGNIN_PROMO_BOOKMARKS_DECLINED, isDeclined);', '    }', '', '    @VisibleForTesting', '    public static int getMaxImpressionsBookmarksForTests() {', '        return MAX_IMPRESSIONS_BOOKMARKS;', '    }', '}', '']}]",chromium%2Fsrc~main~I23061b243395b039a3757d5b40679f388a32c23f,2c6d8db935d052a5ccac1cdbbba574f7c342219a,chrome/browser/signin/ui/android/java/src/org/chromium/chrome/browser/signin/ui/SigninPromoController.java,6bed6b34_e7d40185_before.java,6bed6b34_e7d40185_after.java,SigninPromoController::SigninPromoController,True,True
36,d9bf9954_21f98b78,64.0,"Why this late change?
1) Did you mean != 0 in the check?
2) It looks like it can never be 0 anyway? https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/data/AuthenticatorOption.java;l=85;drc=0f7b26dc2dcf3aa5098a852fc2c02329b25ad98d",57.0,64.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', 'import android.view.LayoutInflater;', 'import android.view.View;', 'import android.view.ViewGroup;', 'import android.widget.ImageView;', 'import android.widget.RadioButton;', 'import android.widget.TextView;', '', 'import androidx.core.content.res.ResourcesCompat;', 'import androidx.recyclerview.widget.RecyclerView;', 'import androidx.recyclerview.widget.RecyclerView.ViewHolder;', '', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', '', 'import java.util.List;', '', '/** Adapter for showing the authenticator options in a {@link RecyclerView}. */', 'public class AuthenticatorOptionsAdapter extends RecyclerView.Adapter<ViewHolder> {', '    /** Interface for callers to be notified when an item is selected. */', '    public interface ItemClickListener {', '        void onItemClicked(AuthenticatorOption option);', '    }', '', '    private final List<AuthenticatorOption> mAuthenticatorOptions;', '    private final ItemClickListener mItemClickListener;', '    private final Context mContext;', '', '    private int mSelectedAuthenticatorIndex;', '', '    public AuthenticatorOptionsAdapter(Context context,', '            List<AuthenticatorOption> authenticatorOptions, ItemClickListener itemClickListener) {', '        this.mAuthenticatorOptions = authenticatorOptions;', '        this.mItemClickListener = itemClickListener;', '        this.mContext = context;', '    }', '', '    @Override', '    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {', '        View view = LayoutInflater.from(parent.getContext())', '                            .inflate(R.layout.authenticator_option, parent, false);', '        return new AuthenticatorOptionViewHolder(view, mItemClickListener);', '    }', '', '    @Override', '    public void onBindViewHolder(ViewHolder viewHolder, final int position) {', '        AuthenticatorOptionViewHolder holder = (AuthenticatorOptionViewHolder) viewHolder;', '        AuthenticatorOption option = mAuthenticatorOptions.get(position);', '        if (getItemCount() == 1) {', '            holder.getRadioButton().setVisibility(View.GONE);', '            int iconResId = option.getIconResId();']}, {'a': ['            if (iconResId != 0) {'], 'b': ['            if (iconResId == 0) {']}, {'ab': ['                holder.getIconImageView().setVisibility(View.VISIBLE);', '                holder.getIconImageView().setImageDrawable(ResourcesCompat.getDrawable(', '                        mContext.getResources(), iconResId, mContext.getTheme()));', '            } else {', '                holder.getIconImageView().setVisibility(View.GONE);', '            }', '        } else {', '            holder.getIconImageView().setVisibility(View.GONE);', '            holder.getRadioButton().setVisibility(View.VISIBLE);', '            holder.getRadioButton().setChecked(position == mSelectedAuthenticatorIndex);', '        }', '        holder.getTitleTextView().setText(option.getTitle());', '        holder.getDescriptionTextView().setText(option.getDescription());', '    }', '', '    @Override', '    public int getItemCount() {', '        return mAuthenticatorOptions.size();', '    }', '', '    class AuthenticatorOptionViewHolder extends RecyclerView.ViewHolder {', '        private final TextView mTitleTextView;', '        private final TextView mDescriptionTextView;', '        private final ImageView mIconImageView;', '        private final RadioButton mRadioButton;', '', '        AuthenticatorOptionViewHolder(View view, ItemClickListener itemClickListener) {', '            super(view);', '            mTitleTextView = view.findViewById(R.id.authenticator_option_title);', '            mDescriptionTextView = view.findViewById(R.id.authenticator_option_description);', '            mIconImageView = view.findViewById(R.id.authenticator_option_icon);', '            mRadioButton = view.findViewById(R.id.authenticator_option_radio_btn);', '            mRadioButton.setOnClickListener(radioButtonView -> {', '                int lastAuthenticatorIndex = mSelectedAuthenticatorIndex;', '                mSelectedAuthenticatorIndex = getAdapterPosition();', '                // Update both the previous and the current selection so that the radio button is', '                // updated.', '                notifyItemChanged(lastAuthenticatorIndex);', '                notifyItemChanged(mSelectedAuthenticatorIndex);', '                itemClickListener.onItemClicked(', '                        mAuthenticatorOptions.get(mSelectedAuthenticatorIndex));', '            });', '        }', '', '        public TextView getTitleTextView() {', '            return mTitleTextView;', '        }', '', '        public TextView getDescriptionTextView() {', '            return mDescriptionTextView;', '        }', '', '        public ImageView getIconImageView() {', '            return mIconImageView;', '        }', '', '        public RadioButton getRadioButton() {', '            return mRadioButton;', '        }', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,2125e5b302625020ff4247f18c2050f913aa9a7c,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorOptionsAdapter.java,d9bf9954_21f98b78_before.java,d9bf9954_21f98b78_after.java,AuthenticatorOptionsAdapter::onBindViewHolder,True,True
37,e39333af_38929a00,64.0,"This change came out of this discussion: https://chromium-review.googlesource.com/c/chromium/src/+/3192612/comments/1352903e_913850c6

I've fixed the logic error, and I've removed the assertion from AuthenticatorOption.java.

Thanks for catching this!",57.0,64.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', 'import android.view.LayoutInflater;', 'import android.view.View;', 'import android.view.ViewGroup;', 'import android.widget.ImageView;', 'import android.widget.RadioButton;', 'import android.widget.TextView;', '', 'import androidx.core.content.res.ResourcesCompat;', 'import androidx.recyclerview.widget.RecyclerView;', 'import androidx.recyclerview.widget.RecyclerView.ViewHolder;', '', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', '', 'import java.util.List;', '', '/** Adapter for showing the authenticator options in a {@link RecyclerView}. */', 'public class AuthenticatorOptionsAdapter extends RecyclerView.Adapter<ViewHolder> {', '    /** Interface for callers to be notified when an item is selected. */', '    public interface ItemClickListener {', '        void onItemClicked(AuthenticatorOption option);', '    }', '', '    private final List<AuthenticatorOption> mAuthenticatorOptions;', '    private final ItemClickListener mItemClickListener;', '    private final Context mContext;', '', '    private int mSelectedAuthenticatorIndex;', '', '    public AuthenticatorOptionsAdapter(Context context,', '            List<AuthenticatorOption> authenticatorOptions, ItemClickListener itemClickListener) {', '        this.mAuthenticatorOptions = authenticatorOptions;', '        this.mItemClickListener = itemClickListener;', '        this.mContext = context;', '    }', '', '    @Override', '    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {', '        View view = LayoutInflater.from(parent.getContext())', '                            .inflate(R.layout.authenticator_option, parent, false);', '        return new AuthenticatorOptionViewHolder(view, mItemClickListener);', '    }', '', '    @Override', '    public void onBindViewHolder(ViewHolder viewHolder, final int position) {', '        AuthenticatorOptionViewHolder holder = (AuthenticatorOptionViewHolder) viewHolder;', '        AuthenticatorOption option = mAuthenticatorOptions.get(position);', '        if (getItemCount() == 1) {', '            holder.getRadioButton().setVisibility(View.GONE);', '            int iconResId = option.getIconResId();']}, {'a': ['            if (iconResId != 0) {'], 'b': ['            if (iconResId == 0) {']}, {'ab': ['                holder.getIconImageView().setVisibility(View.VISIBLE);', '                holder.getIconImageView().setImageDrawable(ResourcesCompat.getDrawable(', '                        mContext.getResources(), iconResId, mContext.getTheme()));', '            } else {', '                holder.getIconImageView().setVisibility(View.GONE);', '            }', '        } else {', '            holder.getIconImageView().setVisibility(View.GONE);', '            holder.getRadioButton().setVisibility(View.VISIBLE);', '            holder.getRadioButton().setChecked(position == mSelectedAuthenticatorIndex);', '        }', '        holder.getTitleTextView().setText(option.getTitle());', '        holder.getDescriptionTextView().setText(option.getDescription());', '    }', '', '    @Override', '    public int getItemCount() {', '        return mAuthenticatorOptions.size();', '    }', '', '    class AuthenticatorOptionViewHolder extends RecyclerView.ViewHolder {', '        private final TextView mTitleTextView;', '        private final TextView mDescriptionTextView;', '        private final ImageView mIconImageView;', '        private final RadioButton mRadioButton;', '', '        AuthenticatorOptionViewHolder(View view, ItemClickListener itemClickListener) {', '            super(view);', '            mTitleTextView = view.findViewById(R.id.authenticator_option_title);', '            mDescriptionTextView = view.findViewById(R.id.authenticator_option_description);', '            mIconImageView = view.findViewById(R.id.authenticator_option_icon);', '            mRadioButton = view.findViewById(R.id.authenticator_option_radio_btn);', '            mRadioButton.setOnClickListener(radioButtonView -> {', '                int lastAuthenticatorIndex = mSelectedAuthenticatorIndex;', '                mSelectedAuthenticatorIndex = getAdapterPosition();', '                // Update both the previous and the current selection so that the radio button is', '                // updated.', '                notifyItemChanged(lastAuthenticatorIndex);', '                notifyItemChanged(mSelectedAuthenticatorIndex);', '                itemClickListener.onItemClicked(', '                        mAuthenticatorOptions.get(mSelectedAuthenticatorIndex));', '            });', '        }', '', '        public TextView getTitleTextView() {', '            return mTitleTextView;', '        }', '', '        public TextView getDescriptionTextView() {', '            return mDescriptionTextView;', '        }', '', '        public ImageView getIconImageView() {', '            return mIconImageView;', '        }', '', '        public RadioButton getRadioButton() {', '            return mRadioButton;', '        }', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,2125e5b302625020ff4247f18c2050f913aa9a7c,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorOptionsAdapter.java,e39333af_38929a00_before.java,e39333af_38929a00_after.java,AuthenticatorOptionsAdapter::onBindViewHolder,True,True
38,ccc0eec1_c716bbe1,64.0,"I missed that it can't be 0 anyway. In that case, we'd need to either throw an exception while creating the AuthenticatorSelectionDialogBridge or allow the iconResId to be 0.

Personally, I'd prefer the latter as when there are multiple authenticators, then we use radio buttons instead of the iconResId.",57.0,64.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', 'import android.view.LayoutInflater;', 'import android.view.View;', 'import android.view.ViewGroup;', 'import android.widget.ImageView;', 'import android.widget.RadioButton;', 'import android.widget.TextView;', '', 'import androidx.core.content.res.ResourcesCompat;', 'import androidx.recyclerview.widget.RecyclerView;', 'import androidx.recyclerview.widget.RecyclerView.ViewHolder;', '', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', '', 'import java.util.List;', '', '/** Adapter for showing the authenticator options in a {@link RecyclerView}. */', 'public class AuthenticatorOptionsAdapter extends RecyclerView.Adapter<ViewHolder> {', '    /** Interface for callers to be notified when an item is selected. */', '    public interface ItemClickListener {', '        void onItemClicked(AuthenticatorOption option);', '    }', '', '    private final List<AuthenticatorOption> mAuthenticatorOptions;', '    private final ItemClickListener mItemClickListener;', '    private final Context mContext;', '', '    private int mSelectedAuthenticatorIndex;', '', '    public AuthenticatorOptionsAdapter(Context context,', '            List<AuthenticatorOption> authenticatorOptions, ItemClickListener itemClickListener) {', '        this.mAuthenticatorOptions = authenticatorOptions;', '        this.mItemClickListener = itemClickListener;', '        this.mContext = context;', '    }', '', '    @Override', '    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {', '        View view = LayoutInflater.from(parent.getContext())', '                            .inflate(R.layout.authenticator_option, parent, false);', '        return new AuthenticatorOptionViewHolder(view, mItemClickListener);', '    }', '', '    @Override', '    public void onBindViewHolder(ViewHolder viewHolder, final int position) {', '        AuthenticatorOptionViewHolder holder = (AuthenticatorOptionViewHolder) viewHolder;', '        AuthenticatorOption option = mAuthenticatorOptions.get(position);', '        if (getItemCount() == 1) {', '            holder.getRadioButton().setVisibility(View.GONE);', '            int iconResId = option.getIconResId();']}, {'a': ['            if (iconResId != 0) {'], 'b': ['            if (iconResId == 0) {']}, {'ab': ['                holder.getIconImageView().setVisibility(View.VISIBLE);', '                holder.getIconImageView().setImageDrawable(ResourcesCompat.getDrawable(', '                        mContext.getResources(), iconResId, mContext.getTheme()));', '            } else {', '                holder.getIconImageView().setVisibility(View.GONE);', '            }', '        } else {', '            holder.getIconImageView().setVisibility(View.GONE);', '            holder.getRadioButton().setVisibility(View.VISIBLE);', '            holder.getRadioButton().setChecked(position == mSelectedAuthenticatorIndex);', '        }', '        holder.getTitleTextView().setText(option.getTitle());', '        holder.getDescriptionTextView().setText(option.getDescription());', '    }', '', '    @Override', '    public int getItemCount() {', '        return mAuthenticatorOptions.size();', '    }', '', '    class AuthenticatorOptionViewHolder extends RecyclerView.ViewHolder {', '        private final TextView mTitleTextView;', '        private final TextView mDescriptionTextView;', '        private final ImageView mIconImageView;', '        private final RadioButton mRadioButton;', '', '        AuthenticatorOptionViewHolder(View view, ItemClickListener itemClickListener) {', '            super(view);', '            mTitleTextView = view.findViewById(R.id.authenticator_option_title);', '            mDescriptionTextView = view.findViewById(R.id.authenticator_option_description);', '            mIconImageView = view.findViewById(R.id.authenticator_option_icon);', '            mRadioButton = view.findViewById(R.id.authenticator_option_radio_btn);', '            mRadioButton.setOnClickListener(radioButtonView -> {', '                int lastAuthenticatorIndex = mSelectedAuthenticatorIndex;', '                mSelectedAuthenticatorIndex = getAdapterPosition();', '                // Update both the previous and the current selection so that the radio button is', '                // updated.', '                notifyItemChanged(lastAuthenticatorIndex);', '                notifyItemChanged(mSelectedAuthenticatorIndex);', '                itemClickListener.onItemClicked(', '                        mAuthenticatorOptions.get(mSelectedAuthenticatorIndex));', '            });', '        }', '', '        public TextView getTitleTextView() {', '            return mTitleTextView;', '        }', '', '        public TextView getDescriptionTextView() {', '            return mDescriptionTextView;', '        }', '', '        public ImageView getIconImageView() {', '            return mIconImageView;', '        }', '', '        public RadioButton getRadioButton() {', '            return mRadioButton;', '        }', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,2125e5b302625020ff4247f18c2050f913aa9a7c,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorOptionsAdapter.java,ccc0eec1_c716bbe1_before.java,ccc0eec1_c716bbe1_after.java,AuthenticatorOptionsAdapter::onBindViewHolder,True,True
39,aef60e12_40ecd0bb,64.0,"Ok thanks.  I'll defer to Android experts/owners on if removing the assert is fine, but from the comment thread you linked it sounds like that's the desired approach.",57.0,64.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', 'import android.view.LayoutInflater;', 'import android.view.View;', 'import android.view.ViewGroup;', 'import android.widget.ImageView;', 'import android.widget.RadioButton;', 'import android.widget.TextView;', '', 'import androidx.core.content.res.ResourcesCompat;', 'import androidx.recyclerview.widget.RecyclerView;', 'import androidx.recyclerview.widget.RecyclerView.ViewHolder;', '', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', '', 'import java.util.List;', '', '/** Adapter for showing the authenticator options in a {@link RecyclerView}. */', 'public class AuthenticatorOptionsAdapter extends RecyclerView.Adapter<ViewHolder> {', '    /** Interface for callers to be notified when an item is selected. */', '    public interface ItemClickListener {', '        void onItemClicked(AuthenticatorOption option);', '    }', '', '    private final List<AuthenticatorOption> mAuthenticatorOptions;', '    private final ItemClickListener mItemClickListener;', '    private final Context mContext;', '', '    private int mSelectedAuthenticatorIndex;', '', '    public AuthenticatorOptionsAdapter(Context context,', '            List<AuthenticatorOption> authenticatorOptions, ItemClickListener itemClickListener) {', '        this.mAuthenticatorOptions = authenticatorOptions;', '        this.mItemClickListener = itemClickListener;', '        this.mContext = context;', '    }', '', '    @Override', '    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {', '        View view = LayoutInflater.from(parent.getContext())', '                            .inflate(R.layout.authenticator_option, parent, false);', '        return new AuthenticatorOptionViewHolder(view, mItemClickListener);', '    }', '', '    @Override', '    public void onBindViewHolder(ViewHolder viewHolder, final int position) {', '        AuthenticatorOptionViewHolder holder = (AuthenticatorOptionViewHolder) viewHolder;', '        AuthenticatorOption option = mAuthenticatorOptions.get(position);', '        if (getItemCount() == 1) {', '            holder.getRadioButton().setVisibility(View.GONE);', '            int iconResId = option.getIconResId();']}, {'a': ['            if (iconResId != 0) {'], 'b': ['            if (iconResId == 0) {']}, {'ab': ['                holder.getIconImageView().setVisibility(View.VISIBLE);', '                holder.getIconImageView().setImageDrawable(ResourcesCompat.getDrawable(', '                        mContext.getResources(), iconResId, mContext.getTheme()));', '            } else {', '                holder.getIconImageView().setVisibility(View.GONE);', '            }', '        } else {', '            holder.getIconImageView().setVisibility(View.GONE);', '            holder.getRadioButton().setVisibility(View.VISIBLE);', '            holder.getRadioButton().setChecked(position == mSelectedAuthenticatorIndex);', '        }', '        holder.getTitleTextView().setText(option.getTitle());', '        holder.getDescriptionTextView().setText(option.getDescription());', '    }', '', '    @Override', '    public int getItemCount() {', '        return mAuthenticatorOptions.size();', '    }', '', '    class AuthenticatorOptionViewHolder extends RecyclerView.ViewHolder {', '        private final TextView mTitleTextView;', '        private final TextView mDescriptionTextView;', '        private final ImageView mIconImageView;', '        private final RadioButton mRadioButton;', '', '        AuthenticatorOptionViewHolder(View view, ItemClickListener itemClickListener) {', '            super(view);', '            mTitleTextView = view.findViewById(R.id.authenticator_option_title);', '            mDescriptionTextView = view.findViewById(R.id.authenticator_option_description);', '            mIconImageView = view.findViewById(R.id.authenticator_option_icon);', '            mRadioButton = view.findViewById(R.id.authenticator_option_radio_btn);', '            mRadioButton.setOnClickListener(radioButtonView -> {', '                int lastAuthenticatorIndex = mSelectedAuthenticatorIndex;', '                mSelectedAuthenticatorIndex = getAdapterPosition();', '                // Update both the previous and the current selection so that the radio button is', '                // updated.', '                notifyItemChanged(lastAuthenticatorIndex);', '                notifyItemChanged(mSelectedAuthenticatorIndex);', '                itemClickListener.onItemClicked(', '                        mAuthenticatorOptions.get(mSelectedAuthenticatorIndex));', '            });', '        }', '', '        public TextView getTitleTextView() {', '            return mTitleTextView;', '        }', '', '        public TextView getDescriptionTextView() {', '            return mDescriptionTextView;', '        }', '', '        public ImageView getIconImageView() {', '            return mIconImageView;', '        }', '', '        public RadioButton getRadioButton() {', '            return mRadioButton;', '        }', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,2125e5b302625020ff4247f18c2050f913aa9a7c,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorOptionsAdapter.java,aef60e12_40ecd0bb_before.java,aef60e12_40ecd0bb_after.java,AuthenticatorOptionsAdapter::onBindViewHolder,True,True
44,3c9dffbe_11cfa28e,102.0,remove addition,102.0,102.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', 'import android.view.LayoutInflater;', 'import android.view.View;', '', 'import androidx.core.content.res.ResourcesCompat;', 'import androidx.recyclerview.widget.RecyclerView;', '', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', 'import org.chromium.ui.modaldialog.ModalDialogProperties;', 'import org.chromium.ui.modelutil.PropertyModel;', '', 'import java.util.List;', '', '/**', ' * Dialog that presents {@link AuthenticatorOption}s to the user to choose from for fetching credit', ' * card information from the backend.', ' */', 'public class AuthenticatorSelectionDialog implements AuthenticatorOptionsAdapter.ItemClickListener {', '    private static final int ANIMATION_DURATION_MS = 250;', '    /** Interface for the caller to be notified of user actions. */', '    public interface Listener {', '        /** Notify that the user selected an authenticator option. */', '        void onOptionSelected(String authenticatorOptionIdentifier);', '        /** Notify that the dialog was dismissed. */', '        void onDialogDismissed();', '    }', '', '    private final ModalDialogProperties.Controller mModalDialogController =', '            new ModalDialogProperties.Controller() {', '                @Override', '                public void onClick(PropertyModel model, int buttonType) {', '                    switch (buttonType) {', '                        case ModalDialogProperties.ButtonType.POSITIVE:', '                            mListener.onOptionSelected(', '                                    mSelectedAuthenticatorOption.getIdentifier());', '                            showProgressBarOverlay();', '                            break;', '                        case ModalDialogProperties.ButtonType.NEGATIVE:', '                            mModalDialogManager.dismissDialog(', '                                    model, DialogDismissalCause.NEGATIVE_BUTTON_CLICKED);', '                            break;', '                    }', '                }', '', '                @Override', '                public void onDismiss(PropertyModel model, int dismissalCause) {', '                    mListener.onDialogDismissed();', '                }', '            };', '', '    private final Context mContext;', '    private final Listener mListener;', '    private final ModalDialogManager mModalDialogManager;', '    private View mProgressBarOverlayView;', '    private View mAuthenticatorSelectionDialogContentsView;', '    private RecyclerView mAuthenticationOptionsRecyclerView;', '    private AuthenticatorOptionsAdapter mAuthenticatorOptionsAdapter;', '', '    private PropertyModel mDialogModel;', '    private AuthenticatorOption mSelectedAuthenticatorOption;', '', '    public AuthenticatorSelectionDialog(', '            Context context, Listener listener, ModalDialogManager modalDialogManager) {', '        this.mContext = context;', '        this.mListener = listener;', '        this.mModalDialogManager = modalDialogManager;', '    }', '', '    @Override', '    public void onItemClicked(AuthenticatorOption option) {', '        mSelectedAuthenticatorOption = option;', '    }', '', '    /**', '     * Shows an Authenticator Selection dialog.', '     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        // By default, the first option will be selected.', '        mSelectedAuthenticatorOption = authenticatorOptions.get(0);', '        View view = LayoutInflater.from(mContext).inflate(', '                R.layout.authenticator_selection_dialog, null);', '        mAuthenticatorSelectionDialogContentsView =', '                view.findViewById(R.id.authenticator_selection_dialog_contents);', '        mProgressBarOverlayView = view.findViewById(R.id.progress_bar_overlay);', '        mProgressBarOverlayView.setVisibility(View.GONE);', '        // Set up the recycler view.', '        mAuthenticationOptionsRecyclerView =', '                (RecyclerView) view.findViewById(R.id.authenticator_options_view);', '        mAuthenticatorOptionsAdapter =', '                new AuthenticatorOptionsAdapter(mContext, authenticatorOptions, this);', '        mAuthenticationOptionsRecyclerView.setAdapter(mAuthenticatorOptionsAdapter);']}, {'a': ['        // Set up the ModalDialog.'], 'b': ['        // Set up the ModalDilsalog.']}, {'ab': ['        PropertyModel.Builder builder =', '                new PropertyModel.Builder(ModalDialogProperties.ALL_KEYS)', '                        .with(ModalDialogProperties.CONTROLLER, mModalDialogController)', '                        .with(ModalDialogProperties.CUSTOM_VIEW, view)', '                        .with(ModalDialogProperties.TITLE,', '                                mContext.getResources().getString(', '                                        R.string.autofill_payments_authenticator_selection_dialog_title))', '                        .with(ModalDialogProperties.TITLE_ICON,', '                                ResourcesCompat.getDrawable(mContext.getResources(),', '                                        R.drawable.google_pay_with_divider, mContext.getTheme()))', '                        .with(ModalDialogProperties.NEGATIVE_BUTTON_TEXT,', '                                mContext.getResources().getString(', '                                        R.string.autofill_payments_authenticator_selection_dialog_negative_button_label))', '                        .with(ModalDialogProperties.POSITIVE_BUTTON_TEXT,', '                                mContext.getResources().getString(', '                                        R.string.autofill_payments_authenticator_selection_dialog_positive_button_label));', '        mDialogModel = builder.build();', '        mModalDialogManager.showDialog(mDialogModel, ModalDialogManager.ModalDialogType.TAB);', '    }', '', '    public void dismiss(int cause) {', '        mModalDialogManager.dismissDialog(mDialogModel, cause);', '    }', '', '    private void showProgressBarOverlay() {', '        mProgressBarOverlayView.setVisibility(View.VISIBLE);', '        mProgressBarOverlayView.setAlpha(0f);', '        mProgressBarOverlayView.animate().alpha(1f).setDuration(ANIMATION_DURATION_MS);', '        mAuthenticatorSelectionDialogContentsView.animate().alpha(0f).setDuration(', '                ANIMATION_DURATION_MS);', '        mDialogModel.set(ModalDialogProperties.POSITIVE_BUTTON_DISABLED, true);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,441af9cb02c689929a9e8fe4cb26a036d34e1bc4,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialog.java,3c9dffbe_11cfa28e_before.java,3c9dffbe_11cfa28e_after.java,AuthenticatorSelectionDialog::show,True,True
45,3aba56b0_3679af05,102.0,Done,102.0,102.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', 'import android.view.LayoutInflater;', 'import android.view.View;', '', 'import androidx.core.content.res.ResourcesCompat;', 'import androidx.recyclerview.widget.RecyclerView;', '', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', 'import org.chromium.ui.modaldialog.ModalDialogProperties;', 'import org.chromium.ui.modelutil.PropertyModel;', '', 'import java.util.List;', '', '/**', ' * Dialog that presents {@link AuthenticatorOption}s to the user to choose from for fetching credit', ' * card information from the backend.', ' */', 'public class AuthenticatorSelectionDialog implements AuthenticatorOptionsAdapter.ItemClickListener {', '    private static final int ANIMATION_DURATION_MS = 250;', '    /** Interface for the caller to be notified of user actions. */', '    public interface Listener {', '        /** Notify that the user selected an authenticator option. */', '        void onOptionSelected(String authenticatorOptionIdentifier);', '        /** Notify that the dialog was dismissed. */', '        void onDialogDismissed();', '    }', '', '    private final ModalDialogProperties.Controller mModalDialogController =', '            new ModalDialogProperties.Controller() {', '                @Override', '                public void onClick(PropertyModel model, int buttonType) {', '                    switch (buttonType) {', '                        case ModalDialogProperties.ButtonType.POSITIVE:', '                            mListener.onOptionSelected(', '                                    mSelectedAuthenticatorOption.getIdentifier());', '                            showProgressBarOverlay();', '                            break;', '                        case ModalDialogProperties.ButtonType.NEGATIVE:', '                            mModalDialogManager.dismissDialog(', '                                    model, DialogDismissalCause.NEGATIVE_BUTTON_CLICKED);', '                            break;', '                    }', '                }', '', '                @Override', '                public void onDismiss(PropertyModel model, int dismissalCause) {', '                    mListener.onDialogDismissed();', '                }', '            };', '', '    private final Context mContext;', '    private final Listener mListener;', '    private final ModalDialogManager mModalDialogManager;', '    private View mProgressBarOverlayView;', '    private View mAuthenticatorSelectionDialogContentsView;', '    private RecyclerView mAuthenticationOptionsRecyclerView;', '    private AuthenticatorOptionsAdapter mAuthenticatorOptionsAdapter;', '', '    private PropertyModel mDialogModel;', '    private AuthenticatorOption mSelectedAuthenticatorOption;', '', '    public AuthenticatorSelectionDialog(', '            Context context, Listener listener, ModalDialogManager modalDialogManager) {', '        this.mContext = context;', '        this.mListener = listener;', '        this.mModalDialogManager = modalDialogManager;', '    }', '', '    @Override', '    public void onItemClicked(AuthenticatorOption option) {', '        mSelectedAuthenticatorOption = option;', '    }', '', '    /**', '     * Shows an Authenticator Selection dialog.', '     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        // By default, the first option will be selected.', '        mSelectedAuthenticatorOption = authenticatorOptions.get(0);', '        View view = LayoutInflater.from(mContext).inflate(', '                R.layout.authenticator_selection_dialog, null);', '        mAuthenticatorSelectionDialogContentsView =', '                view.findViewById(R.id.authenticator_selection_dialog_contents);', '        mProgressBarOverlayView = view.findViewById(R.id.progress_bar_overlay);', '        mProgressBarOverlayView.setVisibility(View.GONE);', '        // Set up the recycler view.', '        mAuthenticationOptionsRecyclerView =', '                (RecyclerView) view.findViewById(R.id.authenticator_options_view);', '        mAuthenticatorOptionsAdapter =', '                new AuthenticatorOptionsAdapter(mContext, authenticatorOptions, this);', '        mAuthenticationOptionsRecyclerView.setAdapter(mAuthenticatorOptionsAdapter);']}, {'a': ['        // Set up the ModalDialog.'], 'b': ['        // Set up the ModalDilsalog.']}, {'ab': ['        PropertyModel.Builder builder =', '                new PropertyModel.Builder(ModalDialogProperties.ALL_KEYS)', '                        .with(ModalDialogProperties.CONTROLLER, mModalDialogController)', '                        .with(ModalDialogProperties.CUSTOM_VIEW, view)', '                        .with(ModalDialogProperties.TITLE,', '                                mContext.getResources().getString(', '                                        R.string.autofill_payments_authenticator_selection_dialog_title))', '                        .with(ModalDialogProperties.TITLE_ICON,', '                                ResourcesCompat.getDrawable(mContext.getResources(),', '                                        R.drawable.google_pay_with_divider, mContext.getTheme()))', '                        .with(ModalDialogProperties.NEGATIVE_BUTTON_TEXT,', '                                mContext.getResources().getString(', '                                        R.string.autofill_payments_authenticator_selection_dialog_negative_button_label))', '                        .with(ModalDialogProperties.POSITIVE_BUTTON_TEXT,', '                                mContext.getResources().getString(', '                                        R.string.autofill_payments_authenticator_selection_dialog_positive_button_label));', '        mDialogModel = builder.build();', '        mModalDialogManager.showDialog(mDialogModel, ModalDialogManager.ModalDialogType.TAB);', '    }', '', '    public void dismiss(int cause) {', '        mModalDialogManager.dismissDialog(mDialogModel, cause);', '    }', '', '    private void showProgressBarOverlay() {', '        mProgressBarOverlayView.setVisibility(View.VISIBLE);', '        mProgressBarOverlayView.setAlpha(0f);', '        mProgressBarOverlayView.animate().alpha(1f).setDuration(ANIMATION_DURATION_MS);', '        mAuthenticatorSelectionDialogContentsView.animate().alpha(0f).setDuration(', '                ANIMATION_DURATION_MS);', '        mDialogModel.set(ModalDialogProperties.POSITIVE_BUTTON_DISABLED, true);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,441af9cb02c689929a9e8fe4cb26a036d34e1bc4,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialog.java,3aba56b0_3679af05_before.java,3aba56b0_3679af05_after.java,AuthenticatorSelectionDialog::show,True,True
46,1352903e_913850c6,74.0,C++ would do NOTREACHED() here which would crash a debug build...I wonder if this should do something similar?  Throwing an exception would crash even a non-debug build though...,74.0,74.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', '', 'import org.chromium.base.annotations.CalledByNative;', 'import org.chromium.base.annotations.JNINamespace;', 'import org.chromium.base.annotations.NativeMethods;', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.data.CardUnmaskChallengeOptionType;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.base.WindowAndroid;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', '', 'import java.util.ArrayList;', 'import java.util.List;', '', '/**', ' * JNI Bridge for {@link AuthenticatorSelectionDialog}', ' */', '@JNINamespace(""autofill"")', 'public class AuthenticatorSelectionDialogBridge implements AuthenticatorSelectionDialog.Listener {', '    private final long mNativeCardUnmaskAuthenticationSelectionDialogView;', '    private final Context mContext;', '    private AuthenticatorSelectionDialog mAuthenticatorSelectionDialog;', '', '    public AuthenticatorSelectionDialogBridge(long nativeAuthenticatorSelectionDialogView,', '            Context context, ModalDialogManager modalDialogManager) {', '        mNativeCardUnmaskAuthenticationSelectionDialogView = nativeAuthenticatorSelectionDialogView;', '        mContext = context;', '        mAuthenticatorSelectionDialog =', '                new AuthenticatorSelectionDialog(context, this, modalDialogManager);', '    }', '', '    @CalledByNative', '    public static AuthenticatorSelectionDialogBridge create(', '            long nativeAuthenticatorSelectionDialogView, WindowAndroid windowAndroid) {', '        return new AuthenticatorSelectionDialogBridge(nativeAuthenticatorSelectionDialogView,', '                windowAndroid.getActivity().get(), windowAndroid.getModalDialogManager());', '    }', '', '    /**', '     * Create a Java List of {@link AuthenticatorOption} and return it.']}, {'a': ['     *']}, {'ab': ['     * @return List of AuthenticatorOptions.', '     */', '    @CalledByNative', '    private static List<AuthenticatorOption> createAuthenticatorOptionList() {', '        return new ArrayList<>();', '    }', '', '    /**', '     * Constructs an {@link AuthenticatorOption} object and adds it to the list that was passed in.']}, {'a': ['     *']}, {'ab': ['     * @param list List to add to.', '     * @param title Title of {@link AuthenticatorOption}.', '     * @param identifier id of {@link AuthenticatorOption}.', '     * @param description Description of {@link AuthenticatorOption}.', '     * @param type type of {@link CardUnmaskChallengeOptionType}. Used to determine the icon that', '     *         should be shown.', '     */', '    @CalledByNative', '    private static void createAuthenticatorOptionAndAddToList(List<AuthenticatorOption> list,', '            String title, String identifier, String description, int type) {']}, {'a': ['        if (list == null) return;', '']}, {'ab': ['        int iconResId = 0;', ""        // We need to map the icon on this side, since the ID isn't available on the C++ side."", '        switch (type) {', '            case CardUnmaskChallengeOptionType.SmsOtp:', '                iconResId = R.drawable.outline_sms_24;', '                break;', '            case CardUnmaskChallengeOptionType.UnknownType:', '                // This should never happen', '                break;', '        }', '        AuthenticatorOption authenticatorOption = new AuthenticatorOption.Builder()', '                                                          .setTitle(title)', '                                                          .setIdentifier(identifier)', '                                                          .setDescription(description)', '                                                          .setIconResId(iconResId)', '                                                          .build();']}, {'a': ['        list.add(authenticatorOption);'], 'b': ['        if (list != null) list.add(authenticatorOption);']}, {'ab': ['    }', '', '    /**', '     * Shows an Authenticator Selection dialog.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    @CalledByNative', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        mAuthenticatorSelectionDialog.show(authenticatorOptions);', '    }', '', '    /**']}, {'a': ['     * Dismisses the Authenticator Selection Dialog.'], 'b': ['     * Dismissies the Authenticator Selection Dialog.']}, {'ab': ['     */', '    @CalledByNative', '    public void dismiss() {', '        mAuthenticatorSelectionDialog.dismiss(DialogDismissalCause.DISMISSED_BY_NATIVE);', '    }', '', '    /**', '     * Notify that the user selected an authenticator option.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptionIdentifier the identifier of the selected option.', '     */', '    @Override', '    public void onOptionSelected(String authenticatorOptionIdentifier) {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {']}, {'b': ['            // This call passes the account fields directly as String and GURL parameters as an', '            // optimization to avoid needing multiple JNI getters on the Account class on for each', '            // field.']}, {'ab': ['            AuthenticatorSelectionDialogBridgeJni.get().onOptionSelected(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView,', '                    authenticatorOptionIdentifier);', '        }', '    }', '', '    /** Notify that the dialog was dismissed. */', '    @Override', '    public void onDialogDismissed() {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onDismissed(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView);', '        }', '    }', '', '    @NativeMethods', '    interface Natives {', '        void onOptionSelected(long nativeAuthenticatorSelectionDialogViewAndroid,', '                String authenticatorOptionIdentifier);', '        void onDismissed(long nativeAuthenticatorSelectionDialogViewAndroid);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,441af9cb02c689929a9e8fe4cb26a036d34e1bc4,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialogBridge.java,1352903e_913850c6_before.java,1352903e_913850c6_after.java,AuthenticatorSelectionDialogBridge::createAuthenticatorOptionAndAddToList,True,True
47,b900a0c3_a7e3d737,74.0,"The only way I think we handle it gracefully is to leave it as is and maybe add a Log statement [1]

To avoid any crashes, we'd also need to update the AuthenticatorOptionsAdapter[2] to handle cases where the iconResId is 0, so that it does not fail trying fetch an icon for that id.

[1]https://sites.google.com/a/google.com/clank/engineering/best-practices/logging 
[2]https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorOptionsAdapter.java;l=58;drc=0f7b26dc2dcf3aa5098a852fc2c02329b25ad98d",74.0,74.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', '', 'import org.chromium.base.annotations.CalledByNative;', 'import org.chromium.base.annotations.JNINamespace;', 'import org.chromium.base.annotations.NativeMethods;', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.data.CardUnmaskChallengeOptionType;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.base.WindowAndroid;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', '', 'import java.util.ArrayList;', 'import java.util.List;', '', '/**', ' * JNI Bridge for {@link AuthenticatorSelectionDialog}', ' */', '@JNINamespace(""autofill"")', 'public class AuthenticatorSelectionDialogBridge implements AuthenticatorSelectionDialog.Listener {', '    private final long mNativeCardUnmaskAuthenticationSelectionDialogView;', '    private final Context mContext;', '    private AuthenticatorSelectionDialog mAuthenticatorSelectionDialog;', '', '    public AuthenticatorSelectionDialogBridge(long nativeAuthenticatorSelectionDialogView,', '            Context context, ModalDialogManager modalDialogManager) {', '        mNativeCardUnmaskAuthenticationSelectionDialogView = nativeAuthenticatorSelectionDialogView;', '        mContext = context;', '        mAuthenticatorSelectionDialog =', '                new AuthenticatorSelectionDialog(context, this, modalDialogManager);', '    }', '', '    @CalledByNative', '    public static AuthenticatorSelectionDialogBridge create(', '            long nativeAuthenticatorSelectionDialogView, WindowAndroid windowAndroid) {', '        return new AuthenticatorSelectionDialogBridge(nativeAuthenticatorSelectionDialogView,', '                windowAndroid.getActivity().get(), windowAndroid.getModalDialogManager());', '    }', '', '    /**', '     * Create a Java List of {@link AuthenticatorOption} and return it.']}, {'a': ['     *']}, {'ab': ['     * @return List of AuthenticatorOptions.', '     */', '    @CalledByNative', '    private static List<AuthenticatorOption> createAuthenticatorOptionList() {', '        return new ArrayList<>();', '    }', '', '    /**', '     * Constructs an {@link AuthenticatorOption} object and adds it to the list that was passed in.']}, {'a': ['     *']}, {'ab': ['     * @param list List to add to.', '     * @param title Title of {@link AuthenticatorOption}.', '     * @param identifier id of {@link AuthenticatorOption}.', '     * @param description Description of {@link AuthenticatorOption}.', '     * @param type type of {@link CardUnmaskChallengeOptionType}. Used to determine the icon that', '     *         should be shown.', '     */', '    @CalledByNative', '    private static void createAuthenticatorOptionAndAddToList(List<AuthenticatorOption> list,', '            String title, String identifier, String description, int type) {']}, {'a': ['        if (list == null) return;', '']}, {'ab': ['        int iconResId = 0;', ""        // We need to map the icon on this side, since the ID isn't available on the C++ side."", '        switch (type) {', '            case CardUnmaskChallengeOptionType.SmsOtp:', '                iconResId = R.drawable.outline_sms_24;', '                break;', '            case CardUnmaskChallengeOptionType.UnknownType:', '                // This should never happen', '                break;', '        }', '        AuthenticatorOption authenticatorOption = new AuthenticatorOption.Builder()', '                                                          .setTitle(title)', '                                                          .setIdentifier(identifier)', '                                                          .setDescription(description)', '                                                          .setIconResId(iconResId)', '                                                          .build();']}, {'a': ['        list.add(authenticatorOption);'], 'b': ['        if (list != null) list.add(authenticatorOption);']}, {'ab': ['    }', '', '    /**', '     * Shows an Authenticator Selection dialog.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    @CalledByNative', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        mAuthenticatorSelectionDialog.show(authenticatorOptions);', '    }', '', '    /**']}, {'a': ['     * Dismisses the Authenticator Selection Dialog.'], 'b': ['     * Dismissies the Authenticator Selection Dialog.']}, {'ab': ['     */', '    @CalledByNative', '    public void dismiss() {', '        mAuthenticatorSelectionDialog.dismiss(DialogDismissalCause.DISMISSED_BY_NATIVE);', '    }', '', '    /**', '     * Notify that the user selected an authenticator option.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptionIdentifier the identifier of the selected option.', '     */', '    @Override', '    public void onOptionSelected(String authenticatorOptionIdentifier) {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {']}, {'b': ['            // This call passes the account fields directly as String and GURL parameters as an', '            // optimization to avoid needing multiple JNI getters on the Account class on for each', '            // field.']}, {'ab': ['            AuthenticatorSelectionDialogBridgeJni.get().onOptionSelected(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView,', '                    authenticatorOptionIdentifier);', '        }', '    }', '', '    /** Notify that the dialog was dismissed. */', '    @Override', '    public void onDialogDismissed() {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onDismissed(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView);', '        }', '    }', '', '    @NativeMethods', '    interface Natives {', '        void onOptionSelected(long nativeAuthenticatorSelectionDialogViewAndroid,', '                String authenticatorOptionIdentifier);', '        void onDismissed(long nativeAuthenticatorSelectionDialogViewAndroid);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,441af9cb02c689929a9e8fe4cb26a036d34e1bc4,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialogBridge.java,b900a0c3_a7e3d737_before.java,b900a0c3_a7e3d737_after.java,AuthenticatorSelectionDialogBridge::createAuthenticatorOptionAndAddToList,True,True
48,5cae2ef7_508cb6bf,74.0,"Theoretically, this should never happen. However, if it's as you say (NOTREACHED() only takes effect on debug builds), throwing an exception here might not be desirable. I'd prefer a more graceful way of handling error conditions in release builds than just straight up crashing... Is there a way to catch an exception across the JNI build?",74.0,74.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', '', 'import org.chromium.base.annotations.CalledByNative;', 'import org.chromium.base.annotations.JNINamespace;', 'import org.chromium.base.annotations.NativeMethods;', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.data.CardUnmaskChallengeOptionType;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.base.WindowAndroid;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', '', 'import java.util.ArrayList;', 'import java.util.List;', '', '/**', ' * JNI Bridge for {@link AuthenticatorSelectionDialog}', ' */', '@JNINamespace(""autofill"")', 'public class AuthenticatorSelectionDialogBridge implements AuthenticatorSelectionDialog.Listener {', '    private final long mNativeCardUnmaskAuthenticationSelectionDialogView;', '    private final Context mContext;', '    private AuthenticatorSelectionDialog mAuthenticatorSelectionDialog;', '', '    public AuthenticatorSelectionDialogBridge(long nativeAuthenticatorSelectionDialogView,', '            Context context, ModalDialogManager modalDialogManager) {', '        mNativeCardUnmaskAuthenticationSelectionDialogView = nativeAuthenticatorSelectionDialogView;', '        mContext = context;', '        mAuthenticatorSelectionDialog =', '                new AuthenticatorSelectionDialog(context, this, modalDialogManager);', '    }', '', '    @CalledByNative', '    public static AuthenticatorSelectionDialogBridge create(', '            long nativeAuthenticatorSelectionDialogView, WindowAndroid windowAndroid) {', '        return new AuthenticatorSelectionDialogBridge(nativeAuthenticatorSelectionDialogView,', '                windowAndroid.getActivity().get(), windowAndroid.getModalDialogManager());', '    }', '', '    /**', '     * Create a Java List of {@link AuthenticatorOption} and return it.']}, {'a': ['     *']}, {'ab': ['     * @return List of AuthenticatorOptions.', '     */', '    @CalledByNative', '    private static List<AuthenticatorOption> createAuthenticatorOptionList() {', '        return new ArrayList<>();', '    }', '', '    /**', '     * Constructs an {@link AuthenticatorOption} object and adds it to the list that was passed in.']}, {'a': ['     *']}, {'ab': ['     * @param list List to add to.', '     * @param title Title of {@link AuthenticatorOption}.', '     * @param identifier id of {@link AuthenticatorOption}.', '     * @param description Description of {@link AuthenticatorOption}.', '     * @param type type of {@link CardUnmaskChallengeOptionType}. Used to determine the icon that', '     *         should be shown.', '     */', '    @CalledByNative', '    private static void createAuthenticatorOptionAndAddToList(List<AuthenticatorOption> list,', '            String title, String identifier, String description, int type) {']}, {'a': ['        if (list == null) return;', '']}, {'ab': ['        int iconResId = 0;', ""        // We need to map the icon on this side, since the ID isn't available on the C++ side."", '        switch (type) {', '            case CardUnmaskChallengeOptionType.SmsOtp:', '                iconResId = R.drawable.outline_sms_24;', '                break;', '            case CardUnmaskChallengeOptionType.UnknownType:', '                // This should never happen', '                break;', '        }', '        AuthenticatorOption authenticatorOption = new AuthenticatorOption.Builder()', '                                                          .setTitle(title)', '                                                          .setIdentifier(identifier)', '                                                          .setDescription(description)', '                                                          .setIconResId(iconResId)', '                                                          .build();']}, {'a': ['        list.add(authenticatorOption);'], 'b': ['        if (list != null) list.add(authenticatorOption);']}, {'ab': ['    }', '', '    /**', '     * Shows an Authenticator Selection dialog.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    @CalledByNative', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        mAuthenticatorSelectionDialog.show(authenticatorOptions);', '    }', '', '    /**']}, {'a': ['     * Dismisses the Authenticator Selection Dialog.'], 'b': ['     * Dismissies the Authenticator Selection Dialog.']}, {'ab': ['     */', '    @CalledByNative', '    public void dismiss() {', '        mAuthenticatorSelectionDialog.dismiss(DialogDismissalCause.DISMISSED_BY_NATIVE);', '    }', '', '    /**', '     * Notify that the user selected an authenticator option.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptionIdentifier the identifier of the selected option.', '     */', '    @Override', '    public void onOptionSelected(String authenticatorOptionIdentifier) {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {']}, {'b': ['            // This call passes the account fields directly as String and GURL parameters as an', '            // optimization to avoid needing multiple JNI getters on the Account class on for each', '            // field.']}, {'ab': ['            AuthenticatorSelectionDialogBridgeJni.get().onOptionSelected(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView,', '                    authenticatorOptionIdentifier);', '        }', '    }', '', '    /** Notify that the dialog was dismissed. */', '    @Override', '    public void onDialogDismissed() {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onDismissed(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView);', '        }', '    }', '', '    @NativeMethods', '    interface Natives {', '        void onOptionSelected(long nativeAuthenticatorSelectionDialogViewAndroid,', '                String authenticatorOptionIdentifier);', '        void onDismissed(long nativeAuthenticatorSelectionDialogViewAndroid);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,441af9cb02c689929a9e8fe4cb26a036d34e1bc4,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialogBridge.java,5cae2ef7_508cb6bf_before.java,5cae2ef7_508cb6bf_after.java,AuthenticatorSelectionDialogBridge::createAuthenticatorOptionAndAddToList,True,True
49,06b8ae77_bfb8df07,74.0,"Good question, agreed that throwing an exception isn't desirable either.  As for your question, not sure, unfortunately.  Maybe Sid knows?  Maybe we just have to leave it be.",74.0,74.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', '', 'import org.chromium.base.annotations.CalledByNative;', 'import org.chromium.base.annotations.JNINamespace;', 'import org.chromium.base.annotations.NativeMethods;', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.data.CardUnmaskChallengeOptionType;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.base.WindowAndroid;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', '', 'import java.util.ArrayList;', 'import java.util.List;', '', '/**', ' * JNI Bridge for {@link AuthenticatorSelectionDialog}', ' */', '@JNINamespace(""autofill"")', 'public class AuthenticatorSelectionDialogBridge implements AuthenticatorSelectionDialog.Listener {', '    private final long mNativeCardUnmaskAuthenticationSelectionDialogView;', '    private final Context mContext;', '    private AuthenticatorSelectionDialog mAuthenticatorSelectionDialog;', '', '    public AuthenticatorSelectionDialogBridge(long nativeAuthenticatorSelectionDialogView,', '            Context context, ModalDialogManager modalDialogManager) {', '        mNativeCardUnmaskAuthenticationSelectionDialogView = nativeAuthenticatorSelectionDialogView;', '        mContext = context;', '        mAuthenticatorSelectionDialog =', '                new AuthenticatorSelectionDialog(context, this, modalDialogManager);', '    }', '', '    @CalledByNative', '    public static AuthenticatorSelectionDialogBridge create(', '            long nativeAuthenticatorSelectionDialogView, WindowAndroid windowAndroid) {', '        return new AuthenticatorSelectionDialogBridge(nativeAuthenticatorSelectionDialogView,', '                windowAndroid.getActivity().get(), windowAndroid.getModalDialogManager());', '    }', '', '    /**', '     * Create a Java List of {@link AuthenticatorOption} and return it.']}, {'a': ['     *']}, {'ab': ['     * @return List of AuthenticatorOptions.', '     */', '    @CalledByNative', '    private static List<AuthenticatorOption> createAuthenticatorOptionList() {', '        return new ArrayList<>();', '    }', '', '    /**', '     * Constructs an {@link AuthenticatorOption} object and adds it to the list that was passed in.']}, {'a': ['     *']}, {'ab': ['     * @param list List to add to.', '     * @param title Title of {@link AuthenticatorOption}.', '     * @param identifier id of {@link AuthenticatorOption}.', '     * @param description Description of {@link AuthenticatorOption}.', '     * @param type type of {@link CardUnmaskChallengeOptionType}. Used to determine the icon that', '     *         should be shown.', '     */', '    @CalledByNative', '    private static void createAuthenticatorOptionAndAddToList(List<AuthenticatorOption> list,', '            String title, String identifier, String description, int type) {']}, {'a': ['        if (list == null) return;', '']}, {'ab': ['        int iconResId = 0;', ""        // We need to map the icon on this side, since the ID isn't available on the C++ side."", '        switch (type) {', '            case CardUnmaskChallengeOptionType.SmsOtp:', '                iconResId = R.drawable.outline_sms_24;', '                break;', '            case CardUnmaskChallengeOptionType.UnknownType:', '                // This should never happen', '                break;', '        }', '        AuthenticatorOption authenticatorOption = new AuthenticatorOption.Builder()', '                                                          .setTitle(title)', '                                                          .setIdentifier(identifier)', '                                                          .setDescription(description)', '                                                          .setIconResId(iconResId)', '                                                          .build();']}, {'a': ['        list.add(authenticatorOption);'], 'b': ['        if (list != null) list.add(authenticatorOption);']}, {'ab': ['    }', '', '    /**', '     * Shows an Authenticator Selection dialog.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    @CalledByNative', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        mAuthenticatorSelectionDialog.show(authenticatorOptions);', '    }', '', '    /**']}, {'a': ['     * Dismisses the Authenticator Selection Dialog.'], 'b': ['     * Dismissies the Authenticator Selection Dialog.']}, {'ab': ['     */', '    @CalledByNative', '    public void dismiss() {', '        mAuthenticatorSelectionDialog.dismiss(DialogDismissalCause.DISMISSED_BY_NATIVE);', '    }', '', '    /**', '     * Notify that the user selected an authenticator option.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptionIdentifier the identifier of the selected option.', '     */', '    @Override', '    public void onOptionSelected(String authenticatorOptionIdentifier) {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {']}, {'b': ['            // This call passes the account fields directly as String and GURL parameters as an', '            // optimization to avoid needing multiple JNI getters on the Account class on for each', '            // field.']}, {'ab': ['            AuthenticatorSelectionDialogBridgeJni.get().onOptionSelected(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView,', '                    authenticatorOptionIdentifier);', '        }', '    }', '', '    /** Notify that the dialog was dismissed. */', '    @Override', '    public void onDialogDismissed() {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onDismissed(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView);', '        }', '    }', '', '    @NativeMethods', '    interface Natives {', '        void onOptionSelected(long nativeAuthenticatorSelectionDialogViewAndroid,', '                String authenticatorOptionIdentifier);', '        void onDismissed(long nativeAuthenticatorSelectionDialogViewAndroid);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,441af9cb02c689929a9e8fe4cb26a036d34e1bc4,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialogBridge.java,06b8ae77_bfb8df07_before.java,06b8ae77_bfb8df07_after.java,AuthenticatorSelectionDialogBridge::createAuthenticatorOptionAndAddToList,True,True
50,9bab2220_9319950a,74.0,Done,74.0,74.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', '', 'import org.chromium.base.annotations.CalledByNative;', 'import org.chromium.base.annotations.JNINamespace;', 'import org.chromium.base.annotations.NativeMethods;', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.data.CardUnmaskChallengeOptionType;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.base.WindowAndroid;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', '', 'import java.util.ArrayList;', 'import java.util.List;', '', '/**', ' * JNI Bridge for {@link AuthenticatorSelectionDialog}', ' */', '@JNINamespace(""autofill"")', 'public class AuthenticatorSelectionDialogBridge implements AuthenticatorSelectionDialog.Listener {', '    private final long mNativeCardUnmaskAuthenticationSelectionDialogView;', '    private final Context mContext;', '    private AuthenticatorSelectionDialog mAuthenticatorSelectionDialog;', '', '    public AuthenticatorSelectionDialogBridge(long nativeAuthenticatorSelectionDialogView,', '            Context context, ModalDialogManager modalDialogManager) {', '        mNativeCardUnmaskAuthenticationSelectionDialogView = nativeAuthenticatorSelectionDialogView;', '        mContext = context;', '        mAuthenticatorSelectionDialog =', '                new AuthenticatorSelectionDialog(context, this, modalDialogManager);', '    }', '', '    @CalledByNative', '    public static AuthenticatorSelectionDialogBridge create(', '            long nativeAuthenticatorSelectionDialogView, WindowAndroid windowAndroid) {', '        return new AuthenticatorSelectionDialogBridge(nativeAuthenticatorSelectionDialogView,', '                windowAndroid.getActivity().get(), windowAndroid.getModalDialogManager());', '    }', '', '    /**', '     * Create a Java List of {@link AuthenticatorOption} and return it.']}, {'a': ['     *']}, {'ab': ['     * @return List of AuthenticatorOptions.', '     */', '    @CalledByNative', '    private static List<AuthenticatorOption> createAuthenticatorOptionList() {', '        return new ArrayList<>();', '    }', '', '    /**', '     * Constructs an {@link AuthenticatorOption} object and adds it to the list that was passed in.']}, {'a': ['     *']}, {'ab': ['     * @param list List to add to.', '     * @param title Title of {@link AuthenticatorOption}.', '     * @param identifier id of {@link AuthenticatorOption}.', '     * @param description Description of {@link AuthenticatorOption}.', '     * @param type type of {@link CardUnmaskChallengeOptionType}. Used to determine the icon that', '     *         should be shown.', '     */', '    @CalledByNative', '    private static void createAuthenticatorOptionAndAddToList(List<AuthenticatorOption> list,', '            String title, String identifier, String description, int type) {']}, {'a': ['        if (list == null) return;', '']}, {'ab': ['        int iconResId = 0;', ""        // We need to map the icon on this side, since the ID isn't available on the C++ side."", '        switch (type) {', '            case CardUnmaskChallengeOptionType.SmsOtp:', '                iconResId = R.drawable.outline_sms_24;', '                break;', '            case CardUnmaskChallengeOptionType.UnknownType:', '                // This should never happen', '                break;', '        }', '        AuthenticatorOption authenticatorOption = new AuthenticatorOption.Builder()', '                                                          .setTitle(title)', '                                                          .setIdentifier(identifier)', '                                                          .setDescription(description)', '                                                          .setIconResId(iconResId)', '                                                          .build();']}, {'a': ['        list.add(authenticatorOption);'], 'b': ['        if (list != null) list.add(authenticatorOption);']}, {'ab': ['    }', '', '    /**', '     * Shows an Authenticator Selection dialog.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    @CalledByNative', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        mAuthenticatorSelectionDialog.show(authenticatorOptions);', '    }', '', '    /**']}, {'a': ['     * Dismisses the Authenticator Selection Dialog.'], 'b': ['     * Dismissies the Authenticator Selection Dialog.']}, {'ab': ['     */', '    @CalledByNative', '    public void dismiss() {', '        mAuthenticatorSelectionDialog.dismiss(DialogDismissalCause.DISMISSED_BY_NATIVE);', '    }', '', '    /**', '     * Notify that the user selected an authenticator option.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptionIdentifier the identifier of the selected option.', '     */', '    @Override', '    public void onOptionSelected(String authenticatorOptionIdentifier) {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {']}, {'b': ['            // This call passes the account fields directly as String and GURL parameters as an', '            // optimization to avoid needing multiple JNI getters on the Account class on for each', '            // field.']}, {'ab': ['            AuthenticatorSelectionDialogBridgeJni.get().onOptionSelected(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView,', '                    authenticatorOptionIdentifier);', '        }', '    }', '', '    /** Notify that the dialog was dismissed. */', '    @Override', '    public void onDialogDismissed() {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onDismissed(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView);', '        }', '    }', '', '    @NativeMethods', '    interface Natives {', '        void onOptionSelected(long nativeAuthenticatorSelectionDialogViewAndroid,', '                String authenticatorOptionIdentifier);', '        void onDismissed(long nativeAuthenticatorSelectionDialogViewAndroid);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,441af9cb02c689929a9e8fe4cb26a036d34e1bc4,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialogBridge.java,9bab2220_9319950a_before.java,9bab2220_9319950a_after.java,AuthenticatorSelectionDialogBridge::createAuthenticatorOptionAndAddToList,True,True
51,fd75ad03_194bf6ad,74.0,Done,74.0,74.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', '', 'import org.chromium.base.annotations.CalledByNative;', 'import org.chromium.base.annotations.JNINamespace;', 'import org.chromium.base.annotations.NativeMethods;', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.data.CardUnmaskChallengeOptionType;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.base.WindowAndroid;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', '', 'import java.util.ArrayList;', 'import java.util.List;', '', '/**', ' * JNI Bridge for {@link AuthenticatorSelectionDialog}', ' */', '@JNINamespace(""autofill"")', 'public class AuthenticatorSelectionDialogBridge implements AuthenticatorSelectionDialog.Listener {', '    private final long mNativeCardUnmaskAuthenticationSelectionDialogView;', '    private final Context mContext;', '    private AuthenticatorSelectionDialog mAuthenticatorSelectionDialog;', '', '    public AuthenticatorSelectionDialogBridge(long nativeAuthenticatorSelectionDialogView,', '            Context context, ModalDialogManager modalDialogManager) {', '        mNativeCardUnmaskAuthenticationSelectionDialogView = nativeAuthenticatorSelectionDialogView;', '        mContext = context;', '        mAuthenticatorSelectionDialog =', '                new AuthenticatorSelectionDialog(context, this, modalDialogManager);', '    }', '', '    @CalledByNative', '    public static AuthenticatorSelectionDialogBridge create(', '            long nativeAuthenticatorSelectionDialogView, WindowAndroid windowAndroid) {', '        return new AuthenticatorSelectionDialogBridge(nativeAuthenticatorSelectionDialogView,', '                windowAndroid.getActivity().get(), windowAndroid.getModalDialogManager());', '    }', '', '    /**', '     * Create a Java List of {@link AuthenticatorOption} and return it.']}, {'a': ['     *']}, {'ab': ['     * @return List of AuthenticatorOptions.', '     */', '    @CalledByNative', '    private static List<AuthenticatorOption> createAuthenticatorOptionList() {', '        return new ArrayList<>();', '    }', '', '    /**', '     * Constructs an {@link AuthenticatorOption} object and adds it to the list that was passed in.']}, {'a': ['     *']}, {'ab': ['     * @param list List to add to.', '     * @param title Title of {@link AuthenticatorOption}.', '     * @param identifier id of {@link AuthenticatorOption}.', '     * @param description Description of {@link AuthenticatorOption}.', '     * @param type type of {@link CardUnmaskChallengeOptionType}. Used to determine the icon that', '     *         should be shown.', '     */', '    @CalledByNative', '    private static void createAuthenticatorOptionAndAddToList(List<AuthenticatorOption> list,', '            String title, String identifier, String description, int type) {']}, {'a': ['        if (list == null) return;', '']}, {'ab': ['        int iconResId = 0;', ""        // We need to map the icon on this side, since the ID isn't available on the C++ side."", '        switch (type) {', '            case CardUnmaskChallengeOptionType.SmsOtp:', '                iconResId = R.drawable.outline_sms_24;', '                break;', '            case CardUnmaskChallengeOptionType.UnknownType:', '                // This should never happen', '                break;', '        }', '        AuthenticatorOption authenticatorOption = new AuthenticatorOption.Builder()', '                                                          .setTitle(title)', '                                                          .setIdentifier(identifier)', '                                                          .setDescription(description)', '                                                          .setIconResId(iconResId)', '                                                          .build();']}, {'a': ['        list.add(authenticatorOption);'], 'b': ['        if (list != null) list.add(authenticatorOption);']}, {'ab': ['    }', '', '    /**', '     * Shows an Authenticator Selection dialog.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    @CalledByNative', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        mAuthenticatorSelectionDialog.show(authenticatorOptions);', '    }', '', '    /**']}, {'a': ['     * Dismisses the Authenticator Selection Dialog.'], 'b': ['     * Dismissies the Authenticator Selection Dialog.']}, {'ab': ['     */', '    @CalledByNative', '    public void dismiss() {', '        mAuthenticatorSelectionDialog.dismiss(DialogDismissalCause.DISMISSED_BY_NATIVE);', '    }', '', '    /**', '     * Notify that the user selected an authenticator option.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptionIdentifier the identifier of the selected option.', '     */', '    @Override', '    public void onOptionSelected(String authenticatorOptionIdentifier) {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {']}, {'b': ['            // This call passes the account fields directly as String and GURL parameters as an', '            // optimization to avoid needing multiple JNI getters on the Account class on for each', '            // field.']}, {'ab': ['            AuthenticatorSelectionDialogBridgeJni.get().onOptionSelected(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView,', '                    authenticatorOptionIdentifier);', '        }', '    }', '', '    /** Notify that the dialog was dismissed. */', '    @Override', '    public void onDialogDismissed() {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onDismissed(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView);', '        }', '    }', '', '    @NativeMethods', '    interface Natives {', '        void onOptionSelected(long nativeAuthenticatorSelectionDialogViewAndroid,', '                String authenticatorOptionIdentifier);', '        void onDismissed(long nativeAuthenticatorSelectionDialogViewAndroid);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,441af9cb02c689929a9e8fe4cb26a036d34e1bc4,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialogBridge.java,fd75ad03_194bf6ad_before.java,fd75ad03_194bf6ad_after.java,AuthenticatorSelectionDialogBridge::createAuthenticatorOptionAndAddToList,True,True
52,c095cb5c_e76f3e7a,83.0,"If nothing happens in the end if |list| is null, maybe starting off this function with `if (list == null) return;` would be better, to avoid unnecessary object construction?",83.0,83.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', '', 'import org.chromium.base.annotations.CalledByNative;', 'import org.chromium.base.annotations.JNINamespace;', 'import org.chromium.base.annotations.NativeMethods;', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.data.CardUnmaskChallengeOptionType;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.base.WindowAndroid;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', '', 'import java.util.ArrayList;', 'import java.util.List;', '', '/**', ' * JNI Bridge for {@link AuthenticatorSelectionDialog}', ' */', '@JNINamespace(""autofill"")', 'public class AuthenticatorSelectionDialogBridge implements AuthenticatorSelectionDialog.Listener {', '    private final long mNativeCardUnmaskAuthenticationSelectionDialogView;', '    private final Context mContext;', '    private AuthenticatorSelectionDialog mAuthenticatorSelectionDialog;', '', '    public AuthenticatorSelectionDialogBridge(long nativeAuthenticatorSelectionDialogView,', '            Context context, ModalDialogManager modalDialogManager) {', '        mNativeCardUnmaskAuthenticationSelectionDialogView = nativeAuthenticatorSelectionDialogView;', '        mContext = context;', '        mAuthenticatorSelectionDialog =', '                new AuthenticatorSelectionDialog(context, this, modalDialogManager);', '    }', '', '    @CalledByNative', '    public static AuthenticatorSelectionDialogBridge create(', '            long nativeAuthenticatorSelectionDialogView, WindowAndroid windowAndroid) {', '        return new AuthenticatorSelectionDialogBridge(nativeAuthenticatorSelectionDialogView,', '                windowAndroid.getActivity().get(), windowAndroid.getModalDialogManager());', '    }', '', '    /**', '     * Create a Java List of {@link AuthenticatorOption} and return it.']}, {'a': ['     *']}, {'ab': ['     * @return List of AuthenticatorOptions.', '     */', '    @CalledByNative', '    private static List<AuthenticatorOption> createAuthenticatorOptionList() {', '        return new ArrayList<>();', '    }', '', '    /**', '     * Constructs an {@link AuthenticatorOption} object and adds it to the list that was passed in.']}, {'a': ['     *']}, {'ab': ['     * @param list List to add to.', '     * @param title Title of {@link AuthenticatorOption}.', '     * @param identifier id of {@link AuthenticatorOption}.', '     * @param description Description of {@link AuthenticatorOption}.', '     * @param type type of {@link CardUnmaskChallengeOptionType}. Used to determine the icon that', '     *         should be shown.', '     */', '    @CalledByNative', '    private static void createAuthenticatorOptionAndAddToList(List<AuthenticatorOption> list,', '            String title, String identifier, String description, int type) {']}, {'a': ['        if (list == null) return;', '']}, {'ab': ['        int iconResId = 0;', ""        // We need to map the icon on this side, since the ID isn't available on the C++ side."", '        switch (type) {', '            case CardUnmaskChallengeOptionType.SmsOtp:', '                iconResId = R.drawable.outline_sms_24;', '                break;', '            case CardUnmaskChallengeOptionType.UnknownType:', '                // This should never happen', '                break;', '        }', '        AuthenticatorOption authenticatorOption = new AuthenticatorOption.Builder()', '                                                          .setTitle(title)', '                                                          .setIdentifier(identifier)', '                                                          .setDescription(description)', '                                                          .setIconResId(iconResId)', '                                                          .build();']}, {'a': ['        list.add(authenticatorOption);'], 'b': ['        if (list != null) list.add(authenticatorOption);']}, {'ab': ['    }', '', '    /**', '     * Shows an Authenticator Selection dialog.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    @CalledByNative', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        mAuthenticatorSelectionDialog.show(authenticatorOptions);', '    }', '', '    /**']}, {'a': ['     * Dismisses the Authenticator Selection Dialog.'], 'b': ['     * Dismissies the Authenticator Selection Dialog.']}, {'ab': ['     */', '    @CalledByNative', '    public void dismiss() {', '        mAuthenticatorSelectionDialog.dismiss(DialogDismissalCause.DISMISSED_BY_NATIVE);', '    }', '', '    /**', '     * Notify that the user selected an authenticator option.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptionIdentifier the identifier of the selected option.', '     */', '    @Override', '    public void onOptionSelected(String authenticatorOptionIdentifier) {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {']}, {'b': ['            // This call passes the account fields directly as String and GURL parameters as an', '            // optimization to avoid needing multiple JNI getters on the Account class on for each', '            // field.']}, {'ab': ['            AuthenticatorSelectionDialogBridgeJni.get().onOptionSelected(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView,', '                    authenticatorOptionIdentifier);', '        }', '    }', '', '    /** Notify that the dialog was dismissed. */', '    @Override', '    public void onDialogDismissed() {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onDismissed(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView);', '        }', '    }', '', '    @NativeMethods', '    interface Natives {', '        void onOptionSelected(long nativeAuthenticatorSelectionDialogViewAndroid,', '                String authenticatorOptionIdentifier);', '        void onDismissed(long nativeAuthenticatorSelectionDialogViewAndroid);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,441af9cb02c689929a9e8fe4cb26a036d34e1bc4,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialogBridge.java,c095cb5c_e76f3e7a_before.java,c095cb5c_e76f3e7a_after.java,AuthenticatorSelectionDialogBridge::createAuthenticatorOptionAndAddToList,True,True
53,e1d80ebe_8ea8359d,83.0,Done,83.0,83.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', '', 'import org.chromium.base.annotations.CalledByNative;', 'import org.chromium.base.annotations.JNINamespace;', 'import org.chromium.base.annotations.NativeMethods;', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.data.CardUnmaskChallengeOptionType;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.base.WindowAndroid;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', '', 'import java.util.ArrayList;', 'import java.util.List;', '', '/**', ' * JNI Bridge for {@link AuthenticatorSelectionDialog}', ' */', '@JNINamespace(""autofill"")', 'public class AuthenticatorSelectionDialogBridge implements AuthenticatorSelectionDialog.Listener {', '    private final long mNativeCardUnmaskAuthenticationSelectionDialogView;', '    private final Context mContext;', '    private AuthenticatorSelectionDialog mAuthenticatorSelectionDialog;', '', '    public AuthenticatorSelectionDialogBridge(long nativeAuthenticatorSelectionDialogView,', '            Context context, ModalDialogManager modalDialogManager) {', '        mNativeCardUnmaskAuthenticationSelectionDialogView = nativeAuthenticatorSelectionDialogView;', '        mContext = context;', '        mAuthenticatorSelectionDialog =', '                new AuthenticatorSelectionDialog(context, this, modalDialogManager);', '    }', '', '    @CalledByNative', '    public static AuthenticatorSelectionDialogBridge create(', '            long nativeAuthenticatorSelectionDialogView, WindowAndroid windowAndroid) {', '        return new AuthenticatorSelectionDialogBridge(nativeAuthenticatorSelectionDialogView,', '                windowAndroid.getActivity().get(), windowAndroid.getModalDialogManager());', '    }', '', '    /**', '     * Create a Java List of {@link AuthenticatorOption} and return it.']}, {'a': ['     *']}, {'ab': ['     * @return List of AuthenticatorOptions.', '     */', '    @CalledByNative', '    private static List<AuthenticatorOption> createAuthenticatorOptionList() {', '        return new ArrayList<>();', '    }', '', '    /**', '     * Constructs an {@link AuthenticatorOption} object and adds it to the list that was passed in.']}, {'a': ['     *']}, {'ab': ['     * @param list List to add to.', '     * @param title Title of {@link AuthenticatorOption}.', '     * @param identifier id of {@link AuthenticatorOption}.', '     * @param description Description of {@link AuthenticatorOption}.', '     * @param type type of {@link CardUnmaskChallengeOptionType}. Used to determine the icon that', '     *         should be shown.', '     */', '    @CalledByNative', '    private static void createAuthenticatorOptionAndAddToList(List<AuthenticatorOption> list,', '            String title, String identifier, String description, int type) {']}, {'a': ['        if (list == null) return;', '']}, {'ab': ['        int iconResId = 0;', ""        // We need to map the icon on this side, since the ID isn't available on the C++ side."", '        switch (type) {', '            case CardUnmaskChallengeOptionType.SmsOtp:', '                iconResId = R.drawable.outline_sms_24;', '                break;', '            case CardUnmaskChallengeOptionType.UnknownType:', '                // This should never happen', '                break;', '        }', '        AuthenticatorOption authenticatorOption = new AuthenticatorOption.Builder()', '                                                          .setTitle(title)', '                                                          .setIdentifier(identifier)', '                                                          .setDescription(description)', '                                                          .setIconResId(iconResId)', '                                                          .build();']}, {'a': ['        list.add(authenticatorOption);'], 'b': ['        if (list != null) list.add(authenticatorOption);']}, {'ab': ['    }', '', '    /**', '     * Shows an Authenticator Selection dialog.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    @CalledByNative', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        mAuthenticatorSelectionDialog.show(authenticatorOptions);', '    }', '', '    /**']}, {'a': ['     * Dismisses the Authenticator Selection Dialog.'], 'b': ['     * Dismissies the Authenticator Selection Dialog.']}, {'ab': ['     */', '    @CalledByNative', '    public void dismiss() {', '        mAuthenticatorSelectionDialog.dismiss(DialogDismissalCause.DISMISSED_BY_NATIVE);', '    }', '', '    /**', '     * Notify that the user selected an authenticator option.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptionIdentifier the identifier of the selected option.', '     */', '    @Override', '    public void onOptionSelected(String authenticatorOptionIdentifier) {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {']}, {'b': ['            // This call passes the account fields directly as String and GURL parameters as an', '            // optimization to avoid needing multiple JNI getters on the Account class on for each', '            // field.']}, {'ab': ['            AuthenticatorSelectionDialogBridgeJni.get().onOptionSelected(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView,', '                    authenticatorOptionIdentifier);', '        }', '    }', '', '    /** Notify that the dialog was dismissed. */', '    @Override', '    public void onDialogDismissed() {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onDismissed(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView);', '        }', '    }', '', '    @NativeMethods', '    interface Natives {', '        void onOptionSelected(long nativeAuthenticatorSelectionDialogViewAndroid,', '                String authenticatorOptionIdentifier);', '        void onDismissed(long nativeAuthenticatorSelectionDialogViewAndroid);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,441af9cb02c689929a9e8fe4cb26a036d34e1bc4,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialogBridge.java,e1d80ebe_8ea8359d_before.java,e1d80ebe_8ea8359d_after.java,AuthenticatorSelectionDialogBridge::createAuthenticatorOptionAndAddToList,True,True
56,0a880965_e08adf83,112.0,nit: This comment seems unrelated.,110.0,112.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', '', 'import org.chromium.base.annotations.CalledByNative;', 'import org.chromium.base.annotations.JNINamespace;', 'import org.chromium.base.annotations.NativeMethods;', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.data.CardUnmaskChallengeOptionType;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.base.WindowAndroid;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', '', 'import java.util.ArrayList;', 'import java.util.List;', '', '/**', ' * JNI Bridge for {@link AuthenticatorSelectionDialog}', ' */', '@JNINamespace(""autofill"")', 'public class AuthenticatorSelectionDialogBridge implements AuthenticatorSelectionDialog.Listener {', '    private final long mNativeCardUnmaskAuthenticationSelectionDialogView;', '    private final Context mContext;', '    private AuthenticatorSelectionDialog mAuthenticatorSelectionDialog;', '', '    public AuthenticatorSelectionDialogBridge(long nativeAuthenticatorSelectionDialogView,', '            Context context, ModalDialogManager modalDialogManager) {', '        mNativeCardUnmaskAuthenticationSelectionDialogView = nativeAuthenticatorSelectionDialogView;', '        mContext = context;', '        mAuthenticatorSelectionDialog =', '                new AuthenticatorSelectionDialog(context, this, modalDialogManager);', '    }', '', '    @CalledByNative', '    public static AuthenticatorSelectionDialogBridge create(', '            long nativeAuthenticatorSelectionDialogView, WindowAndroid windowAndroid) {', '        return new AuthenticatorSelectionDialogBridge(nativeAuthenticatorSelectionDialogView,', '                windowAndroid.getActivity().get(), windowAndroid.getModalDialogManager());', '    }', '', '    /**', '     * Create a Java List of {@link AuthenticatorOption} and return it.']}, {'a': ['     *']}, {'ab': ['     * @return List of AuthenticatorOptions.', '     */', '    @CalledByNative', '    private static List<AuthenticatorOption> createAuthenticatorOptionList() {', '        return new ArrayList<>();', '    }', '', '    /**', '     * Constructs an {@link AuthenticatorOption} object and adds it to the list that was passed in.']}, {'a': ['     *']}, {'ab': ['     * @param list List to add to.', '     * @param title Title of {@link AuthenticatorOption}.', '     * @param identifier id of {@link AuthenticatorOption}.', '     * @param description Description of {@link AuthenticatorOption}.', '     * @param type type of {@link CardUnmaskChallengeOptionType}. Used to determine the icon that', '     *         should be shown.', '     */', '    @CalledByNative', '    private static void createAuthenticatorOptionAndAddToList(List<AuthenticatorOption> list,', '            String title, String identifier, String description, int type) {']}, {'a': ['        if (list == null) return;', '']}, {'ab': ['        int iconResId = 0;', ""        // We need to map the icon on this side, since the ID isn't available on the C++ side."", '        switch (type) {', '            case CardUnmaskChallengeOptionType.SmsOtp:', '                iconResId = R.drawable.outline_sms_24;', '                break;', '            case CardUnmaskChallengeOptionType.UnknownType:', '                // This should never happen', '                break;', '        }', '        AuthenticatorOption authenticatorOption = new AuthenticatorOption.Builder()', '                                                          .setTitle(title)', '                                                          .setIdentifier(identifier)', '                                                          .setDescription(description)', '                                                          .setIconResId(iconResId)', '                                                          .build();']}, {'a': ['        list.add(authenticatorOption);'], 'b': ['        if (list != null) list.add(authenticatorOption);']}, {'ab': ['    }', '', '    /**', '     * Shows an Authenticator Selection dialog.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    @CalledByNative', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        mAuthenticatorSelectionDialog.show(authenticatorOptions);', '    }', '', '    /**']}, {'a': ['     * Dismisses the Authenticator Selection Dialog.'], 'b': ['     * Dismissies the Authenticator Selection Dialog.']}, {'ab': ['     */', '    @CalledByNative', '    public void dismiss() {', '        mAuthenticatorSelectionDialog.dismiss(DialogDismissalCause.DISMISSED_BY_NATIVE);', '    }', '', '    /**', '     * Notify that the user selected an authenticator option.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptionIdentifier the identifier of the selected option.', '     */', '    @Override', '    public void onOptionSelected(String authenticatorOptionIdentifier) {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {']}, {'b': ['            // This call passes the account fields directly as String and GURL parameters as an', '            // optimization to avoid needing multiple JNI getters on the Account class on for each', '            // field.']}, {'ab': ['            AuthenticatorSelectionDialogBridgeJni.get().onOptionSelected(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView,', '                    authenticatorOptionIdentifier);', '        }', '    }', '', '    /** Notify that the dialog was dismissed. */', '    @Override', '    public void onDialogDismissed() {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onDismissed(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView);', '        }', '    }', '', '    @NativeMethods', '    interface Natives {', '        void onOptionSelected(long nativeAuthenticatorSelectionDialogViewAndroid,', '                String authenticatorOptionIdentifier);', '        void onDismissed(long nativeAuthenticatorSelectionDialogViewAndroid);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,441af9cb02c689929a9e8fe4cb26a036d34e1bc4,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialogBridge.java,0a880965_e08adf83_before.java,0a880965_e08adf83_after.java,AuthenticatorSelectionDialogBridge::onOptionSelected,True,True
57,b01514fd_4e89dd9c,112.0,Done,110.0,112.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', '', 'import org.chromium.base.annotations.CalledByNative;', 'import org.chromium.base.annotations.JNINamespace;', 'import org.chromium.base.annotations.NativeMethods;', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.data.CardUnmaskChallengeOptionType;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.base.WindowAndroid;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', '', 'import java.util.ArrayList;', 'import java.util.List;', '', '/**', ' * JNI Bridge for {@link AuthenticatorSelectionDialog}', ' */', '@JNINamespace(""autofill"")', 'public class AuthenticatorSelectionDialogBridge implements AuthenticatorSelectionDialog.Listener {', '    private final long mNativeCardUnmaskAuthenticationSelectionDialogView;', '    private final Context mContext;', '    private AuthenticatorSelectionDialog mAuthenticatorSelectionDialog;', '', '    public AuthenticatorSelectionDialogBridge(long nativeAuthenticatorSelectionDialogView,', '            Context context, ModalDialogManager modalDialogManager) {', '        mNativeCardUnmaskAuthenticationSelectionDialogView = nativeAuthenticatorSelectionDialogView;', '        mContext = context;', '        mAuthenticatorSelectionDialog =', '                new AuthenticatorSelectionDialog(context, this, modalDialogManager);', '    }', '', '    @CalledByNative', '    public static AuthenticatorSelectionDialogBridge create(', '            long nativeAuthenticatorSelectionDialogView, WindowAndroid windowAndroid) {', '        return new AuthenticatorSelectionDialogBridge(nativeAuthenticatorSelectionDialogView,', '                windowAndroid.getActivity().get(), windowAndroid.getModalDialogManager());', '    }', '', '    /**', '     * Create a Java List of {@link AuthenticatorOption} and return it.']}, {'a': ['     *']}, {'ab': ['     * @return List of AuthenticatorOptions.', '     */', '    @CalledByNative', '    private static List<AuthenticatorOption> createAuthenticatorOptionList() {', '        return new ArrayList<>();', '    }', '', '    /**', '     * Constructs an {@link AuthenticatorOption} object and adds it to the list that was passed in.']}, {'a': ['     *']}, {'ab': ['     * @param list List to add to.', '     * @param title Title of {@link AuthenticatorOption}.', '     * @param identifier id of {@link AuthenticatorOption}.', '     * @param description Description of {@link AuthenticatorOption}.', '     * @param type type of {@link CardUnmaskChallengeOptionType}. Used to determine the icon that', '     *         should be shown.', '     */', '    @CalledByNative', '    private static void createAuthenticatorOptionAndAddToList(List<AuthenticatorOption> list,', '            String title, String identifier, String description, int type) {']}, {'a': ['        if (list == null) return;', '']}, {'ab': ['        int iconResId = 0;', ""        // We need to map the icon on this side, since the ID isn't available on the C++ side."", '        switch (type) {', '            case CardUnmaskChallengeOptionType.SmsOtp:', '                iconResId = R.drawable.outline_sms_24;', '                break;', '            case CardUnmaskChallengeOptionType.UnknownType:', '                // This should never happen', '                break;', '        }', '        AuthenticatorOption authenticatorOption = new AuthenticatorOption.Builder()', '                                                          .setTitle(title)', '                                                          .setIdentifier(identifier)', '                                                          .setDescription(description)', '                                                          .setIconResId(iconResId)', '                                                          .build();']}, {'a': ['        list.add(authenticatorOption);'], 'b': ['        if (list != null) list.add(authenticatorOption);']}, {'ab': ['    }', '', '    /**', '     * Shows an Authenticator Selection dialog.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    @CalledByNative', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        mAuthenticatorSelectionDialog.show(authenticatorOptions);', '    }', '', '    /**']}, {'a': ['     * Dismisses the Authenticator Selection Dialog.'], 'b': ['     * Dismissies the Authenticator Selection Dialog.']}, {'ab': ['     */', '    @CalledByNative', '    public void dismiss() {', '        mAuthenticatorSelectionDialog.dismiss(DialogDismissalCause.DISMISSED_BY_NATIVE);', '    }', '', '    /**', '     * Notify that the user selected an authenticator option.']}, {'a': ['     *']}, {'ab': ['     * @param authenticatorOptionIdentifier the identifier of the selected option.', '     */', '    @Override', '    public void onOptionSelected(String authenticatorOptionIdentifier) {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {']}, {'b': ['            // This call passes the account fields directly as String and GURL parameters as an', '            // optimization to avoid needing multiple JNI getters on the Account class on for each', '            // field.']}, {'ab': ['            AuthenticatorSelectionDialogBridgeJni.get().onOptionSelected(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView,', '                    authenticatorOptionIdentifier);', '        }', '    }', '', '    /** Notify that the dialog was dismissed. */', '    @Override', '    public void onDialogDismissed() {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onDismissed(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView);', '        }', '    }', '', '    @NativeMethods', '    interface Natives {', '        void onOptionSelected(long nativeAuthenticatorSelectionDialogViewAndroid,', '                String authenticatorOptionIdentifier);', '        void onDismissed(long nativeAuthenticatorSelectionDialogViewAndroid);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,441af9cb02c689929a9e8fe4cb26a036d34e1bc4,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialogBridge.java,b01514fd_4e89dd9c_before.java,b01514fd_4e89dd9c_after.java,AuthenticatorSelectionDialogBridge::onOptionSelected,True,True
58,98c0be16_09d2e17a,69.0,"I think Java requires curly braces even in C++, sorry for my misleading comment earlier. :)

  if (list == null) {
    return;
  }",69.0,69.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', '', 'import org.chromium.base.annotations.CalledByNative;', 'import org.chromium.base.annotations.JNINamespace;', 'import org.chromium.base.annotations.NativeMethods;', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.data.CardUnmaskChallengeOptionType;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.base.WindowAndroid;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', '', 'import java.util.ArrayList;', 'import java.util.List;', '', '/**', ' * JNI Bridge for {@link AuthenticatorSelectionDialog}', ' */', '@JNINamespace(""autofill"")', 'public class AuthenticatorSelectionDialogBridge implements AuthenticatorSelectionDialog.Listener {', '    private final long mNativeCardUnmaskAuthenticationSelectionDialogView;', '    private final Context mContext;', '    private AuthenticatorSelectionDialog mAuthenticatorSelectionDialog;', '', '    public AuthenticatorSelectionDialogBridge(long nativeAuthenticatorSelectionDialogView,', '            Context context, ModalDialogManager modalDialogManager) {', '        mNativeCardUnmaskAuthenticationSelectionDialogView = nativeAuthenticatorSelectionDialogView;', '        mContext = context;', '        mAuthenticatorSelectionDialog =', '                new AuthenticatorSelectionDialog(context, this, modalDialogManager);', '    }', '', '    @CalledByNative', '    public static AuthenticatorSelectionDialogBridge create(', '            long nativeAuthenticatorSelectionDialogView, WindowAndroid windowAndroid) {', '        return new AuthenticatorSelectionDialogBridge(nativeAuthenticatorSelectionDialogView,', '                windowAndroid.getActivity().get(), windowAndroid.getModalDialogManager());', '    }', '', '    /**', '     * Create a Java List of {@link AuthenticatorOption} and return it.', '     *', '     * @return List of AuthenticatorOptions.', '     */', '    @CalledByNative', '    private static List<AuthenticatorOption> createAuthenticatorOptionList() {', '        return new ArrayList<>();', '    }', '', '    /**', '     * Constructs an {@link AuthenticatorOption} object and adds it to the list that was passed in.', '     *', '     * @param list List to add to.', '     * @param title Title of {@link AuthenticatorOption}.', '     * @param identifier id of {@link AuthenticatorOption}.', '     * @param description Description of {@link AuthenticatorOption}.', '     * @param type type of {@link CardUnmaskChallengeOptionType}. Used to determine the icon that', '     *         should be shown.', '     */', '    @CalledByNative', '    private static void createAuthenticatorOptionAndAddToList(List<AuthenticatorOption> list,', '            String title, String identifier, String description, int type) {']}, {'a': ['        if (list == null) {', '            return;', '        }'], 'b': ['        if (list == null) return;']}, {'ab': ['', '        int iconResId = 0;', ""        // We need to map the icon on this side, since the ID isn't available on the C++ side."", '        switch (type) {', '            case CardUnmaskChallengeOptionType.SmsOtp:', '                iconResId = R.drawable.outline_sms_24;', '                break;', '            case CardUnmaskChallengeOptionType.UnknownType:', '                // This should never happen', '                break;', '        }', '        AuthenticatorOption authenticatorOption = new AuthenticatorOption.Builder()', '                                                          .setTitle(title)', '                                                          .setIdentifier(identifier)', '                                                          .setDescription(description)', '                                                          .setIconResId(iconResId)', '                                                          .build();', '        list.add(authenticatorOption);', '    }', '', '    /**', '     * Shows an Authenticator Selection dialog.', '     *', '     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    @CalledByNative', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        mAuthenticatorSelectionDialog.show(authenticatorOptions);', '    }', '', '    /**', '     * Dismisses the Authenticator Selection Dialog.', '     */', '    @CalledByNative', '    public void dismiss() {', '        mAuthenticatorSelectionDialog.dismiss(DialogDismissalCause.DISMISSED_BY_NATIVE);', '    }', '', '    /**', '     * Notify that the user selected an authenticator option.', '     *', '     * @param authenticatorOptionIdentifier the identifier of the selected option.', '     */', '    @Override', '    public void onOptionSelected(String authenticatorOptionIdentifier) {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onOptionSelected(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView,', '                    authenticatorOptionIdentifier);', '        }', '    }', '', '    /** Notify that the dialog was dismissed. */', '    @Override', '    public void onDialogDismissed() {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onDismissed(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView);', '        }', '    }', '', '    @NativeMethods', '    interface Natives {', '        void onOptionSelected(long nativeAuthenticatorSelectionDialogViewAndroid,', '                String authenticatorOptionIdentifier);', '        void onDismissed(long nativeAuthenticatorSelectionDialogViewAndroid);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,11fb33a4b231001e7909a98c0029e54ed954d416,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialogBridge.java,98c0be16_09d2e17a_before.java,98c0be16_09d2e17a_after.java,AuthenticatorSelectionDialogBridge::createAuthenticatorOptionAndAddToList,True,True
59,f78ff58c_5da46b46,69.0,Done,69.0,69.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.autofill;', '', 'import android.content.Context;', '', 'import org.chromium.base.annotations.CalledByNative;', 'import org.chromium.base.annotations.JNINamespace;', 'import org.chromium.base.annotations.NativeMethods;', 'import org.chromium.chrome.browser.ui.autofill.data.AuthenticatorOption;', 'import org.chromium.chrome.browser.ui.autofill.data.CardUnmaskChallengeOptionType;', 'import org.chromium.chrome.browser.ui.autofill.internal.R;', 'import org.chromium.ui.base.WindowAndroid;', 'import org.chromium.ui.modaldialog.DialogDismissalCause;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', '', 'import java.util.ArrayList;', 'import java.util.List;', '', '/**', ' * JNI Bridge for {@link AuthenticatorSelectionDialog}', ' */', '@JNINamespace(""autofill"")', 'public class AuthenticatorSelectionDialogBridge implements AuthenticatorSelectionDialog.Listener {', '    private final long mNativeCardUnmaskAuthenticationSelectionDialogView;', '    private final Context mContext;', '    private AuthenticatorSelectionDialog mAuthenticatorSelectionDialog;', '', '    public AuthenticatorSelectionDialogBridge(long nativeAuthenticatorSelectionDialogView,', '            Context context, ModalDialogManager modalDialogManager) {', '        mNativeCardUnmaskAuthenticationSelectionDialogView = nativeAuthenticatorSelectionDialogView;', '        mContext = context;', '        mAuthenticatorSelectionDialog =', '                new AuthenticatorSelectionDialog(context, this, modalDialogManager);', '    }', '', '    @CalledByNative', '    public static AuthenticatorSelectionDialogBridge create(', '            long nativeAuthenticatorSelectionDialogView, WindowAndroid windowAndroid) {', '        return new AuthenticatorSelectionDialogBridge(nativeAuthenticatorSelectionDialogView,', '                windowAndroid.getActivity().get(), windowAndroid.getModalDialogManager());', '    }', '', '    /**', '     * Create a Java List of {@link AuthenticatorOption} and return it.', '     *', '     * @return List of AuthenticatorOptions.', '     */', '    @CalledByNative', '    private static List<AuthenticatorOption> createAuthenticatorOptionList() {', '        return new ArrayList<>();', '    }', '', '    /**', '     * Constructs an {@link AuthenticatorOption} object and adds it to the list that was passed in.', '     *', '     * @param list List to add to.', '     * @param title Title of {@link AuthenticatorOption}.', '     * @param identifier id of {@link AuthenticatorOption}.', '     * @param description Description of {@link AuthenticatorOption}.', '     * @param type type of {@link CardUnmaskChallengeOptionType}. Used to determine the icon that', '     *         should be shown.', '     */', '    @CalledByNative', '    private static void createAuthenticatorOptionAndAddToList(List<AuthenticatorOption> list,', '            String title, String identifier, String description, int type) {']}, {'a': ['        if (list == null) {', '            return;', '        }'], 'b': ['        if (list == null) return;']}, {'ab': ['', '        int iconResId = 0;', ""        // We need to map the icon on this side, since the ID isn't available on the C++ side."", '        switch (type) {', '            case CardUnmaskChallengeOptionType.SmsOtp:', '                iconResId = R.drawable.outline_sms_24;', '                break;', '            case CardUnmaskChallengeOptionType.UnknownType:', '                // This should never happen', '                break;', '        }', '        AuthenticatorOption authenticatorOption = new AuthenticatorOption.Builder()', '                                                          .setTitle(title)', '                                                          .setIdentifier(identifier)', '                                                          .setDescription(description)', '                                                          .setIconResId(iconResId)', '                                                          .build();', '        list.add(authenticatorOption);', '    }', '', '    /**', '     * Shows an Authenticator Selection dialog.', '     *', '     * @param authenticatorOptions The authenticator options available to the user.', '     */', '    @CalledByNative', '    public void show(List<AuthenticatorOption> authenticatorOptions) {', '        mAuthenticatorSelectionDialog.show(authenticatorOptions);', '    }', '', '    /**', '     * Dismisses the Authenticator Selection Dialog.', '     */', '    @CalledByNative', '    public void dismiss() {', '        mAuthenticatorSelectionDialog.dismiss(DialogDismissalCause.DISMISSED_BY_NATIVE);', '    }', '', '    /**', '     * Notify that the user selected an authenticator option.', '     *', '     * @param authenticatorOptionIdentifier the identifier of the selected option.', '     */', '    @Override', '    public void onOptionSelected(String authenticatorOptionIdentifier) {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onOptionSelected(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView,', '                    authenticatorOptionIdentifier);', '        }', '    }', '', '    /** Notify that the dialog was dismissed. */', '    @Override', '    public void onDialogDismissed() {', '        if (mNativeCardUnmaskAuthenticationSelectionDialogView != 0) {', '            AuthenticatorSelectionDialogBridgeJni.get().onDismissed(', '                    mNativeCardUnmaskAuthenticationSelectionDialogView);', '        }', '    }', '', '    @NativeMethods', '    interface Natives {', '        void onOptionSelected(long nativeAuthenticatorSelectionDialogViewAndroid,', '                String authenticatorOptionIdentifier);', '        void onDismissed(long nativeAuthenticatorSelectionDialogViewAndroid);', '    }', '}', '']}]",chromium%2Fsrc~main~I3d59ceed76d30e2d6ba1517727bba4c56b07c261,11fb33a4b231001e7909a98c0029e54ed954d416,chrome/browser/ui/android/autofill/internal/java/src/org/chromium/chrome/browser/ui/autofill/AuthenticatorSelectionDialogBridge.java,f78ff58c_5da46b46_before.java,f78ff58c_5da46b46_after.java,AuthenticatorSelectionDialogBridge::createAuthenticatorOptionAndAddToList,True,True
67,f40d885f_697ef2a8,153.0,"nit: addAccounts(accounts, /*areAccountsClickable=*/!hasSingleAccount);
go/java-practices/methods#call-site-literals",153.0,153.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.android.webid;', '', 'import android.os.Handler;', '', 'import androidx.annotation.Px;', 'import androidx.annotation.VisibleForTesting;', '', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.AccountProperties;', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.AutoSignInCancelButtonProperties;', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.ContinueButtonProperties;', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.DataSharingConsentProperties;', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.HeaderProperties;', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.HeaderProperties.HeaderType;', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.ItemType;', 'import org.chromium.chrome.browser.ui.android.webid.data.Account;', 'import org.chromium.chrome.browser.ui.android.webid.data.ClientIdMetadata;', 'import org.chromium.components.browser_ui.bottomsheet.BottomSheetContent;', 'import org.chromium.components.browser_ui.bottomsheet.BottomSheetController;', 'import org.chromium.components.browser_ui.bottomsheet.BottomSheetController.StateChangeReason;', 'import org.chromium.components.browser_ui.bottomsheet.BottomSheetObserver;', 'import org.chromium.components.browser_ui.bottomsheet.EmptyBottomSheetObserver;', 'import org.chromium.components.favicon.LargeIconBridge;', 'import org.chromium.components.favicon.LargeIconBridge.LargeIconCallback;', 'import org.chromium.components.image_fetcher.ImageFetcher;', 'import org.chromium.components.url_formatter.SchemeDisplay;', 'import org.chromium.components.url_formatter.UrlFormatter;', 'import org.chromium.ui.modelutil.MVCListAdapter.ListItem;', 'import org.chromium.ui.modelutil.MVCListAdapter.ModelList;', 'import org.chromium.ui.modelutil.PropertyModel;', 'import org.chromium.url.GURL;', '', 'import java.util.List;', '', '/**', ' * Contains the logic for the AccountSelection component. It sets the state of the model and reacts', ' * to events like clicks.', ' */', 'class AccountSelectionMediator {', '    private boolean mVisible;', '    private final AccountSelectionComponent.Delegate mDelegate;', '    private final ModelList mSheetItems;', '    private final ImageFetcher mImageFetcher;', '    private final LargeIconBridge mLargeIconBridge;', '    private final @Px int mDesiredAvatarSize;', '    private final @Px int mDesiredIconSize;', '', '    private final BottomSheetController mBottomSheetController;', '    private final BottomSheetContent mBottomSheetContent;', '    private final BottomSheetObserver mBottomSheetObserver;', '    private final Handler mAutoSignInTaskHandler = new Handler();', '    // TODO(yigu): Increase the time after adding a continue button for users to', '    // proceed. Eventually this should be specified by IDPs.', '    private static final int AUTO_SIGN_IN_CANCELLATION_TIMER_MS = 5000;', '', '    AccountSelectionMediator(AccountSelectionComponent.Delegate delegate, ModelList sheetItems,', '            BottomSheetController bottomSheetController, BottomSheetContent bottomSheetContent,', '            ImageFetcher imageFetcher, @Px int desiredAvatarSize, LargeIconBridge largeIconBridge,', '            @Px int desiredIconSize) {', '        assert delegate != null;', '        mVisible = false;', '        mDelegate = delegate;', '        mSheetItems = sheetItems;', '        mImageFetcher = imageFetcher;', '        mDesiredAvatarSize = desiredAvatarSize;', '        mLargeIconBridge = largeIconBridge;', '        mDesiredIconSize = desiredIconSize;', '        mBottomSheetController = bottomSheetController;', '        mBottomSheetContent = bottomSheetContent;', '', '        mBottomSheetObserver = new EmptyBottomSheetObserver() {', '            // TODO(majidvp): We should override #onSheetStateChanged() and react to HIDDEN state', '            // since closed is a legacy fixture that can get out of sync with the state is some', '            // situations. https://crbug.com/1215174', '            @Override', '            public void onSheetClosed(@BottomSheetController.StateChangeReason int reason) {', '                super.onSheetClosed(reason);', '                mBottomSheetController.removeObserver(mBottomSheetObserver);', '', '                if (!mVisible) return;', '                onDismissed(reason);', '            }', '        };', '    }', '', '    void addHeader(String url, List<Account> accounts) {', '        boolean useSignInHeader = false;', '        for (Account account : accounts) {', '            if (!account.isSignIn()) continue;', '            useSignInHeader = true;', '            break;', '        }', '        HeaderType headerType;', '        if (useSignInHeader) {', '            headerType = HeaderType.SIGN_IN;', '        } else {', '            headerType =', '                    accounts.size() == 1 ? HeaderType.SINGLE_ACCOUNT : HeaderType.MULTIPLE_ACCOUNT;', '        }', '        String site_url =', '                UrlFormatter.formatUrlForSecurityDisplay(url, SchemeDisplay.OMIT_HTTP_AND_HTTPS);', '', '        // We remove the HTTPS from URL since it is the only protocol that is', '        // allowed with WebID.', '        mSheetItems.add(new ListItem(ItemType.HEADER,', '                new PropertyModel.Builder(HeaderProperties.ALL_KEYS)', '                        .with(HeaderProperties.TYPE, headerType)', '                        .with(HeaderProperties.FORMATTED_URL, site_url)', '                        .build()));', '    }', '', '    void addAccounts(List<Account> accounts, boolean areAccountsClickable) {', '        for (Account account : accounts) {', '            final PropertyModel model = createAccountItem(account, areAccountsClickable);', '            mSheetItems.add(new ListItem(ItemType.ACCOUNT, model));', '            requestIconOrFallbackImage(model);', '            requestAvatarImage(model);', '        }', '    }', '', '    void addButton(Account account, ClientIdMetadata metadata, boolean isAutoSignIn) {', '        if (isAutoSignIn) {', '            assert account.isSignIn();', '            final PropertyModel cancelBtnModel = createAutoSignInCancelBtnItem();', '            mSheetItems.add(new ListItem(ItemType.AUTO_SIGN_IN_CANCEL_BUTTON, cancelBtnModel));', '', '            mAutoSignInTaskHandler.postDelayed(', '                    () -> onAccountSelected(account), AUTO_SIGN_IN_CANCELLATION_TIMER_MS);', '            return;', '        }', '', '        // Shows the continue button for both sign-up and non auto-sign-in.', '        final PropertyModel continueBtnModel = createContinueBtnItem(account);', '        mSheetItems.add(new ListItem(ItemType.CONTINUE_BUTTON, continueBtnModel));', '', '        // Only show the user data sharing consent text for sign up.', '        if (!account.isSignIn()) {', '            String provider_url = UrlFormatter.formatUrlForSecurityDisplay(', '                    account.getOriginUrl(), SchemeDisplay.OMIT_HTTP_AND_HTTPS);', '            mSheetItems.add(new ListItem(ItemType.DATA_SHARING_CONSENT,', '                    createDataSharingConsentItem(provider_url, metadata)));', '        }', '    }', '', '    void showAccounts(', '            String url, List<Account> accounts, ClientIdMetadata metadata, boolean isAutoSignIn) {', '        mSheetItems.clear();', '        addHeader(url, accounts);', '        boolean hasSingleAccount = (accounts.size() == 1);']}, {'a': ['        addAccounts(accounts, /*areAccountsClickable=*/!hasSingleAccount);'], 'b': ['        addAccounts(accounts, !hasSingleAccount /* areAccountsClickable */);']}, {'ab': ['        if (hasSingleAccount) {', '            addButton(accounts.get(0), metadata, isAutoSignIn);', '        }', '', '        showContent();', '    }', '', '    /**', '     * Requests to show the bottom sheet. If it is not possible to immediately show the content', '     * (e.g., higher priority content is being shown) it removes the request from the bottom sheet', '     * controller queue and notifies the delegate of the dismissal.', '     */', '    @VisibleForTesting', '    void showContent() {', '        if (mBottomSheetController.requestShowContent(mBottomSheetContent, true)) {', '            mVisible = true;', '            mBottomSheetController.addObserver(mBottomSheetObserver);', '        } else {', '            onDismissed(BottomSheetController.StateChangeReason.NONE);', '        }', '    }', '', '    /**', '     * Requests to hide the bottom sheet.', '     */', '    void hideContent() {', '        mVisible = false;', '        mBottomSheetController.hideContent(mBottomSheetContent, true);', '    }', '', '    private void requestAvatarImage(PropertyModel accountModel) {', '        Account account = accountModel.get(AccountProperties.ACCOUNT);', '        final String name = account.getName();', '        final String avatarURL = account.getPictureUrl().getSpec();', '', '        if (!avatarURL.isEmpty()) {', '            ImageFetcher.Params params = ImageFetcher.Params.create(avatarURL,', '                    ImageFetcher.WEB_ID_ACCOUNT_SELECTION_UMA_CLIENT_NAME, mDesiredAvatarSize,', '                    mDesiredAvatarSize);', '', '            mImageFetcher.fetchImage(params, bitmap -> {', '                accountModel.set(AccountProperties.AVATAR,', '                        new AccountProperties.Avatar(name, bitmap, mDesiredAvatarSize));', '            });', '        } else {', '            accountModel.set(AccountProperties.AVATAR,', '                    new AccountProperties.Avatar(name, null, mDesiredAvatarSize));', '        }', '    }', '', '    private void requestIconOrFallbackImage(PropertyModel accountModel) {', '        Account account = accountModel.get(AccountProperties.ACCOUNT);', '        final GURL iconOrigin = account.getOriginUrl();', '        final LargeIconCallback setIcon = (icon, fallbackColor, hasDefaultColor, type) -> {', '            accountModel.set(AccountProperties.FAVICON_OR_FALLBACK,', '                    new AccountProperties.FaviconOrFallback(', '                            iconOrigin, icon, fallbackColor, mDesiredIconSize));', '        };', '        mLargeIconBridge.getLargeIconForUrl(iconOrigin, mDesiredIconSize, setIcon);', '    }', '', '    boolean isVisible() {', '        return mVisible;', '    }', '', '    void onAccountSelected(Account account) {', '        if (!mVisible) return;', '        hideContent();', '        mDelegate.onAccountSelected(account);', '    }', '', '    void onDismissed(@StateChangeReason int reason) {', '        hideContent();', '        mDelegate.onDismissed();', '    }', '', '    void onAutoSignInCancelled() {', '        hideContent();', '        mDelegate.onAutoSignInCancelled();', '    }', '', '    private PropertyModel createAccountItem(Account account, boolean isAccountClickable) {', '        PropertyModel.Builder modelBuilder = new PropertyModel.Builder(AccountProperties.ALL_KEYS)', '                                                     .with(AccountProperties.ACCOUNT, account);', '        if (isAccountClickable) {', '            modelBuilder.with(AccountProperties.ON_CLICK_LISTENER, this::onAccountSelected);', '        }', '        return modelBuilder.build();', '    }', '', '    private PropertyModel createContinueBtnItem(Account account) {', '        return new PropertyModel.Builder(ContinueButtonProperties.ALL_KEYS)', '                .with(ContinueButtonProperties.ACCOUNT, account)', '                .with(ContinueButtonProperties.ON_CLICK_LISTENER, this::onAccountSelected)', '                .build();', '    }', '', '    private PropertyModel createAutoSignInCancelBtnItem() {', '        return new PropertyModel.Builder(AutoSignInCancelButtonProperties.ALL_KEYS)', '                .with(AutoSignInCancelButtonProperties.ON_CLICK_LISTENER,', '                        this::onAutoSignInCancelled)', '                .build();', '    }', '', '    private PropertyModel createDataSharingConsentItem(String provider, ClientIdMetadata metadata) {', '        return new PropertyModel.Builder(DataSharingConsentProperties.ALL_KEYS)', '                .with(DataSharingConsentProperties.PROVIDER_URL, provider)', '                .with(DataSharingConsentProperties.TERMS_OF_SERVICE_URL,', '                        metadata.getTermsOfServiceUrl().getValidSpecOrEmpty())', '                .with(DataSharingConsentProperties.PRIVACY_POLICY_URL,', '                        metadata.getPrivacyPolicyUrl().getValidSpecOrEmpty())', '                .build();', '    }', '}', '']}]",chromium%2Fsrc~main~Ia8d49728a83d1db67ef658d13e9dee307480e922,f2396dc030d632db7e00809b1d7b4e89673cd62a,chrome/browser/ui/android/webid/internal/java/src/org/chromium/chrome/browser/ui/android/webid/AccountSelectionMediator.java,f40d885f_697ef2a8_before.java,f40d885f_697ef2a8_after.java,AccountSelectionMediator::showAccounts,True,True
68,c2c02c8f_99d2f0a6,153.0,Done,153.0,153.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.ui.android.webid;', '', 'import android.os.Handler;', '', 'import androidx.annotation.Px;', 'import androidx.annotation.VisibleForTesting;', '', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.AccountProperties;', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.AutoSignInCancelButtonProperties;', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.ContinueButtonProperties;', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.DataSharingConsentProperties;', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.HeaderProperties;', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.HeaderProperties.HeaderType;', 'import org.chromium.chrome.browser.ui.android.webid.AccountSelectionProperties.ItemType;', 'import org.chromium.chrome.browser.ui.android.webid.data.Account;', 'import org.chromium.chrome.browser.ui.android.webid.data.ClientIdMetadata;', 'import org.chromium.components.browser_ui.bottomsheet.BottomSheetContent;', 'import org.chromium.components.browser_ui.bottomsheet.BottomSheetController;', 'import org.chromium.components.browser_ui.bottomsheet.BottomSheetController.StateChangeReason;', 'import org.chromium.components.browser_ui.bottomsheet.BottomSheetObserver;', 'import org.chromium.components.browser_ui.bottomsheet.EmptyBottomSheetObserver;', 'import org.chromium.components.favicon.LargeIconBridge;', 'import org.chromium.components.favicon.LargeIconBridge.LargeIconCallback;', 'import org.chromium.components.image_fetcher.ImageFetcher;', 'import org.chromium.components.url_formatter.SchemeDisplay;', 'import org.chromium.components.url_formatter.UrlFormatter;', 'import org.chromium.ui.modelutil.MVCListAdapter.ListItem;', 'import org.chromium.ui.modelutil.MVCListAdapter.ModelList;', 'import org.chromium.ui.modelutil.PropertyModel;', 'import org.chromium.url.GURL;', '', 'import java.util.List;', '', '/**', ' * Contains the logic for the AccountSelection component. It sets the state of the model and reacts', ' * to events like clicks.', ' */', 'class AccountSelectionMediator {', '    private boolean mVisible;', '    private final AccountSelectionComponent.Delegate mDelegate;', '    private final ModelList mSheetItems;', '    private final ImageFetcher mImageFetcher;', '    private final LargeIconBridge mLargeIconBridge;', '    private final @Px int mDesiredAvatarSize;', '    private final @Px int mDesiredIconSize;', '', '    private final BottomSheetController mBottomSheetController;', '    private final BottomSheetContent mBottomSheetContent;', '    private final BottomSheetObserver mBottomSheetObserver;', '    private final Handler mAutoSignInTaskHandler = new Handler();', '    // TODO(yigu): Increase the time after adding a continue button for users to', '    // proceed. Eventually this should be specified by IDPs.', '    private static final int AUTO_SIGN_IN_CANCELLATION_TIMER_MS = 5000;', '', '    AccountSelectionMediator(AccountSelectionComponent.Delegate delegate, ModelList sheetItems,', '            BottomSheetController bottomSheetController, BottomSheetContent bottomSheetContent,', '            ImageFetcher imageFetcher, @Px int desiredAvatarSize, LargeIconBridge largeIconBridge,', '            @Px int desiredIconSize) {', '        assert delegate != null;', '        mVisible = false;', '        mDelegate = delegate;', '        mSheetItems = sheetItems;', '        mImageFetcher = imageFetcher;', '        mDesiredAvatarSize = desiredAvatarSize;', '        mLargeIconBridge = largeIconBridge;', '        mDesiredIconSize = desiredIconSize;', '        mBottomSheetController = bottomSheetController;', '        mBottomSheetContent = bottomSheetContent;', '', '        mBottomSheetObserver = new EmptyBottomSheetObserver() {', '            // TODO(majidvp): We should override #onSheetStateChanged() and react to HIDDEN state', '            // since closed is a legacy fixture that can get out of sync with the state is some', '            // situations. https://crbug.com/1215174', '            @Override', '            public void onSheetClosed(@BottomSheetController.StateChangeReason int reason) {', '                super.onSheetClosed(reason);', '                mBottomSheetController.removeObserver(mBottomSheetObserver);', '', '                if (!mVisible) return;', '                onDismissed(reason);', '            }', '        };', '    }', '', '    void addHeader(String url, List<Account> accounts) {', '        boolean useSignInHeader = false;', '        for (Account account : accounts) {', '            if (!account.isSignIn()) continue;', '            useSignInHeader = true;', '            break;', '        }', '        HeaderType headerType;', '        if (useSignInHeader) {', '            headerType = HeaderType.SIGN_IN;', '        } else {', '            headerType =', '                    accounts.size() == 1 ? HeaderType.SINGLE_ACCOUNT : HeaderType.MULTIPLE_ACCOUNT;', '        }', '        String site_url =', '                UrlFormatter.formatUrlForSecurityDisplay(url, SchemeDisplay.OMIT_HTTP_AND_HTTPS);', '', '        // We remove the HTTPS from URL since it is the only protocol that is', '        // allowed with WebID.', '        mSheetItems.add(new ListItem(ItemType.HEADER,', '                new PropertyModel.Builder(HeaderProperties.ALL_KEYS)', '                        .with(HeaderProperties.TYPE, headerType)', '                        .with(HeaderProperties.FORMATTED_URL, site_url)', '                        .build()));', '    }', '', '    void addAccounts(List<Account> accounts, boolean areAccountsClickable) {', '        for (Account account : accounts) {', '            final PropertyModel model = createAccountItem(account, areAccountsClickable);', '            mSheetItems.add(new ListItem(ItemType.ACCOUNT, model));', '            requestIconOrFallbackImage(model);', '            requestAvatarImage(model);', '        }', '    }', '', '    void addButton(Account account, ClientIdMetadata metadata, boolean isAutoSignIn) {', '        if (isAutoSignIn) {', '            assert account.isSignIn();', '            final PropertyModel cancelBtnModel = createAutoSignInCancelBtnItem();', '            mSheetItems.add(new ListItem(ItemType.AUTO_SIGN_IN_CANCEL_BUTTON, cancelBtnModel));', '', '            mAutoSignInTaskHandler.postDelayed(', '                    () -> onAccountSelected(account), AUTO_SIGN_IN_CANCELLATION_TIMER_MS);', '            return;', '        }', '', '        // Shows the continue button for both sign-up and non auto-sign-in.', '        final PropertyModel continueBtnModel = createContinueBtnItem(account);', '        mSheetItems.add(new ListItem(ItemType.CONTINUE_BUTTON, continueBtnModel));', '', '        // Only show the user data sharing consent text for sign up.', '        if (!account.isSignIn()) {', '            String provider_url = UrlFormatter.formatUrlForSecurityDisplay(', '                    account.getOriginUrl(), SchemeDisplay.OMIT_HTTP_AND_HTTPS);', '            mSheetItems.add(new ListItem(ItemType.DATA_SHARING_CONSENT,', '                    createDataSharingConsentItem(provider_url, metadata)));', '        }', '    }', '', '    void showAccounts(', '            String url, List<Account> accounts, ClientIdMetadata metadata, boolean isAutoSignIn) {', '        mSheetItems.clear();', '        addHeader(url, accounts);', '        boolean hasSingleAccount = (accounts.size() == 1);']}, {'a': ['        addAccounts(accounts, /*areAccountsClickable=*/!hasSingleAccount);'], 'b': ['        addAccounts(accounts, !hasSingleAccount /* areAccountsClickable */);']}, {'ab': ['        if (hasSingleAccount) {', '            addButton(accounts.get(0), metadata, isAutoSignIn);', '        }', '', '        showContent();', '    }', '', '    /**', '     * Requests to show the bottom sheet. If it is not possible to immediately show the content', '     * (e.g., higher priority content is being shown) it removes the request from the bottom sheet', '     * controller queue and notifies the delegate of the dismissal.', '     */', '    @VisibleForTesting', '    void showContent() {', '        if (mBottomSheetController.requestShowContent(mBottomSheetContent, true)) {', '            mVisible = true;', '            mBottomSheetController.addObserver(mBottomSheetObserver);', '        } else {', '            onDismissed(BottomSheetController.StateChangeReason.NONE);', '        }', '    }', '', '    /**', '     * Requests to hide the bottom sheet.', '     */', '    void hideContent() {', '        mVisible = false;', '        mBottomSheetController.hideContent(mBottomSheetContent, true);', '    }', '', '    private void requestAvatarImage(PropertyModel accountModel) {', '        Account account = accountModel.get(AccountProperties.ACCOUNT);', '        final String name = account.getName();', '        final String avatarURL = account.getPictureUrl().getSpec();', '', '        if (!avatarURL.isEmpty()) {', '            ImageFetcher.Params params = ImageFetcher.Params.create(avatarURL,', '                    ImageFetcher.WEB_ID_ACCOUNT_SELECTION_UMA_CLIENT_NAME, mDesiredAvatarSize,', '                    mDesiredAvatarSize);', '', '            mImageFetcher.fetchImage(params, bitmap -> {', '                accountModel.set(AccountProperties.AVATAR,', '                        new AccountProperties.Avatar(name, bitmap, mDesiredAvatarSize));', '            });', '        } else {', '            accountModel.set(AccountProperties.AVATAR,', '                    new AccountProperties.Avatar(name, null, mDesiredAvatarSize));', '        }', '    }', '', '    private void requestIconOrFallbackImage(PropertyModel accountModel) {', '        Account account = accountModel.get(AccountProperties.ACCOUNT);', '        final GURL iconOrigin = account.getOriginUrl();', '        final LargeIconCallback setIcon = (icon, fallbackColor, hasDefaultColor, type) -> {', '            accountModel.set(AccountProperties.FAVICON_OR_FALLBACK,', '                    new AccountProperties.FaviconOrFallback(', '                            iconOrigin, icon, fallbackColor, mDesiredIconSize));', '        };', '        mLargeIconBridge.getLargeIconForUrl(iconOrigin, mDesiredIconSize, setIcon);', '    }', '', '    boolean isVisible() {', '        return mVisible;', '    }', '', '    void onAccountSelected(Account account) {', '        if (!mVisible) return;', '        hideContent();', '        mDelegate.onAccountSelected(account);', '    }', '', '    void onDismissed(@StateChangeReason int reason) {', '        hideContent();', '        mDelegate.onDismissed();', '    }', '', '    void onAutoSignInCancelled() {', '        hideContent();', '        mDelegate.onAutoSignInCancelled();', '    }', '', '    private PropertyModel createAccountItem(Account account, boolean isAccountClickable) {', '        PropertyModel.Builder modelBuilder = new PropertyModel.Builder(AccountProperties.ALL_KEYS)', '                                                     .with(AccountProperties.ACCOUNT, account);', '        if (isAccountClickable) {', '            modelBuilder.with(AccountProperties.ON_CLICK_LISTENER, this::onAccountSelected);', '        }', '        return modelBuilder.build();', '    }', '', '    private PropertyModel createContinueBtnItem(Account account) {', '        return new PropertyModel.Builder(ContinueButtonProperties.ALL_KEYS)', '                .with(ContinueButtonProperties.ACCOUNT, account)', '                .with(ContinueButtonProperties.ON_CLICK_LISTENER, this::onAccountSelected)', '                .build();', '    }', '', '    private PropertyModel createAutoSignInCancelBtnItem() {', '        return new PropertyModel.Builder(AutoSignInCancelButtonProperties.ALL_KEYS)', '                .with(AutoSignInCancelButtonProperties.ON_CLICK_LISTENER,', '                        this::onAutoSignInCancelled)', '                .build();', '    }', '', '    private PropertyModel createDataSharingConsentItem(String provider, ClientIdMetadata metadata) {', '        return new PropertyModel.Builder(DataSharingConsentProperties.ALL_KEYS)', '                .with(DataSharingConsentProperties.PROVIDER_URL, provider)', '                .with(DataSharingConsentProperties.TERMS_OF_SERVICE_URL,', '                        metadata.getTermsOfServiceUrl().getValidSpecOrEmpty())', '                .with(DataSharingConsentProperties.PRIVACY_POLICY_URL,', '                        metadata.getPrivacyPolicyUrl().getValidSpecOrEmpty())', '                .build();', '    }', '}', '']}]",chromium%2Fsrc~main~Ia8d49728a83d1db67ef658d13e9dee307480e922,f2396dc030d632db7e00809b1d7b4e89673cd62a,chrome/browser/ui/android/webid/internal/java/src/org/chromium/chrome/browser/ui/android/webid/AccountSelectionMediator.java,c2c02c8f_99d2f0a6_before.java,c2c02c8f_99d2f0a6_after.java,AccountSelectionMediator::showAccounts,True,True
69,4d806afb_8756af6a,62.0,Nit: Returns... https://google.github.io/styleguide/javaguide.html#s7.2-summary-fragment,62.0,62.0,"[{'ab': ['// Copyright 2015 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.firstrun;', '', 'import android.accounts.Account;', 'import android.app.Activity;', 'import android.content.Context;', 'import android.content.Intent;', 'import android.net.Uri;', 'import android.os.Bundle;', 'import android.os.SystemClock;', 'import android.provider.Settings;', '', 'import androidx.annotation.VisibleForTesting;', '', 'import org.chromium.base.ApiCompatibilityUtils;', 'import org.chromium.base.CommandLine;', 'import org.chromium.base.IntentUtils;', 'import org.chromium.base.Log;', 'import org.chromium.base.metrics.RecordHistogram;', 'import org.chromium.chrome.browser.IntentHandler;', 'import org.chromium.chrome.browser.LaunchIntentDispatcher;', 'import org.chromium.chrome.browser.childaccounts.ChildAccountService;', 'import org.chromium.chrome.browser.flags.ChromeSwitches;', 'import org.chromium.chrome.browser.locale.LocaleManager;', 'import org.chromium.chrome.browser.net.spdyproxy.DataReductionProxySettings;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.search_engines.SearchEnginePromoType;', 'import org.chromium.chrome.browser.signin.services.FREMobileIdentityConsistencyFieldTrial;', 'import org.chromium.chrome.browser.signin.services.IdentityServicesProvider;', 'import org.chromium.chrome.browser.signin.services.SigninManager;', 'import org.chromium.chrome.browser.vr.VrModuleProvider;', 'import org.chromium.components.embedder_support.util.UrlConstants;', 'import org.chromium.components.signin.AccountManagerFacadeProvider;', 'import org.chromium.components.signin.ChildAccountStatus;', 'import org.chromium.components.signin.ChildAccountStatus.Status;', 'import org.chromium.components.signin.identitymanager.ConsentLevel;', 'import org.chromium.components.signin.identitymanager.IdentityManager;', '', 'import java.util.List;', '', '/**', ' * A helper to determine what should be the sequence of First Run Experience screens, and whether', ' * it should be run.', ' *', ' * Usage:', ' * new FirstRunFlowSequencer(activity, launcherProvidedProperties) {', ' *     override onFlowIsKnown', ' * }.start();', ' */', 'public abstract class FirstRunFlowSequencer  {', '    private static final String TAG = ""firstrun"";', '', '    /**', '     * A delegate class to determine if first run promo pages should be shown based on various', '     * signals. Some methods may be overridden by tests to fake desired behavior.', '     */', '    @VisibleForTesting', '    public static class FirstRunFlowSequencerDelegate {']}, {'a': ['        /** Returns true if the sync consent promo page should be shown. */'], 'b': ['        /** @return true if the sync consent promo page should be shown. */']}, {'ab': ['        boolean shouldShowSyncConsentPage(', '                Activity activity, List<Account> accounts, @Status int childAccountStatus) {', '            if (ChildAccountStatus.isChild(childAccountStatus)) {']}, {'a': ['                // Always show the sync consent page for child account.'], 'b': ['                // Always show the sync consent page for child account']}, {'ab': ['                return true;', '            }', '            final IdentityManager identityManager =', '                    IdentityServicesProvider.get().getIdentityManager(', '                            Profile.getLastUsedRegularProfile());', '            if (identityManager.hasPrimaryAccount(ConsentLevel.SYNC) || !isSyncAllowed()) {', '                // No need to show the sync consent page if users already consented to sync or', '                // if sync is not allowed.', '                return false;', '            }', '            if (FREMobileIdentityConsistencyFieldTrial.isEnabled()) {', '                // Show the sync consent page only to the signed-in users.', '                return identityManager.hasPrimaryAccount(ConsentLevel.SIGNIN);', '            } else {', '                // We show the sync consent page if sync is allowed, and not signed in, and', '                // - ""skip the first use hints"" is not set, or', '                // - ""skip the first use hints"" is set, but there is at least one account.', '                return !shouldSkipFirstUseHints(activity) || !accounts.isEmpty();', '            }', '        }', '', '        /** @return true if the Data Reduction promo page should be shown. */', '        @VisibleForTesting', '        public boolean shouldShowDataReductionPage() {', '            return !DataReductionProxySettings.getInstance().isDataReductionProxyManaged()', '                    && DataReductionProxySettings.getInstance()', '                               .isDataReductionProxyFREPromoAllowed();', '        }', '', '        /** @return true if the Search Engine promo page should be shown. */', '        @VisibleForTesting', '        public boolean shouldShowSearchEnginePage() {', '            @SearchEnginePromoType', '            int searchPromoType = LocaleManager.getInstance().getSearchEnginePromoShowType();', '            return searchPromoType == SearchEnginePromoType.SHOW_NEW', '                    || searchPromoType == SearchEnginePromoType.SHOW_EXISTING;', '        }', '', '        /** @return true if Sync is allowed for the current user. */', '        @VisibleForTesting', '        protected boolean isSyncAllowed() {', '            SigninManager signinManager = IdentityServicesProvider.get().getSigninManager(', '                    Profile.getLastUsedRegularProfile());', '            return FirstRunUtils.canAllowSync() && !signinManager.isSigninDisabledByPolicy()', '                    && signinManager.isSigninSupported();', '        }', '', '        /** @return true if first use hints should be skipped. */', '        @VisibleForTesting', '        protected boolean shouldSkipFirstUseHints(Activity activity) {', '            return Settings.Secure.getInt(', '                           activity.getContentResolver(), Settings.Secure.SKIP_FIRST_USE_HINTS, 0)', '                    != 0;', '        }', '    }', '', '    private final Activity mActivity;', '    private @ChildAccountStatus.Status int mChildAccountStatus;', '    private List<Account> mGoogleAccounts;', '', '    /**', ""     * The delegate to be used by the Sequencer. By default, it's an instance of"", ""     * {@link FirstRunFlowSequencerDelegate}, unless it's overridden by {@code sDelegateForTesting}."", '     */', '    private FirstRunFlowSequencerDelegate mDelegate;', '', '    /** If not null, overrides {@code mDelegate} for this object during tests. */', '    private static FirstRunFlowSequencerDelegate sDelegateForTesting;', '', '    /**', '     * Callback that is called once the flow is determined.', '     * If the properties is null, the First Run experience needs to finish and', '     * restart the original intent if necessary.', '     * @param freProperties Properties to be used in the First Run activity, or null.', '     */', '    public abstract void onFlowIsKnown(Bundle freProperties);', '', '    public FirstRunFlowSequencer(Activity activity) {', '        mActivity = activity;', '        mDelegate = sDelegateForTesting != null ? sDelegateForTesting', '                                                : new FirstRunFlowSequencerDelegate();', '    }', '', '    /**', '     * Starts determining parameters for the First Run.', '     * Once finished, calls onFlowIsKnown().', '     */', '    public void start() {', '        long childAccountStatusStart = SystemClock.elapsedRealtime();', '        AccountManagerFacadeProvider.getInstance().getAccounts().then(accounts -> {', '            ChildAccountService.checkChildAccountStatus(accounts, status -> {', '                RecordHistogram.recordTimesHistogram(""MobileFre.ChildAccountStatusDuration"",', '                        SystemClock.elapsedRealtime() - childAccountStatusStart);', '                initializeSharedState(status, accounts);', '                processFreEnvironmentPreNative();', '            });', '        });', '    }', '', '    protected boolean shouldShowDataReductionPage() {', '        return mDelegate.shouldShowDataReductionPage();', '    }', '', '    @VisibleForTesting', '    protected boolean shouldShowSearchEnginePage() {', '        return mDelegate.shouldShowSearchEnginePage();', '    }', '', '    private boolean shouldShowSyncConsentPage() {', '        return mDelegate.shouldShowSyncConsentPage(mActivity, mGoogleAccounts, mChildAccountStatus);', '    }', '', '    @VisibleForTesting', '    protected void setFirstRunFlowSignInComplete() {', '        FirstRunSignInProcessor.setFirstRunFlowSignInComplete(true);', '    }', '', '    @VisibleForTesting', '    void initializeSharedState(', '            @ChildAccountStatus.Status int childAccountStatus, List<Account> accounts) {', '        mChildAccountStatus = childAccountStatus;', '        mGoogleAccounts = accounts;', '    }', '', '    void processFreEnvironmentPreNative() {', '        Bundle freProperties = new Bundle();', '        freProperties.putInt(SyncConsentFirstRunFragment.CHILD_ACCOUNT_STATUS, mChildAccountStatus);', '', '        onFlowIsKnown(freProperties);', '        if (ChildAccountStatus.isChild(mChildAccountStatus)) {', '            setFirstRunFlowSignInComplete();', '        }', '    }', '', '    /**', '     * Will be called either when policies are initialized, or when native is initialized if we have', '     * no on-device policies.', '     * @param freProperties Resulting FRE properties bundle.', '     */', '    public void updateFirstRunProperties(Bundle freProperties) {', '        freProperties.putBoolean(', '                FirstRunActivity.SHOW_SYNC_CONSENT_PAGE, shouldShowSyncConsentPage());', '        freProperties.putBoolean(', '                FirstRunActivity.SHOW_DATA_REDUCTION_PAGE, shouldShowDataReductionPage());', '        freProperties.putBoolean(', '                FirstRunActivity.SHOW_SEARCH_ENGINE_PAGE, shouldShowSearchEnginePage());', '    }', '', '    /**', '     * Marks a given flow as completed.', '     * @param signInAccountName The account name for the pending sign-in request. (Or null)', '     * @param showSignInSettings Whether the user selected to see the settings once signed in.', '     */', '    public static void markFlowAsCompleted(String signInAccountName, boolean showSignInSettings) {', '        // When the user accepts ToS in the Setup Wizard, we do not show the ToS page to the user', '        // because the user has already accepted one outside FRE.', '        if (!FirstRunUtils.isFirstRunEulaAccepted()) {', '            FirstRunUtils.setEulaAccepted();', '        }', '', '        // Mark the FRE flow as complete and set the sign-in flow preferences if necessary.', '        FirstRunSignInProcessor.finalizeFirstRunFlowState(signInAccountName, showSignInSettings);', '    }', '', '    /**', '     * Checks if the First Run Experience needs to be launched.', '     * @param preferLightweightFre Whether to prefer the Lightweight First Run Experience.', '     * @param fromIntent Intent used to launch the caller.', '     * @return Whether the First Run Experience needs to be launched.', '     */', '    public static boolean checkIfFirstRunIsNecessary(', '            boolean preferLightweightFre, Intent fromIntent) {', '        boolean isCct = fromIntent.getBooleanExtra(', '                                FirstRunActivityBase.EXTRA_CHROME_LAUNCH_INTENT_IS_CCT, false)', '                || LaunchIntentDispatcher.isCustomTabIntent(fromIntent);', '        return checkIfFirstRunIsNecessary(preferLightweightFre, isCct);', '    }', '', '    /**', '     * Checks if the First Run Experience needs to be launched.', '     * @param preferLightweightFre Whether to prefer the Lightweight First Run Experience.', '     * @param isCct Whether this check is being made in the context of a CCT.', '     * @return Whether the First Run Experience needs to be launched.', '     */', '    public static boolean checkIfFirstRunIsNecessary(boolean preferLightweightFre, boolean isCct) {', '        // If FRE is disabled (e.g. in tests), proceed directly to the intent handling.', '        if (CommandLine.getInstance().hasSwitch(ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE)', '                || ApiCompatibilityUtils.isDemoUser()', '                || ApiCompatibilityUtils.isRunningInUserTestHarness()) {', '            return false;', '        }', '        if (FirstRunStatus.getFirstRunFlowComplete()) {', '            // Promo pages are removed, so there is nothing else to show in FRE.', '            return false;', '        }', '        if (FirstRunStatus.isFirstRunSkippedByPolicy() && (isCct || preferLightweightFre)) {', '            // Domain policies may have caused CCTs to skip the FRE. While this needs to be figured', '            // out at runtime for each app restart, it should apply to all CCTs for the duration of', ""            // the app's lifetime."", '            return false;', '        }', '        if (preferLightweightFre', '                && (FirstRunStatus.shouldSkipWelcomePage()', '                        || FirstRunStatus.getLightweightFirstRunFlowComplete())) {', '            return false;', '        }', '        return true;', '    }', '', '    /**', '     * Tries to launch the First Run Experience.  If the Activity was launched with the wrong Intent', '     * flags, we first relaunch it to make sure it runs in its own task, then trigger First Run.', '     *', '     * @param caller               Activity instance that is checking if first run is necessary.', '     * @param fromIntent           Intent used to launch the caller.', '     * @param requiresBroadcast    Whether or not the Intent triggers a BroadcastReceiver.', '     * @param preferLightweightFre Whether to prefer the Lightweight First Run Experience.', '     * @return Whether startup must be blocked (e.g. via Activity#finish or dropping the Intent).', '     */', '    public static boolean launch(Context caller, Intent fromIntent, boolean requiresBroadcast,', '            boolean preferLightweightFre) {', '        // Check if the user needs to go through First Run at all.', '        if (!checkIfFirstRunIsNecessary(preferLightweightFre, fromIntent)) return false;', '', '        String intentUrl = IntentHandler.getUrlFromIntent(fromIntent);', '        Uri uri = intentUrl != null ? Uri.parse(intentUrl) : null;', '        if (uri != null && UrlConstants.CONTENT_SCHEME.equals(uri.getScheme())) {', '            caller.grantUriPermission(', '                    caller.getPackageName(), uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);', '        }', '', '        Log.d(TAG, ""Redirecting user through FRE."");', '', ""        // Launch the async restriction checking as soon as we know we'll be running FRE."", '        FirstRunAppRestrictionInfo.startInitializationHint();', '', '        if ((fromIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {', '            FreIntentCreator intentCreator = new FreIntentCreator();', '            Intent freIntent = intentCreator.create(', '                    caller, fromIntent, requiresBroadcast, preferLightweightFre);', '', '            // Although the FRE tries to run in the same task now, this is still needed for', '            // non-activity entry points like the search widget to launch at all. This flag does not', '            // seem to preclude an old task from being reused.', '            if (!(caller instanceof Activity)) {', '                freIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);', '            }', '', '            boolean isVrIntent = VrModuleProvider.getIntentDelegate().isVrIntent(fromIntent);', '            if (isVrIntent) {', '                freIntent =', '                        VrModuleProvider.getIntentDelegate().setupVrFreIntent(caller, freIntent);', '                // We cannot access Chrome right now, e.g. because the VR module is not installed.', '                if (freIntent == null) return true;', '            }', '            IntentUtils.safeStartActivity(caller, freIntent);', '        } else {', ""            // First Run requires that the Intent contains NEW_TASK so that it doesn't sit on top"", '            // of something else.', '            Intent newIntent = new Intent(fromIntent);', '            newIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);', '            IntentUtils.safeStartActivity(caller, newIntent);', '        }', '        return true;', '    }', '', '    /** Defines an alternative delegate for testing. Must be reset on {@code tearDown}. */', '    @VisibleForTesting', '    public static void setDelegateForTesting(FirstRunFlowSequencerDelegate delegate) {', '        sDelegateForTesting = delegate;', '    }', '}', '']}]",chromium%2Fsrc~main~I8ba145360c3bac92658deee8bcdece7c3afd2889,8bcac7993e185af9b6da80e0bf885e23892a3ab3,chrome/android/java/src/org/chromium/chrome/browser/firstrun/FirstRunFlowSequencer.java,4d806afb_8756af6a_before.java,4d806afb_8756af6a_after.java,FirstRunFlowSequencer::FirstRunFlowSequencerDelegate::shouldShowSyncConsentPage,True,True
70,7ca165b9_9bf39e2f,66.0,Nit: period.,66.0,66.0,"[{'ab': ['// Copyright 2015 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.firstrun;', '', 'import android.accounts.Account;', 'import android.app.Activity;', 'import android.content.Context;', 'import android.content.Intent;', 'import android.net.Uri;', 'import android.os.Bundle;', 'import android.os.SystemClock;', 'import android.provider.Settings;', '', 'import androidx.annotation.VisibleForTesting;', '', 'import org.chromium.base.ApiCompatibilityUtils;', 'import org.chromium.base.CommandLine;', 'import org.chromium.base.IntentUtils;', 'import org.chromium.base.Log;', 'import org.chromium.base.metrics.RecordHistogram;', 'import org.chromium.chrome.browser.IntentHandler;', 'import org.chromium.chrome.browser.LaunchIntentDispatcher;', 'import org.chromium.chrome.browser.childaccounts.ChildAccountService;', 'import org.chromium.chrome.browser.flags.ChromeSwitches;', 'import org.chromium.chrome.browser.locale.LocaleManager;', 'import org.chromium.chrome.browser.net.spdyproxy.DataReductionProxySettings;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.search_engines.SearchEnginePromoType;', 'import org.chromium.chrome.browser.signin.services.FREMobileIdentityConsistencyFieldTrial;', 'import org.chromium.chrome.browser.signin.services.IdentityServicesProvider;', 'import org.chromium.chrome.browser.signin.services.SigninManager;', 'import org.chromium.chrome.browser.vr.VrModuleProvider;', 'import org.chromium.components.embedder_support.util.UrlConstants;', 'import org.chromium.components.signin.AccountManagerFacadeProvider;', 'import org.chromium.components.signin.ChildAccountStatus;', 'import org.chromium.components.signin.ChildAccountStatus.Status;', 'import org.chromium.components.signin.identitymanager.ConsentLevel;', 'import org.chromium.components.signin.identitymanager.IdentityManager;', '', 'import java.util.List;', '', '/**', ' * A helper to determine what should be the sequence of First Run Experience screens, and whether', ' * it should be run.', ' *', ' * Usage:', ' * new FirstRunFlowSequencer(activity, launcherProvidedProperties) {', ' *     override onFlowIsKnown', ' * }.start();', ' */', 'public abstract class FirstRunFlowSequencer  {', '    private static final String TAG = ""firstrun"";', '', '    /**', '     * A delegate class to determine if first run promo pages should be shown based on various', '     * signals. Some methods may be overridden by tests to fake desired behavior.', '     */', '    @VisibleForTesting', '    public static class FirstRunFlowSequencerDelegate {']}, {'a': ['        /** Returns true if the sync consent promo page should be shown. */'], 'b': ['        /** @return true if the sync consent promo page should be shown. */']}, {'ab': ['        boolean shouldShowSyncConsentPage(', '                Activity activity, List<Account> accounts, @Status int childAccountStatus) {', '            if (ChildAccountStatus.isChild(childAccountStatus)) {']}, {'a': ['                // Always show the sync consent page for child account.'], 'b': ['                // Always show the sync consent page for child account']}, {'ab': ['                return true;', '            }', '            final IdentityManager identityManager =', '                    IdentityServicesProvider.get().getIdentityManager(', '                            Profile.getLastUsedRegularProfile());', '            if (identityManager.hasPrimaryAccount(ConsentLevel.SYNC) || !isSyncAllowed()) {', '                // No need to show the sync consent page if users already consented to sync or', '                // if sync is not allowed.', '                return false;', '            }', '            if (FREMobileIdentityConsistencyFieldTrial.isEnabled()) {', '                // Show the sync consent page only to the signed-in users.', '                return identityManager.hasPrimaryAccount(ConsentLevel.SIGNIN);', '            } else {', '                // We show the sync consent page if sync is allowed, and not signed in, and', '                // - ""skip the first use hints"" is not set, or', '                // - ""skip the first use hints"" is set, but there is at least one account.', '                return !shouldSkipFirstUseHints(activity) || !accounts.isEmpty();', '            }', '        }', '', '        /** @return true if the Data Reduction promo page should be shown. */', '        @VisibleForTesting', '        public boolean shouldShowDataReductionPage() {', '            return !DataReductionProxySettings.getInstance().isDataReductionProxyManaged()', '                    && DataReductionProxySettings.getInstance()', '                               .isDataReductionProxyFREPromoAllowed();', '        }', '', '        /** @return true if the Search Engine promo page should be shown. */', '        @VisibleForTesting', '        public boolean shouldShowSearchEnginePage() {', '            @SearchEnginePromoType', '            int searchPromoType = LocaleManager.getInstance().getSearchEnginePromoShowType();', '            return searchPromoType == SearchEnginePromoType.SHOW_NEW', '                    || searchPromoType == SearchEnginePromoType.SHOW_EXISTING;', '        }', '', '        /** @return true if Sync is allowed for the current user. */', '        @VisibleForTesting', '        protected boolean isSyncAllowed() {', '            SigninManager signinManager = IdentityServicesProvider.get().getSigninManager(', '                    Profile.getLastUsedRegularProfile());', '            return FirstRunUtils.canAllowSync() && !signinManager.isSigninDisabledByPolicy()', '                    && signinManager.isSigninSupported();', '        }', '', '        /** @return true if first use hints should be skipped. */', '        @VisibleForTesting', '        protected boolean shouldSkipFirstUseHints(Activity activity) {', '            return Settings.Secure.getInt(', '                           activity.getContentResolver(), Settings.Secure.SKIP_FIRST_USE_HINTS, 0)', '                    != 0;', '        }', '    }', '', '    private final Activity mActivity;', '    private @ChildAccountStatus.Status int mChildAccountStatus;', '    private List<Account> mGoogleAccounts;', '', '    /**', ""     * The delegate to be used by the Sequencer. By default, it's an instance of"", ""     * {@link FirstRunFlowSequencerDelegate}, unless it's overridden by {@code sDelegateForTesting}."", '     */', '    private FirstRunFlowSequencerDelegate mDelegate;', '', '    /** If not null, overrides {@code mDelegate} for this object during tests. */', '    private static FirstRunFlowSequencerDelegate sDelegateForTesting;', '', '    /**', '     * Callback that is called once the flow is determined.', '     * If the properties is null, the First Run experience needs to finish and', '     * restart the original intent if necessary.', '     * @param freProperties Properties to be used in the First Run activity, or null.', '     */', '    public abstract void onFlowIsKnown(Bundle freProperties);', '', '    public FirstRunFlowSequencer(Activity activity) {', '        mActivity = activity;', '        mDelegate = sDelegateForTesting != null ? sDelegateForTesting', '                                                : new FirstRunFlowSequencerDelegate();', '    }', '', '    /**', '     * Starts determining parameters for the First Run.', '     * Once finished, calls onFlowIsKnown().', '     */', '    public void start() {', '        long childAccountStatusStart = SystemClock.elapsedRealtime();', '        AccountManagerFacadeProvider.getInstance().getAccounts().then(accounts -> {', '            ChildAccountService.checkChildAccountStatus(accounts, status -> {', '                RecordHistogram.recordTimesHistogram(""MobileFre.ChildAccountStatusDuration"",', '                        SystemClock.elapsedRealtime() - childAccountStatusStart);', '                initializeSharedState(status, accounts);', '                processFreEnvironmentPreNative();', '            });', '        });', '    }', '', '    protected boolean shouldShowDataReductionPage() {', '        return mDelegate.shouldShowDataReductionPage();', '    }', '', '    @VisibleForTesting', '    protected boolean shouldShowSearchEnginePage() {', '        return mDelegate.shouldShowSearchEnginePage();', '    }', '', '    private boolean shouldShowSyncConsentPage() {', '        return mDelegate.shouldShowSyncConsentPage(mActivity, mGoogleAccounts, mChildAccountStatus);', '    }', '', '    @VisibleForTesting', '    protected void setFirstRunFlowSignInComplete() {', '        FirstRunSignInProcessor.setFirstRunFlowSignInComplete(true);', '    }', '', '    @VisibleForTesting', '    void initializeSharedState(', '            @ChildAccountStatus.Status int childAccountStatus, List<Account> accounts) {', '        mChildAccountStatus = childAccountStatus;', '        mGoogleAccounts = accounts;', '    }', '', '    void processFreEnvironmentPreNative() {', '        Bundle freProperties = new Bundle();', '        freProperties.putInt(SyncConsentFirstRunFragment.CHILD_ACCOUNT_STATUS, mChildAccountStatus);', '', '        onFlowIsKnown(freProperties);', '        if (ChildAccountStatus.isChild(mChildAccountStatus)) {', '            setFirstRunFlowSignInComplete();', '        }', '    }', '', '    /**', '     * Will be called either when policies are initialized, or when native is initialized if we have', '     * no on-device policies.', '     * @param freProperties Resulting FRE properties bundle.', '     */', '    public void updateFirstRunProperties(Bundle freProperties) {', '        freProperties.putBoolean(', '                FirstRunActivity.SHOW_SYNC_CONSENT_PAGE, shouldShowSyncConsentPage());', '        freProperties.putBoolean(', '                FirstRunActivity.SHOW_DATA_REDUCTION_PAGE, shouldShowDataReductionPage());', '        freProperties.putBoolean(', '                FirstRunActivity.SHOW_SEARCH_ENGINE_PAGE, shouldShowSearchEnginePage());', '    }', '', '    /**', '     * Marks a given flow as completed.', '     * @param signInAccountName The account name for the pending sign-in request. (Or null)', '     * @param showSignInSettings Whether the user selected to see the settings once signed in.', '     */', '    public static void markFlowAsCompleted(String signInAccountName, boolean showSignInSettings) {', '        // When the user accepts ToS in the Setup Wizard, we do not show the ToS page to the user', '        // because the user has already accepted one outside FRE.', '        if (!FirstRunUtils.isFirstRunEulaAccepted()) {', '            FirstRunUtils.setEulaAccepted();', '        }', '', '        // Mark the FRE flow as complete and set the sign-in flow preferences if necessary.', '        FirstRunSignInProcessor.finalizeFirstRunFlowState(signInAccountName, showSignInSettings);', '    }', '', '    /**', '     * Checks if the First Run Experience needs to be launched.', '     * @param preferLightweightFre Whether to prefer the Lightweight First Run Experience.', '     * @param fromIntent Intent used to launch the caller.', '     * @return Whether the First Run Experience needs to be launched.', '     */', '    public static boolean checkIfFirstRunIsNecessary(', '            boolean preferLightweightFre, Intent fromIntent) {', '        boolean isCct = fromIntent.getBooleanExtra(', '                                FirstRunActivityBase.EXTRA_CHROME_LAUNCH_INTENT_IS_CCT, false)', '                || LaunchIntentDispatcher.isCustomTabIntent(fromIntent);', '        return checkIfFirstRunIsNecessary(preferLightweightFre, isCct);', '    }', '', '    /**', '     * Checks if the First Run Experience needs to be launched.', '     * @param preferLightweightFre Whether to prefer the Lightweight First Run Experience.', '     * @param isCct Whether this check is being made in the context of a CCT.', '     * @return Whether the First Run Experience needs to be launched.', '     */', '    public static boolean checkIfFirstRunIsNecessary(boolean preferLightweightFre, boolean isCct) {', '        // If FRE is disabled (e.g. in tests), proceed directly to the intent handling.', '        if (CommandLine.getInstance().hasSwitch(ChromeSwitches.DISABLE_FIRST_RUN_EXPERIENCE)', '                || ApiCompatibilityUtils.isDemoUser()', '                || ApiCompatibilityUtils.isRunningInUserTestHarness()) {', '            return false;', '        }', '        if (FirstRunStatus.getFirstRunFlowComplete()) {', '            // Promo pages are removed, so there is nothing else to show in FRE.', '            return false;', '        }', '        if (FirstRunStatus.isFirstRunSkippedByPolicy() && (isCct || preferLightweightFre)) {', '            // Domain policies may have caused CCTs to skip the FRE. While this needs to be figured', '            // out at runtime for each app restart, it should apply to all CCTs for the duration of', ""            // the app's lifetime."", '            return false;', '        }', '        if (preferLightweightFre', '                && (FirstRunStatus.shouldSkipWelcomePage()', '                        || FirstRunStatus.getLightweightFirstRunFlowComplete())) {', '            return false;', '        }', '        return true;', '    }', '', '    /**', '     * Tries to launch the First Run Experience.  If the Activity was launched with the wrong Intent', '     * flags, we first relaunch it to make sure it runs in its own task, then trigger First Run.', '     *', '     * @param caller               Activity instance that is checking if first run is necessary.', '     * @param fromIntent           Intent used to launch the caller.', '     * @param requiresBroadcast    Whether or not the Intent triggers a BroadcastReceiver.', '     * @param preferLightweightFre Whether to prefer the Lightweight First Run Experience.', '     * @return Whether startup must be blocked (e.g. via Activity#finish or dropping the Intent).', '     */', '    public static boolean launch(Context caller, Intent fromIntent, boolean requiresBroadcast,', '            boolean preferLightweightFre) {', '        // Check if the user needs to go through First Run at all.', '        if (!checkIfFirstRunIsNecessary(preferLightweightFre, fromIntent)) return false;', '', '        String intentUrl = IntentHandler.getUrlFromIntent(fromIntent);', '        Uri uri = intentUrl != null ? Uri.parse(intentUrl) : null;', '        if (uri != null && UrlConstants.CONTENT_SCHEME.equals(uri.getScheme())) {', '            caller.grantUriPermission(', '                    caller.getPackageName(), uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);', '        }', '', '        Log.d(TAG, ""Redirecting user through FRE."");', '', ""        // Launch the async restriction checking as soon as we know we'll be running FRE."", '        FirstRunAppRestrictionInfo.startInitializationHint();', '', '        if ((fromIntent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {', '            FreIntentCreator intentCreator = new FreIntentCreator();', '            Intent freIntent = intentCreator.create(', '                    caller, fromIntent, requiresBroadcast, preferLightweightFre);', '', '            // Although the FRE tries to run in the same task now, this is still needed for', '            // non-activity entry points like the search widget to launch at all. This flag does not', '            // seem to preclude an old task from being reused.', '            if (!(caller instanceof Activity)) {', '                freIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);', '            }', '', '            boolean isVrIntent = VrModuleProvider.getIntentDelegate().isVrIntent(fromIntent);', '            if (isVrIntent) {', '                freIntent =', '                        VrModuleProvider.getIntentDelegate().setupVrFreIntent(caller, freIntent);', '                // We cannot access Chrome right now, e.g. because the VR module is not installed.', '                if (freIntent == null) return true;', '            }', '            IntentUtils.safeStartActivity(caller, freIntent);', '        } else {', ""            // First Run requires that the Intent contains NEW_TASK so that it doesn't sit on top"", '            // of something else.', '            Intent newIntent = new Intent(fromIntent);', '            newIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);', '            IntentUtils.safeStartActivity(caller, newIntent);', '        }', '        return true;', '    }', '', '    /** Defines an alternative delegate for testing. Must be reset on {@code tearDown}. */', '    @VisibleForTesting', '    public static void setDelegateForTesting(FirstRunFlowSequencerDelegate delegate) {', '        sDelegateForTesting = delegate;', '    }', '}', '']}]",chromium%2Fsrc~main~I8ba145360c3bac92658deee8bcdece7c3afd2889,8bcac7993e185af9b6da80e0bf885e23892a3ab3,chrome/android/java/src/org/chromium/chrome/browser/firstrun/FirstRunFlowSequencer.java,7ca165b9_9bf39e2f_before.java,7ca165b9_9bf39e2f_after.java,FirstRunFlowSequencer::FirstRunFlowSequencerDelegate::shouldShowSyncConsentPage,True,True
71,42aefa39_379f1917,137.0,I feel like I've seen you do this before in another recent CL. Is there a shared place you can put this pattern?,136.0,137.0,"[{'ab': ['// Copyright 2021 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser.firstrun;', '', 'import static androidx.test.espresso.Espresso.onView;', 'import static androidx.test.espresso.action.ViewActions.click;', 'import static androidx.test.espresso.assertion.ViewAssertions.matches;', 'import static androidx.test.espresso.matcher.ViewMatchers.isDisplayed;', 'import static androidx.test.espresso.matcher.ViewMatchers.withId;', 'import static androidx.test.espresso.matcher.ViewMatchers.withText;', '', 'import static org.hamcrest.Matchers.not;', 'import static org.mockito.Mockito.when;', '', 'import android.accounts.Account;', 'import android.content.Intent;', 'import android.support.test.runner.lifecycle.Stage;', '', 'import androidx.test.filters.MediumTest;', '', 'import org.junit.Before;', 'import org.junit.Rule;', 'import org.junit.Test;', 'import org.junit.runner.RunWith;', 'import org.mockito.Mock;', 'import org.mockito.junit.MockitoJUnit;', 'import org.mockito.junit.MockitoRule;', '', 'import org.chromium.base.ContextUtils;', 'import org.chromium.base.test.BaseActivityTestRule;', 'import org.chromium.base.test.util.ApplicationTestUtils;', 'import org.chromium.base.test.util.CommandLineFlags;', 'import org.chromium.base.test.util.CriteriaHelper;', 'import org.chromium.chrome.R;', 'import org.chromium.chrome.browser.flags.ChromeSwitches;', 'import org.chromium.chrome.browser.signin.SigninFirstRunFragment;', 'import org.chromium.chrome.test.ChromeJUnit4ClassRunner;', 'import org.chromium.chrome.test.util.browser.signin.AccountManagerTestRule;', 'import org.chromium.components.externalauth.ExternalAuthUtils;', 'import org.chromium.components.signin.ChildAccountStatus;', 'import org.chromium.components.signin.test.util.FakeAccountManagerFacade;', 'import org.chromium.content_public.browser.test.util.TestThreadUtils;', '', '/**', ' * Integration tests for the first run experience with sign-in and sync decoupled.', ' */', '@RunWith(ChromeJUnit4ClassRunner.class)', '@CommandLineFlags.Add({ChromeSwitches.FORCE_ENABLE_SIGNIN_FRE})', 'public class FirstRunActivitySigninAndSyncTest {', '    private static final String TEST_EMAIL = ""test.account@gmail.com"";', '    private static final String CHILD_EMAIL = ""child.account@gmail.com"";', '', '    @Rule', '    public final MockitoRule mMockitoRule = MockitoJUnit.rule();', '', '    private final FakeAccountManagerFacade mFakeAccountManagerFacade =', '            new FakeAccountManagerFacade() {', '                @Override', '                public void checkChildAccountStatus(', '                        Account account, ChildAccountStatusListener listener) {', '                    listener.onStatusReady(account.name.equals(CHILD_EMAIL)', '                                    ? ChildAccountStatus.REGULAR_CHILD', '                                    : ChildAccountStatus.NOT_CHILD);', '                }', '            };', '', '    @Rule', '    public final AccountManagerTestRule mAccountManagerTestRule =', '            new AccountManagerTestRule(mFakeAccountManagerFacade);', '', '    @Rule', '    public final BaseActivityTestRule<FirstRunActivity> mFirstRunActivityRule =', '            new BaseActivityTestRule<>(FirstRunActivity.class);', '', '    @Mock', '    private ExternalAuthUtils mExternalAuthUtilsMock;', '', '    @Before', '    public void setUp() {', '        when(mExternalAuthUtilsMock.canUseGooglePlayServices()).thenReturn(true);', '        ExternalAuthUtils.setInstanceForTesting(mExternalAuthUtilsMock);', '    }', '', '    @Test', '    @MediumTest', '    public void dismissButtonClickSkipsSyncConsentPageWhenNoAccountsAreOnDevice() {', '        launchFirstRunActivity();', '        onView(withId(R.id.signin_fre_selected_account)).check(matches(not(isDisplayed())));', '', '        onView(withText(R.string.signin_fre_dismiss_button)).perform(click());', '', '        ensureCurrentPageIs(DataReductionProxyFirstRunFragment.class);', '    }', '', '    @Test', '    @MediumTest', '    public void dismissButtonClickSkipsSyncConsentPageWhenOneAccountIsOnDevice() {', '        mAccountManagerTestRule.addAccount(TEST_EMAIL);', '        launchFirstRunActivity();', '        onView(withId(R.id.signin_fre_selected_account)).check(matches(isDisplayed()));', '', '        onView(withText(R.string.signin_fre_dismiss_button)).perform(click());', '', '        ensureCurrentPageIs(DataReductionProxyFirstRunFragment.class);', '    }', '', '    @Test', '    @MediumTest', '    public void continueButtonClickShowsSyncConsentPage() {', '        mAccountManagerTestRule.addAccount(TEST_EMAIL);', '        launchFirstRunActivity();', '        ensureCurrentPageIs(SigninFirstRunFragment.class);', '        onView(withId(R.id.signin_fre_selected_account)).check(matches(isDisplayed()));', '']}, {'a': ['        clickContinueButton();'], 'b': ['        // This helps to reduce flakiness on some marshmallow bots in comparison with', '        // espresso click.', '        TestThreadUtils.runOnUiThreadBlocking(() -> {', '            mFirstRunActivityRule.getActivity()', '                    .findViewById(R.id.signin_fre_continue_button)', '                    .performClick();', '        });']}, {'ab': ['', '        ensureCurrentPageIs(SyncConsentFirstRunFragment.class);', '    }', '', '    @Test', '    @MediumTest', '    public void continueButtonClickShowsSyncConsentPageWithChildAccount() {', '        mAccountManagerTestRule.addAccount(CHILD_EMAIL);', '        launchFirstRunActivity();', '        ensureCurrentPageIs(SigninFirstRunFragment.class);', '        onView(withId(R.id.signin_fre_selected_account)).check(matches(isDisplayed()));', '']}, {'a': ['        clickContinueButton();', '', '        ensureCurrentPageIs(SyncConsentFirstRunFragment.class);', '    }', '', '    private void clickContinueButton() {']}, {'ab': ['        // This helps to reduce flakiness on some marshmallow bots in comparison with', '        // espresso click.', '        TestThreadUtils.runOnUiThreadBlocking(() -> {', '            mFirstRunActivityRule.getActivity()', '                    .findViewById(R.id.signin_fre_continue_button)', '                    .performClick();', '        });']}, {'b': ['', '        ensureCurrentPageIs(SyncConsentFirstRunFragment.class);']}, {'ab': ['    }', '', '    private <T extends FirstRunFragment> void ensureCurrentPageIs(Class<T> fragmentClass) {', '        CriteriaHelper.pollUiThread(() -> {', '            return fragmentClass.isInstance(', '                    mFirstRunActivityRule.getActivity().getCurrentFragmentForTesting());', '        }, fragmentClass.getName() + "" should be the current page"");', '    }', '', '    private void launchFirstRunActivity() {', '        final Intent intent =', '                new Intent(ContextUtils.getApplicationContext(), FirstRunActivity.class);', '        mFirstRunActivityRule.launchActivity(intent);', '        ApplicationTestUtils.waitForActivityState(', '                mFirstRunActivityRule.getActivity(), Stage.RESUMED);', '        CriteriaHelper.pollUiThread(', '                mFirstRunActivityRule.getActivity()::isNativeSideIsInitializedForTest);', '    }', '}', '']}]",chromium%2Fsrc~main~I8ba145360c3bac92658deee8bcdece7c3afd2889,8bcac7993e185af9b6da80e0bf885e23892a3ab3,chrome/android/javatests/src/org/chromium/chrome/browser/firstrun/FirstRunActivitySigninAndSyncTest.java,42aefa39_379f1917_before.java,42aefa39_379f1917_after.java,FirstRunActivitySigninAndSyncTest::continueButtonClickShowsSyncConsentPageWithChildAccount,True,True
72,4ddf1150_88a6e516,2171.0,"Think of the case: 1) user open this background Tab. 2) tap the tab switcher button and enter the tab switcher. 3) choose the background tab from the tab switcher again. 4) on the background tab, taps the back button. There are many steps are done before it returns to the Start surface, do you still want to close this background tab? I'm fine with deleting the tab here, but just want to make sure that you really want to delete this tab in such a case.

Actually, I think this could be:
if (type == TabLaunchType.FROM_LONGPRESS_BACKGROUND && !StartSurfaceUserData.getKeepTab(currentTab)) {
  getCurrentTabModel().closeTab(currentTab);
}

StartSurfaceUserData.setKeepTab() is called when user taps either home button or tab switcher button on the tab. It distinguishes the cases that tapping the back button directly after opening the tab from the cases that user does multiple other steps. Wdyt?",2169.0,2171.0,"[{'ab': ['// Copyright 2015 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser;', '', 'import android.annotation.TargetApi;', 'import android.app.ActivityManager;', 'import android.content.ComponentName;', 'import android.content.Context;', 'import android.content.Intent;', 'import android.content.pm.ApplicationInfo;', 'import android.content.pm.ShortcutManager;', 'import android.os.Build;', 'import android.os.Bundle;', 'import android.os.SystemClock;', 'import android.text.TextUtils;', 'import android.text.format.DateUtils;', 'import android.util.Pair;', 'import android.view.KeyEvent;', 'import android.view.KeyboardShortcutGroup;', 'import android.view.Menu;', 'import android.view.View;', 'import android.view.View.OnClickListener;', 'import android.view.ViewConfiguration;', 'import android.view.ViewGroup;', 'import android.view.Window;', 'import android.view.WindowManager;', '', 'import androidx.annotation.IntDef;', 'import androidx.annotation.Nullable;', 'import androidx.annotation.VisibleForTesting;', 'import androidx.lifecycle.Lifecycle;', 'import androidx.lifecycle.LifecycleObserver;', 'import androidx.lifecycle.LifecycleRegistry;', '', 'import org.chromium.base.CallbackController;', 'import org.chromium.base.CommandLine;', 'import org.chromium.base.ContextUtils;', 'import org.chromium.base.IntentUtils;', 'import org.chromium.base.Log;', 'import org.chromium.base.MemoryPressureListener;', 'import org.chromium.base.ThreadUtils;', 'import org.chromium.base.TraceEvent;', 'import org.chromium.base.annotations.UsedByReflection;', 'import org.chromium.base.jank_tracker.JankTrackerImpl;', 'import org.chromium.base.library_loader.LibraryLoader;', 'import org.chromium.base.metrics.RecordHistogram;', 'import org.chromium.base.metrics.RecordUserAction;', 'import org.chromium.base.supplier.ObservableSupplierImpl;', 'import org.chromium.base.supplier.OneShotCallback;', 'import org.chromium.base.supplier.OneshotSupplier;', 'import org.chromium.base.supplier.OneshotSupplierImpl;', 'import org.chromium.base.supplier.Supplier;', 'import org.chromium.base.supplier.UnownedUserDataSupplier;', 'import org.chromium.base.task.PostTask;', 'import org.chromium.cc.input.BrowserControlsState;', 'import org.chromium.chrome.R;', 'import org.chromium.chrome.browser.IntentHandler.IntentHandlerDelegate;', 'import org.chromium.chrome.browser.IntentHandler.TabOpenType;', 'import org.chromium.chrome.browser.accessibility_tab_switcher.OverviewListLayout;', 'import org.chromium.chrome.browser.app.ChromeActivity;', 'import org.chromium.chrome.browser.app.metrics.LaunchCauseMetrics;', 'import org.chromium.chrome.browser.app.metrics.TabbedActivityLaunchCauseMetrics;', 'import org.chromium.chrome.browser.app.tabmodel.AsyncTabParamsManagerSingleton;', 'import org.chromium.chrome.browser.app.tabmodel.ChromeNextTabPolicySupplier;', 'import org.chromium.chrome.browser.app.tabmodel.TabModelOrchestrator;', 'import org.chromium.chrome.browser.app.tabmodel.TabWindowManagerSingleton;', 'import org.chromium.chrome.browser.app.tabmodel.TabbedModeTabModelOrchestrator;', 'import org.chromium.chrome.browser.bookmarks.BookmarkUtils;', 'import org.chromium.chrome.browser.browserservices.intents.WebappConstants;', 'import org.chromium.chrome.browser.compositor.CompositorViewHolder;', 'import org.chromium.chrome.browser.compositor.bottombar.ephemeraltab.EphemeralTabCoordinator;', 'import org.chromium.chrome.browser.compositor.layouts.Layout;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChrome;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChromePhone;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChromeTablet;', 'import org.chromium.chrome.browser.compositor.layouts.OverviewModeBehavior;', 'import org.chromium.chrome.browser.compositor.layouts.OverviewModeController;', 'import org.chromium.chrome.browser.cookies.CookiesFetcher;', 'import org.chromium.chrome.browser.crypto.CipherFactory;', 'import org.chromium.chrome.browser.dependency_injection.ChromeActivityComponent;', 'import org.chromium.chrome.browser.device.DeviceClassManager;', 'import org.chromium.chrome.browser.dom_distiller.ReaderModeManager;', 'import org.chromium.chrome.browser.download.DownloadNotificationService;', 'import org.chromium.chrome.browser.download.DownloadOpenSource;', 'import org.chromium.chrome.browser.download.DownloadUtils;', 'import org.chromium.chrome.browser.feature_engagement.TrackerFactory;', 'import org.chromium.chrome.browser.feed.FeedSurfaceTracker;', 'import org.chromium.chrome.browser.firstrun.FirstRunSignInProcessor;', 'import org.chromium.chrome.browser.flags.ActivityType;', 'import org.chromium.chrome.browser.flags.CachedFeatureFlags;', 'import org.chromium.chrome.browser.flags.ChromeFeatureList;', 'import org.chromium.chrome.browser.flags.ChromeSwitches;', 'import org.chromium.chrome.browser.fonts.FontPreloader;', 'import org.chromium.chrome.browser.gesturenav.NavigationSheet;', 'import org.chromium.chrome.browser.homepage.HomepageManager;', 'import org.chromium.chrome.browser.incognito.IncognitoNotificationManager;', 'import org.chromium.chrome.browser.incognito.IncognitoNotificationPresenceController;', 'import org.chromium.chrome.browser.incognito.IncognitoProfileDestroyer;', 'import org.chromium.chrome.browser.incognito.IncognitoStartup;', 'import org.chromium.chrome.browser.incognito.IncognitoTabLauncher;', 'import org.chromium.chrome.browser.incognito.IncognitoTabSnapshotController;', 'import org.chromium.chrome.browser.incognito.IncognitoUtils;', 'import org.chromium.chrome.browser.infobar.DataReductionPromoInfoBar;', 'import org.chromium.chrome.browser.infobar.SyncErrorInfoBar;', 'import org.chromium.chrome.browser.layouts.LayoutStateProvider;', 'import org.chromium.chrome.browser.lifecycle.ActivityLifecycleDispatcher;', 'import org.chromium.chrome.browser.locale.LocaleManager;', 'import org.chromium.chrome.browser.metrics.AndroidSessionDurationsServiceState;', 'import org.chromium.chrome.browser.metrics.LaunchMetrics;', 'import org.chromium.chrome.browser.metrics.MainIntentBehaviorMetrics;', 'import org.chromium.chrome.browser.modaldialog.ChromeTabModalPresenter;', 'import org.chromium.chrome.browser.modaldialog.TabModalLifetimeHandler;', 'import org.chromium.chrome.browser.multiwindow.MultiInstanceChromeTabbedActivity;', 'import org.chromium.chrome.browser.multiwindow.MultiInstanceManager;', 'import org.chromium.chrome.browser.multiwindow.MultiWindowUtils;', 'import org.chromium.chrome.browser.native_page.NativePageAssassin;', 'import org.chromium.chrome.browser.navigation_predictor.NavigationPredictorBridge;', 'import org.chromium.chrome.browser.night_mode.WebContentsDarkModeController;', 'import org.chromium.chrome.browser.ntp.NewTabPageLaunchOrigin;', 'import org.chromium.chrome.browser.ntp.NewTabPageUma;', 'import org.chromium.chrome.browser.ntp.NewTabPageUtils;', 'import org.chromium.chrome.browser.omnibox.OmniboxFocusReason;', 'import org.chromium.chrome.browser.paint_preview.StartupPaintPreviewHelper;', 'import org.chromium.chrome.browser.paint_preview.StartupPaintPreviewHelperSupplier;', 'import org.chromium.chrome.browser.partnercustomizations.PartnerBrowserCustomizations;', 'import org.chromium.chrome.browser.preferences.ChromePreferenceKeys;', 'import org.chromium.chrome.browser.profiles.OTRProfileID;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.profiles.ProfileManager;', 'import org.chromium.chrome.browser.reengagement.ReengagementNotificationController;', 'import org.chromium.chrome.browser.search_engines.SearchEngineChoiceNotification;', 'import org.chromium.chrome.browser.settings.SettingsLauncherImpl;', 'import org.chromium.chrome.browser.share.send_tab_to_self.SendTabToSelfAndroidBridge;', 'import org.chromium.chrome.browser.suggestions.SuggestionsMetrics;', 'import org.chromium.chrome.browser.survey.ChromeSurveyController;', 'import org.chromium.chrome.browser.sync.ui.SyncErrorMessage;', 'import org.chromium.chrome.browser.sync.ui.SyncErrorPromptUtils;', 'import org.chromium.chrome.browser.tab.RedirectHandlerTabHelper;', 'import org.chromium.chrome.browser.tab.Tab;', 'import org.chromium.chrome.browser.tab.TabAssociatedApp;', 'import org.chromium.chrome.browser.tab.TabCreationState;', 'import org.chromium.chrome.browser.tab.TabDelegateFactory;', 'import org.chromium.chrome.browser.tab.TabLaunchType;', 'import org.chromium.chrome.browser.tab.TabSelectionType;', 'import org.chromium.chrome.browser.tab.state.CriticalPersistedTabData;', 'import org.chromium.chrome.browser.tabbed_mode.TabbedAppMenuPropertiesDelegate;', 'import org.chromium.chrome.browser.tabbed_mode.TabbedRootUiCoordinator;', 'import org.chromium.chrome.browser.tabmodel.ChromeTabCreator;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHost;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHostRegistry;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHostUtils;', 'import org.chromium.chrome.browser.tabmodel.NextTabPolicy.NextTabPolicySupplier;', 'import org.chromium.chrome.browser.tabmodel.TabModel;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelector;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorBase;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorTabModelObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorTabObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelUtils;', 'import org.chromium.chrome.browser.tabmodel.TabWindowManager;', 'import org.chromium.chrome.browser.tasks.ConditionalTabStripUtils;', 'import org.chromium.chrome.browser.tasks.EngagementTimeUtil;', 'import org.chromium.chrome.browser.tasks.JourneyManager;', 'import org.chromium.chrome.browser.tasks.ReturnToChromeExperimentsUtil;', 'import org.chromium.chrome.browser.tasks.TasksUma;', 'import org.chromium.chrome.browser.tasks.tab_management.TabGroupUi;', 'import org.chromium.chrome.browser.tasks.tab_management.TabManagementDelegate;', 'import org.chromium.chrome.browser.tasks.tab_management.TabManagementModuleProvider;', 'import org.chromium.chrome.browser.tasks.tab_management.TabUiFeatureUtilities;', 'import org.chromium.chrome.browser.toolbar.ToolbarButtonInProductHelpController;', 'import org.chromium.chrome.browser.toolbar.ToolbarIntentMetadata;', 'import org.chromium.chrome.browser.toolbar.ToolbarManager;', 'import org.chromium.chrome.browser.toolbar.top.ToolbarControlContainer;', 'import org.chromium.chrome.browser.translate.TranslateIntentHandler;', 'import org.chromium.chrome.browser.ui.AppLaunchDrawBlocker;', 'import org.chromium.chrome.browser.ui.RootUiCoordinator;', 'import org.chromium.chrome.browser.ui.TabObscuringHandler;', 'import org.chromium.chrome.browser.ui.appmenu.AppMenuPropertiesDelegate;', 'import org.chromium.chrome.browser.undo_tab_close_snackbar.UndoBarController;', 'import org.chromium.chrome.browser.usage_stats.UsageStatsService;', 'import org.chromium.chrome.browser.util.ChromeAccessibilityUtil;', 'import org.chromium.chrome.browser.vr.VrModuleProvider;', 'import org.chromium.chrome.features.start_surface.StartSurface;', 'import org.chromium.chrome.features.start_surface.StartSurfaceConfiguration;', 'import org.chromium.chrome.features.start_surface.StartSurfaceState;', 'import org.chromium.chrome.features.start_surface.StartSurfaceUserData;', 'import org.chromium.components.browser_ui.settings.SettingsLauncher;', 'import org.chromium.components.browser_ui.util.BrowserControlsVisibilityDelegate;', 'import org.chromium.components.browser_ui.util.ComposedBrowserControlsVisibilityDelegate;', 'import org.chromium.components.embedder_support.util.UrlConstants;', 'import org.chromium.components.embedder_support.util.UrlUtilities;', 'import org.chromium.components.feature_engagement.EventConstants;', 'import org.chromium.components.messages.MessageDispatcherProvider;', 'import org.chromium.components.profile_metrics.BrowserProfileType;', 'import org.chromium.components.webapps.ShortcutSource;', 'import org.chromium.content_public.browser.LoadUrlParams;', 'import org.chromium.content_public.browser.NavigationHandle;', 'import org.chromium.content_public.browser.RenderFrameHost;', 'import org.chromium.content_public.browser.UiThreadTaskTraits;', 'import org.chromium.content_public.browser.WebContents;', 'import org.chromium.content_public.browser.WebContentsAccessibility;', 'import org.chromium.content_public.common.ContentSwitches;', 'import org.chromium.ui.base.PageTransition;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', 'import org.chromium.ui.widget.Toast;', '', 'import java.lang.annotation.Retention;', 'import java.lang.annotation.RetentionPolicy;', 'import java.util.HashSet;', 'import java.util.List;', 'import java.util.Locale;', '', '/**', ' * This is the main activity for ChromeMobile when not running in document mode.  All the tabs', ' * are accessible via a chrome specific tab switching UI.', ' */', 'public class ChromeTabbedActivity extends ChromeActivity<ChromeActivityComponent>', '        implements ChromeAccessibilityUtil.Observer {', '    private static final String TAG = ""ChromeTabbedActivity"";', '', '    private static final String HELP_URL_PREFIX = ""https://support.google.com/chrome/"";', '', '    protected static final String WINDOW_INDEX = ""window_index"";', '', '    private static final String IS_INCOGNITO_SELECTED = ""is_incognito_selected"";', '', '    private static final int INVALID_WINDOW_ID = TabWindowManager.INVALID_WINDOW_INDEX;', '', '    // How long to delay closing the current tab when our app is minimized.  Have to delay this', ""    // so that we don't show the contents of the next tab while minimizing."", '    private static final long CLOSE_TAB_ON_MINIMIZE_DELAY_MS = 500;', '', '    // Maximum delay for initial tab creation. This is for homepage and NTP, not previous tabs', '    // restore. This is needed because we do not know when reading PartnerBrowserCustomizations', '    // provider will be finished.', '    private static final int INITIAL_TAB_CREATION_TIMEOUT_MS = 500;', '', '    /**', '     * Sending an intent with this action to Chrome will cause it to close all tabs', '     * (iff the --enable-test-intents command line flag is set). If a URL is supplied in the', '     * intent data, this will be loaded and unaffected by the close all action.', '     */', '    private static final String ACTION_CLOSE_TABS =', '            ""com.google.android.apps.chrome.ACTION_CLOSE_TABS"";', '', '    @VisibleForTesting', '    public static final String STARTUP_UMA_HISTOGRAM_SUFFIX = "".Tabbed"";', '', '    // Name of the ChromeTabbedActivity alias that handles MAIN intents.', '    public static final String MAIN_LAUNCHER_ACTIVITY_NAME = ""com.google.android.apps.chrome.Main"";', '', '    public static final SettingsLauncher SETTINGS_LAUNCHER = new SettingsLauncherImpl();', '', '    public static final HashSet<String> TABBED_MODE_COMPONENT_NAMES = new HashSet<String>() {', '        {', '            add(ChromeTabbedActivity.class.getName());', '            add(MultiInstanceChromeTabbedActivity.class.getName());', '            add(ChromeTabbedActivity2.class.getName());', '            add(MAIN_LAUNCHER_ACTIVITY_NAME);', '        }', '    };', '', '    /**', '     * Identifies a histogram to use in {@link #maybeDispatchExplicitMainViewIntent(Intent, int)}.', '     */', '    @IntDef({DispatchedBy.ON_CREATE, DispatchedBy.ON_NEW_INTENT})', '    @Retention(RetentionPolicy.SOURCE)', '    private @interface DispatchedBy {', '        int ON_CREATE = 1;', '        int ON_NEW_INTENT = 2;', '    }', '', '    // Count histogram used to track number of tabs when we show the Overview on Return to Chrome.', '    private static final String TAB_COUNT_ON_RETURN = ""Tabs.TabCountOnStartScreenShown"";', '', '    private final MainIntentBehaviorMetrics mMainIntentMetrics;', '    private @Nullable MultiInstanceManager mMultiInstanceManager;', '', '    private UndoBarController mUndoBarPopupController;', '', '    private LayoutManagerChrome mLayoutManager;', '', '    private ViewGroup mContentContainer;', '', '    private ToolbarControlContainer mControlContainer;', '', '    private TabbedModeTabModelOrchestrator mTabModelOrchestrator;', '    private TabModelSelectorBase mTabModelSelector;', '    private TabModelSelectorTabObserver mTabModelSelectorTabObserver;', '    private TabModelSelectorTabModelObserver mTabModelObserver;', '', '    private BrowserControlsVisibilityDelegate mVrBrowserControlsVisibilityDelegate;', '    private TabModalLifetimeHandler mTabModalHandler;', '', '    private boolean mUIWithNativeInitialized;', '', '    private Boolean mIsAccessibilityTabSwitcherEnabled;', '', '    private LocaleManager mLocaleManager;', '', '    private AppIndexingUtil mAppIndexingUtil;', '', '    private Runnable mShowHistoryRunnable;', '', '    private CompositorViewHolder mCompositorViewHolder;', '    private OverviewListLayout mOverviewListLayout;', '    /**', '     * Keeps track of whether or not a specific tab was created based on the startup intent.', '     */', '    private boolean mCreatedTabOnStartup;', '', '    // Whether or not the initial tab is being created.', '    private boolean mPendingInitialTabCreation;', '', '    // Whether {@link setInitialOverviewState()} has been called within the current onStart/onStop', '    // session.', '    private boolean mHasDeterminedOverviewStateForCurrentSession;', '    /**', '     *  Keeps track of the pref for the last time since this activity was stopped.', '     */', '    private ChromeInactivityTracker mInactivityTracker;', '', ""    // This is the cached value of mIntentHandler#shouldIgnoreIntent and shouldn't be read directly."", '    // Use #shouldIgnoreIntent instead.', '    private Boolean mShouldIgnoreIntent;', '    /*', '     *  Listens to FrameMetrics and records jank metrics.', '     */', '    private JankTrackerImpl mJankTracker;', '', '    // Supplier for a dependency to inform about the type of intent used to launch Chrome.', '    private OneshotSupplierImpl<ToolbarIntentMetadata> mIntentMetadataOneshotSupplier =', '            new OneshotSupplierImpl<>();', '', '    // Time at which an intent was received and handled.', '    private long mIntentHandlingTimeMs;', '', '    /**', '     * Whether the StartSurface is shown when Chrome is launched.', '     */', '    private boolean mOverviewShownOnStart;', '', '    private NextTabPolicySupplier mNextTabPolicySupplier;', '', '    private final UnownedUserDataSupplier<StartupPaintPreviewHelper>', '            mStartupPaintPreviewHelperSupplier = new StartupPaintPreviewHelperSupplier();', '', '    private final OneshotSupplierImpl<LayoutStateProvider> mLayoutStateProviderOneshotSupplier =', '            new OneshotSupplierImpl<>();', '    // TODO(crbug.com/1108496): Removed after all usages has been migrated to LayoutStateProvider.', '    private final OneshotSupplierImpl<OverviewModeBehavior> mOverviewModeBehaviorSupplier =', '            new OneshotSupplierImpl<>();', '    private OverviewModeController mOverviewModeController;', '', '    private ObservableSupplierImpl<EphemeralTabCoordinator> mEphemeralTabCoordinatorSupplier =', '            new ObservableSupplierImpl<>();', '    private final OneshotSupplierImpl<StartSurface> mStartSurfaceSupplier =', '            new OneshotSupplierImpl<>();', '    private ObservableSupplierImpl<Tab> mStartSurfaceParentTabSupplier =', '            new ObservableSupplierImpl<>();', '', '    private CallbackController mCallbackController = new CallbackController();', '    private TabbedModeTabDelegateFactory mTabDelegateFactory;', '', '    private final AppLaunchDrawBlocker mAppLaunchDrawBlocker;', '', '    // ID assigned to each ChromeTabbedActivity instance in Android S+ where multi-instance feature', '    // is supported. This can be explicitly set in the incoming Intent or internally assigned.', '    private int mWindowId;', '', '    private final IncognitoTabHost mIncognitoTabHost = new IncognitoTabHost() {', '        @Override', '        public boolean hasIncognitoTabs() {', '            return getTabModelSelector().getModel(true).getCount() > 0;', '        }', '', '        @Override', '        public void closeAllIncognitoTabs() {', '            if (isActivityFinishingOrDestroyed()) return;', '', '            // If the tabbed activity has not yet initialized, then finish the activity to avoid', '            // timing issues with clearing the incognito tab state in the background.', '            if (!areTabModelsInitialized() || !didFinishNativeInitialization()) {', '                finish();', '                return;', '            }', '', '            getTabModelSelector().getModel(true).closeAllTabs(false, false);', '        }', '', '        @Override', '        public boolean isActiveModel() {', '            return getTabModelSelector().getModel(true).isActiveModel();', '        }', '    };', '', '    /**', '     * This class is used to warm up the chrome split ClassLoader. See SplitChromeApplication for', '     * more info', '     */', '    @UsedByReflection(""SplitChromeApplication.java"")', '    public static class Preload extends ChromeTabbedActivity {', '        private LifecycleRegistry mLifecycleRegistry;', '', '        @UsedByReflection(""SplitChromeApplication.java"")', '        public Preload() {}', '', '        @Override', '        public Lifecycle getLifecycle() {', '            if (mLifecycleRegistry == null) {', '                // LifecycleRegistry normally enforces it is called on the main thread, but this', '                // class will be preloaded in a background thread. The only method that gets called', '                // in the activity constructor is addObserver(), so just override that.', '                mLifecycleRegistry = new LifecycleRegistry(null) {', '                    @Override', '                    public void addObserver(LifecycleObserver observer) {}', '                };', '            }', '            return mLifecycleRegistry;', '        }', '    }', '', '    /**', '     * Specify the proper non-.Main-aliased Chrome Activity for the given component.', '     *', '     * @param intent The intent to set the component for.', '     * @param component The client generated component to be validated.', '     */', '    public static void setNonAliasedComponent(Intent intent, ComponentName component) {', '        assert component != null;', '        Context appContext = ContextUtils.getApplicationContext();', '        if (!TextUtils.equals(component.getPackageName(), appContext.getPackageName())) {', '            return;', '        }', '        if (component.getClassName() != null', '                && TextUtils.equals(component.getClassName(),', '                        ChromeTabbedActivity.MAIN_LAUNCHER_ACTIVITY_NAME)) {', '            // Keep in sync with the activities that the .Main alias points to in', '            // AndroidManifest.xml.', '            intent.setClass(appContext, ChromeTabbedActivity.class);', '        } else {', '            intent.setComponent(component);', '        }', '    }', '', '    /**', '     * Constructs a ChromeTabbedActivity.', '     */', '    public ChromeTabbedActivity() {', '        mMainIntentMetrics = new MainIntentBehaviorMetrics();', '', '        // AppLaunchDrawBlocker may block drawing the Activity content until the initial tab is', '        // available.', '        // clang-format off', '        mAppLaunchDrawBlocker = new AppLaunchDrawBlocker(getLifecycleDispatcher(),', '                () -> findViewById(android.R.id.content),', '                this::getIntent, this::shouldIgnoreIntent, this::isTablet,', '                this::shouldShowOverviewPageOnStart);', '        // clang-format on', '    }', '', '    @Override', '    protected void onPreCreate() {', '        super.onPreCreate();', '        mMultiInstanceManager = MultiInstanceManager.create(this, getTabModelOrchestratorSupplier(),', '                getMultiWindowModeStateDispatcher(), getLifecycleDispatcher(),', '                getModalDialogManagerSupplier(), this);', '    }', '', '    @Override', '    protected @LaunchIntentDispatcher.Action int maybeDispatchLaunchIntent(', '            Intent intent, Bundle savedInstanceState) {', '        // Detect if incoming intent is a result of Chrome recreating itself. For now, restrict this', ""        // path to reparenting to ensure the launching logic isn't disrupted."", ""        // TODO(crbug.com/1065491): Unlock this codepath for all incoming intents once it's"", '        // confirmed working and stable.', '        if (savedInstanceState != null', '                && AsyncTabParamsManagerSingleton.getInstance().hasParamsWithTabToReparent()) {', '            return LaunchIntentDispatcher.Action.CONTINUE;', '        }', '', '        if (getClass().equals(ChromeTabbedActivity.class)', '                && Intent.ACTION_MAIN.equals(intent.getAction())) {', '            // Call dispatchToTabbedActivity() for MAIN intents to activate proper multi-window', '            // TabbedActivity (i.e. if CTA2 is currently running and Chrome is started, CTA2', ""            // should be brought to front). Don't call dispatchToTabbedActivity() for non-MAIN"", '            // intents to avoid breaking cases where CTA is started explicitly (e.g. to handle', ""            // 'Move to other window' command from CTA2)."", '            return LaunchIntentDispatcher.dispatchToTabbedActivity(this, intent);', '        }', '        @LaunchIntentDispatcher.Action', '        int action = maybeDispatchExplicitMainViewIntent(intent, DispatchedBy.ON_CREATE);', '        if (action != LaunchIntentDispatcher.Action.CONTINUE) {', '            return action;', '        }', '        return super.maybeDispatchLaunchIntent(intent, savedInstanceState);', '    }', '', '    // We know of at least one app that explicitly specifies .Main activity in custom tab', ""    // intents. The app shouldn't be doing that, but until it's updated, we need to support"", '    // such use case.', '    //', '    // This method attempts to treat VIEW intents explicitly sent to .Main as custom tab', '    // intents, and dispatch them accordingly. If the intent was not dispatched, the method', '    // returns Action.CONTINUE.', '    //', '    // The method also updates the supplied boolean histogram with the dispatching result,', '    // but only if the intent is a VIEW intent sent explicitly to .Main activity.', '    private @LaunchIntentDispatcher.Action int maybeDispatchExplicitMainViewIntent(', '            Intent intent, @DispatchedBy int dispatchedBy) {', ""        // The first check ensures that this is .Main activity alias (we can't check exactly, but"", '        // this gets us sufficiently close).', '        if (getClass().equals(ChromeTabbedActivity.class)', '                && Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getComponent() != null', '                && MAIN_LAUNCHER_ACTIVITY_NAME.equals(intent.getComponent().getClassName())) {', '            @LaunchIntentDispatcher.Action', '            int action = LaunchIntentDispatcher.dispatchToCustomTabActivity(this, intent);', '            switch (dispatchedBy) {', '                case DispatchedBy.ON_CREATE:', '                    RecordHistogram.recordBooleanHistogram(', '                            ""Android.MainActivity.ExplicitMainViewIntentDispatched.OnCreate"",', '                            action != LaunchIntentDispatcher.Action.CONTINUE);', '                    break;', '                case DispatchedBy.ON_NEW_INTENT:', '', '                    RecordHistogram.recordBooleanHistogram(', '                            ""Android.MainActivity.ExplicitMainViewIntentDispatched.OnNewIntent"",', '                            action != LaunchIntentDispatcher.Action.CONTINUE);', '                    break;', '                default:', '                    assert false : ""Unknown dispatchedBy value "" + dispatchedBy;', '            }', '            if (action == LaunchIntentDispatcher.Action.CONTINUE) {', '                // Intent was not dispatched, record its source.', '                @IntentHandler.ExternalAppId', '                int externalId = IntentHandler.determineExternalIntentSource(intent);', '                RecordHistogram.recordEnumeratedHistogram(', '                        ""Android.MainActivity.UndispatchedExplicitMainViewIntentSource"", externalId,', '                        IntentHandler.ExternalAppId.NUM_ENTRIES);', '', ""                // Crash if intent came from us, but only in debug builds and only if we weren't"", ""                // explicitly told not to. Hopefully we'll get enough reports to find where"", '                // these intents come from.', '                if (externalId == IntentHandler.ExternalAppId.CHROME', '                        && 0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE)', '                        && !CommandLine.getInstance().hasSwitch(', '                                ChromeSwitches.DONT_CRASH_ON_VIEW_MAIN_INTENTS)) {', '                    String intentInfo = intent.toString();', '                    Bundle extras = intent.getExtras();', '                    if (extras != null) {', '                        intentInfo +=', '                                "", extras.keySet = ["" + TextUtils.join("", "", extras.keySet()) + ""]"";', '                    }', '                    String message = String.format((Locale) null,', '                            ""VIEW intent sent to .Main activity alias was not dispatched. PLEASE ""', '                                    + ""report the following info to crbug.com/789732: \\""%s\\"". Use ""', '                                    + ""--%s flag to disable this check."",', '                            intentInfo, ChromeSwitches.DONT_CRASH_ON_VIEW_MAIN_INTENTS);', '                    throw new IllegalStateException(message);', '                }', '            }', '            return action;', '        }', '        return LaunchIntentDispatcher.Action.CONTINUE;', '    }', '', '    @Override', '    public void initializeCompositor() {', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.initializeCompositor"");', '            super.initializeCompositor();', '', '            // LocaleManager can only function after the native library is loaded.', '            mLocaleManager = LocaleManager.getInstance();', '            mLocaleManager.setSettingsLauncher(SETTINGS_LAUNCHER);', '            mLocaleManager.showSearchEnginePromoIfNeeded(this, null);', '', '            mTabModelOrchestrator.onNativeLibraryReady(getTabContentManager());', '', '            mTabModelObserver = new TabModelSelectorTabModelObserver(mTabModelSelector) {', '                @Override', '                public void didCloseTab(int tabId, boolean incognito) {', '                    closeIfNoTabsAndHomepageEnabled(false);', '                }', '', '                @Override', '                public void tabPendingClosure(Tab tab) {', '                    closeIfNoTabsAndHomepageEnabled(true);', '                }', '', '                @Override', '                public void tabRemoved(Tab tab) {', '                    closeIfNoTabsAndHomepageEnabled(false);', '                }', '', '                private void closeIfNoTabsAndHomepageEnabled(boolean isPendingClosure) {', '                    if (getTabModelSelector().getTotalTabCount() == 0) {', '                        // If the last tab is closed, and homepage is enabled, then exit Chrome.', '                        if (HomepageManager.shouldCloseAppWithZeroTabs()) {', '                            finish();', '                        } else if (isPendingClosure) {', '                            NewTabPageUma.recordNTPImpression(', '                                    NewTabPageUma.NTP_IMPESSION_POTENTIAL_NOTAB);', '                        }', '                    }', '', '                    // TODO(960196) : remove this when the associated bug fix. This is a band-aid', '                    //  fix for TabGrid and closing tabs with TabGroupUi.', '                    //  If one of the following is true, then exit Chrome when TabGroupsAndroid is', '                    //  enabled, and tab switcher is not shown:', '                    //   1. If the very last tab is closed.', '                    //   2. If normal tab model is selected and no normal tabs.', '                    if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(ChromeTabbedActivity.this)', '                            && !mOverviewModeController.overviewVisible()) {', '                        if (getTabModelSelector().getTotalTabCount() == 0', '                                || (!getTabModelSelector().isIncognitoSelected()', '                                        && getTabModelSelector().getModel(false).getCount() == 0)) {', '                            finish();', '                        }', '                    }', '                }', '', '                @Override', '                public void didAddTab(', '                        Tab tab, @TabLaunchType int type, @TabCreationState int creationState) {', '                    if (type == TabLaunchType.FROM_LONGPRESS_BACKGROUND', '                            && !DeviceClassManager.enableAnimations()) {', '                        Toast.makeText(ChromeTabbedActivity.this, R.string.open_in_new_tab_toast,', '                                     Toast.LENGTH_SHORT)', '                                .show();', '                    }', '                }', '', '                @Override', '                public void multipleTabsPendingClosure(List<Tab> tabs, boolean isAllTabs) {', '                    if (!isAllTabs) return;', '                    NewTabPageUma.recordNTPImpression(NewTabPageUma.NTP_IMPESSION_POTENTIAL_NOTAB);', '                }', '            };', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.initializeCompositor"");', '        }', '    }', '', '    private void refreshSignIn() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.refreshSignIn"")) {', '            FirstRunSignInProcessor.start(this);', '        }', '    }', '', '    private void setupCompositorContentPreNativeForPhone() {', '        if (isTablet()) return;', '', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPreNativeForPhone"")) {', '            CompositorViewHolder compositorViewHolder = getCompositorViewHolderSupplier().get();', '', '            // TODO(1169205): Remove all GTS enabled checks after M5 is default.', '            if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(this)) {', '                TabManagementDelegate tabManagementDelegate =', '                        TabManagementModuleProvider.getDelegate();', '                if (tabManagementDelegate != null) {', '                    StartSurface startSurface = tabManagementDelegate.createStartSurface(this,', '                            mRootUiCoordinator.getScrimCoordinator(),', '                            mRootUiCoordinator.getBottomSheetController(), mStartSurfaceSupplier,', '                            mStartSurfaceParentTabSupplier, hadWarmStart(), getWindowAndroid(),', '                            compositorViewHolder, compositorViewHolder::getDynamicResourceLoader,', '                            getTabModelSelector(), getBrowserControlsManager(),', '                            getSnackbarManager(), getShareDelegateSupplier(),', '                            getToolbarManager()::getOmniboxStub, getTabContentManager(),', '                            getModalDialogManager(),', '                            /* chromeActivityNativeDelegate= */ this, getLifecycleDispatcher(),', '                            getTabCreatorManagerSupplier().get(),', '                            getMenuOrKeyboardActionController(),', '                            getMultiWindowModeStateDispatcher(), mJankTracker,', '                            getToolbarManager()::getToolbar);', '                }', '            }', '', '            // clang-format off', '            mLayoutManager = new LayoutManagerChromePhone(compositorViewHolder, mContentContainer,', '                    mStartSurfaceSupplier.get(), getTabContentManagerSupplier(),', '                    () -> {', '                        if (!getCompositorViewHolderSupplier().hasValue()) return null;', '                        return getCompositorViewHolderSupplier().get().getLayerTitleCache();', '                    },', '                    mOverviewModeBehaviorSupplier,', '                    mRootUiCoordinator::getTopUiThemeColorProvider, mJankTracker);', '            mLayoutStateProviderOneshotSupplier.set(mLayoutManager);', '            // clang-format on', '            mOverviewModeController = mLayoutManager;', '        }', '    }', '', '    private void setupCompositorContentPreNativeForTablet() {', '        if (!isTablet()) return;', '', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPreNativeForTablet"")) {', '            // clang-format off', '            mLayoutManager = new LayoutManagerChromeTablet(getCompositorViewHolderSupplier().get(),', '                    mContentContainer, getTabContentManagerSupplier(),', '                    () -> {', '                        if (!getCompositorViewHolderSupplier().hasValue()) return null;', '                        return getCompositorViewHolderSupplier().get().getLayerTitleCache();', '                    },', '                    mOverviewModeBehaviorSupplier,', '                    mRootUiCoordinator::getTopUiThemeColorProvider, mJankTracker);', '            mLayoutStateProviderOneshotSupplier.set(mLayoutManager);', '            // clang-format on', '            mOverviewModeController = mLayoutManager;', '        }', '    }', '', '    private void setupCompositorContentPostNative() {', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPostNative"")) {', '            if (!isLayoutManagerCreated()) {', '                if (isTablet()) {', '                    setupCompositorContentPreNativeForTablet();', '                } else {', '                    setupCompositorContentPreNativeForPhone();', '                }', '            }', '', '            mLayoutManager.setEnableAnimations(DeviceClassManager.enableAnimations());', '', '            // TODO(yusufo): get rid of findViewById(R.id.url_bar).', '            initializeCompositorContent(mLayoutManager, findViewById(R.id.url_bar),', '                    mContentContainer, mControlContainer);', '        }', '    }', '', '    private boolean isLayoutManagerCreated() {', '        return mLayoutManager != null;', '    }', '', '    private void initializeToolbarManager() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.initializeToolbarManager"")) {', '            mUndoBarPopupController.initialize();', '', '            OnClickListener tabSwitcherClickHandler = v -> {', '                if (ChromeFeatureList.isEnabled(ChromeFeatureList.TOOLBAR_IPH_ANDROID)) {', '                    Profile profile = mTabModelProfileSupplier.get();', '                    if (profile != null) {', '                        TrackerFactory.getTrackerForProfile(profile).notifyEvent(', '                                EventConstants.TAB_SWITCHER_BUTTON_CLICKED);', '                    }', '                }', '', '                if (getFullscreenManager().getPersistentFullscreenMode()) {', '                    return;', '                }', '', '                if (isInOverviewMode()', '                        && !ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '                    hideOverview();', '                } else {', '                    showOverview(StartSurfaceState.SHOWING_TABSWITCHER);', '                }', '            };', '            OnClickListener newTabClickHandler = v -> {', '                getTabModelSelector().getModel(false).commitAllTabClosures();', '                // This assumes that the keyboard can not be seen at the same time as the', '                // newtab button on the toolbar.', '                getCurrentTabCreator().launchNTP();', '                mLocaleManager.showSearchEnginePromoIfNeeded(ChromeTabbedActivity.this, null);', '                if (getTabModelSelector().isIncognitoSelected()) {', '                    RecordUserAction.record(""MobileToolbarStackViewNewIncognitoTab"");', '                } else {', '                    RecordUserAction.record(""MobileToolbarStackViewNewTab"");', '                }', '                RecordUserAction.record(""MobileTopToolbarNewTabButton"");', '', '                RecordUserAction.record(""MobileNewTabOpened"");', '                ReturnToChromeExperimentsUtil.onNewTabOpened();', '            };', '            OnClickListener bookmarkClickHandler = v -> addOrEditBookmark(getActivityTab());', '', '            Supplier<Boolean> showStartSurfaceSupplier = () -> {', '                // If incognito is selected, tapping the home button stays on the current incognito', '                // tab.', '                if (ReturnToChromeExperimentsUtil.shouldShowStartSurfaceAsTheHomePageOnPhone(', '                            this, isTablet())', '                        && !mTabModelSelector.isIncognitoSelected()) {', '                    StartSurfaceUserData.setKeepTab(getActivityTab(), true);', '                    showOverview(StartSurfaceState.SHOWING_HOMEPAGE);', '                    return true;', '                }', '                return false;', '            };', '', '            getToolbarManager().initializeWithNative(mLayoutManager, tabSwitcherClickHandler,', '                    newTabClickHandler, bookmarkClickHandler, null, showStartSurfaceSupplier);', '', '            if (!TabUiFeatureUtilities.supportInstantStart(isTablet(), this)) {', '                assert !(mOverviewModeController != null', '                        && mOverviewModeController.overviewVisible());', '            }', '        }', '    }', '', '    private void maybeCreateIncognitoTabSnapshotController() {', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.maybeCreateIncognitoTabSnapshotController"")) {', '            if (!CommandLine.getInstance().hasSwitch(', '                        ChromeSwitches.ENABLE_INCOGNITO_SNAPSHOTS_IN_ANDROID_RECENTS)) {', '                IncognitoTabSnapshotController.createIncognitoTabSnapshotController(', '                        this, getWindow(), mLayoutManager, mTabModelSelector);', '            }', '', '            mUIWithNativeInitialized = true;', '            onAccessibilityTabSwitcherModeChanged();', '', '            // The dataset has already been created, we need to initialize our state.', '            mTabModelSelector.notifyChanged();', '', '            // Check for incognito tabs to handle the case where Chrome was swiped away in the', '            // background.', '            if (!IncognitoTabHostUtils.doIncognitoTabsExist()) {', '                IncognitoNotificationManager.dismissIncognitoNotification();', '                DownloadNotificationService.getInstance().cancelOffTheRecordDownloads();', '            }', '        }', '    }', '', '    private void maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.""', '                     + ""maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver"")) {', '            FeedSurfaceTracker.getInstance().startup();', '', '            if (UsageStatsService.isEnabled()) {', '                UsageStatsService.getInstance().createPageViewObserver(', '                        this, getActivityTabProvider(), getTabContentManagerSupplier());', '            }', '        }', '    }', '', '    private void initJourneyManager() {', '        assert mOverviewModeController != null;', '', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.initJourneyManager"")) {', '            if (ChromeFeatureList.isEnabled(ChromeFeatureList.TAB_ENGAGEMENT_REPORTING_ANDROID)) {', '                // The lifecycle of this object is managed by the lifecycle dispatcher.', '                new JourneyManager(getTabModelSelector(), getLifecycleDispatcher(),', '                        mOverviewModeController, new EngagementTimeUtil());', '            }', '        }', '    }', '', '    @Override', '    public void onNewIntent(Intent intent) {', ""        // The intent to use in maybeDispatchExplicitMainViewIntent(). We're explicitly"", '        // adding NEW_TASK flag to make sure backing from CCT brings up the caller activity,', '        // and not Chrome', '        Intent intentForDispatching = new Intent(intent);', '        intentForDispatching.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);', '        @LaunchIntentDispatcher.Action', '        int action = maybeDispatchExplicitMainViewIntent(', '                intentForDispatching, DispatchedBy.ON_NEW_INTENT);', '        if (action != LaunchIntentDispatcher.Action.CONTINUE) {', '            // Pressing back button in CCT should bring user to the caller activity.', '            moveTaskToBack(true);', '            // Intent was dispatched to CustomTabActivity, consume it.', '            return;', '        }', '', '        mIntentHandlingTimeMs = SystemClock.uptimeMillis();', '        super.onNewIntent(intent);', '    }', '', '    @Override', '    public void startNativeInitialization() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.startNativeInitialization"")) {', ""            // This is on the critical path so don't delay."", '            if (ChromeFeatureList.isEnabled(', '                        ChromeFeatureList.DARKEN_WEBSITES_CHECKBOX_IN_THEMES_SETTING)) {', '                WebContentsDarkModeController.createInstance();', '            }', '            setupCompositorContentPostNative();', '', ""            // All this initialization can be expensive so it's split into multiple tasks."", '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::refreshSignIn));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::initializeToolbarManager));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::maybeCreateIncognitoTabSnapshotController));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::onAccessibilityTabSwitcherModeChanged));', '', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::initJourneyManager));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::finishNativeInitialization));', '            ChromeAccessibilityUtil.get().addObserver(this);', '        }', '    }', '', '    @Override', '    public void finishNativeInitialization() {', '        super.finishNativeInitialization();', '', '        // TODO(jinsukkim): Let these classes handle the registration by themselves.', '        mCompositorViewHolder = getCompositorViewHolderSupplier().get();', '        mOverviewListLayout = (OverviewListLayout) mLayoutManager.getOverviewListLayout();', '        getTabObscuringHandler().addObserver(mCompositorViewHolder);', '        getTabObscuringHandler().addObserver(mOverviewListLayout);', '', '        ChromeAccessibilityUtil.get().addObserver(mLayoutManager);', '        if (isTablet()) ChromeAccessibilityUtil.get().addObserver(mCompositorViewHolder);', '    }', '', '    @Override', '    public void onResumeWithNative() {', '        super.onResumeWithNative();', '', '        IncognitoStartup.onResumeWithNative(', '                getTabModelSelectorSupplier(), TABBED_MODE_COMPONENT_NAMES);', '', '        mLocaleManager.setSnackbarManager(getSnackbarManager());', '        mLocaleManager.startObservingPhoneChanges();', '', '        if (isWarmOnResume()) {', '            NavigationPredictorBridge.onActivityWarmResumed();', '        } else {', '            NavigationPredictorBridge.onColdStart();', '        }', '', '        // This call is not guarded by a feature flag.', '        SearchEngineChoiceNotification.handleSearchEngineChoice(', '                this, getSnackbarManager(), SETTINGS_LAUNCHER);', '', '        if (!isWarmOnResume()) {', '            SuggestionsMetrics.recordArticlesListVisible();', '        }', '    }', '', '    @Override', '    public void onPauseWithNative() {', '        mTabModelSelector.commitAllTabClosures();', '        CookiesFetcher.persistCookies();', '', '        mLocaleManager.setSnackbarManager(null);', '        mLocaleManager.stopObservingPhoneChanges();', '', '        NavigationPredictorBridge.onPause();', '', '        super.onPauseWithNative();', '    }', '', '    @Override', '    public void onStopWithNative() {', '        super.onStopWithNative();', '', '        mTabModelOrchestrator.saveState();', '        mHasDeterminedOverviewStateForCurrentSession = false;', '    }', '', '    @Override', '    public void onStartWithNative() {', '        mMainIntentMetrics.logLaunchBehavior();', '        super.onStartWithNative();', '', ""        // Don't call setInitialOverviewState if we're waiting for the tab's creation or we risk"", '        // showing a glimpse of the tab selector during start up.', '        if (!mPendingInitialTabCreation) {', '            setInitialOverviewState();', '        }', '', '        if (TabUiFeatureUtilities.isConditionalTabStripEnabled()', '                || ConditionalTabStripUtils.getOptOutIndicator()) {', '            ConditionalTabStripUtils.updateFeatureExpiration(', '                    mInactivityTracker.getLastBackgroundedTimeMs());', '        }', '', '        Bundle savedInstanceState = getSavedInstanceState();', '        if (savedInstanceState != null', '                && savedInstanceState.getBoolean(IS_INCOGNITO_SELECTED, false)) {', '            // This will be executed only once since SavedInstanceState will be reset a few lines', '            // later.', '            AndroidSessionDurationsServiceState.restoreNativeFromSerialized(savedInstanceState,', '                    getCurrentTabModel().getProfile().getPrimaryOTRProfile(', '                            /* createIfNeeded= */ true));', '        }', '', '        resetSavedInstanceState();', '        StartSurfaceConfiguration.addFeedVisibilityObserver();', '        BookmarkUtils.maybeExpireLastBookmarkLocationForReadLater(', '                mInactivityTracker.getTimeSinceLastBackgroundedMs());', '    }', '', '    @Override', '    public void onNewIntentWithNative(Intent intent) {', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.onNewIntentWithNative"");', '', '            super.onNewIntentWithNative(intent);', '            if (IntentUtils.isMainIntentFromLauncher(intent)) {', '                logMainIntentBehavior(intent);', '            }', '', '            if (CommandLine.getInstance().hasSwitch(ContentSwitches.ENABLE_TEST_INTENTS)) {', '                handleDebugIntent(intent);', '            }', '', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.onNewIntentWithNative"");', '        }', '    }', '', '    @Override', '    public @ActivityType int getActivityType() {', '        return ActivityType.TABBED;', '    }', '', '    @Override', '    public ChromeTabCreator getTabCreator(boolean incognito) {', '        return (ChromeTabCreator) super.getTabCreator(incognito);', '    }', '', '    @Override', '    public ChromeTabCreator getCurrentTabCreator() {', '        return (ChromeTabCreator) super.getCurrentTabCreator();', '    }', '', '    @Override', '    public OverviewModeBehavior getOverviewModeBehavior() {', '        return mOverviewModeController;', '    }', '', '    @Override', '    public @Nullable OneshotSupplier<OverviewModeBehavior> getOverviewModeBehaviorSupplier() {', '        return mOverviewModeBehaviorSupplier;', '    }', '', '    /**', '     * @return The toolbar button in-product help controller for this activity.', '     * TODO(pnoland, https://crbug.com/865801): remove this in favor', ""     *        of injecting the controller directly where it's needed."", '     */', '    public ToolbarButtonInProductHelpController getToolbarButtonInProductHelpController() {', '        return ((TabbedRootUiCoordinator) mRootUiCoordinator)', '                .getToolbarButtonInProductHelpController();', '    }', '', '    private void handleDebugIntent(Intent intent) {', '        if (ACTION_CLOSE_TABS.equals(intent.getAction())) {', '            getTabModelSelector().closeAllTabs();', '        } else if (MemoryPressureListener.handleDebugIntent(', '                           ChromeTabbedActivity.this, intent.getAction())) {', '            // Handled.', '        }', '    }', '', '    private void setTrackColdStartupMetrics(boolean shouldTrackColdStartupMetrics) {', '        assert getActivityTabStartupMetricsTracker() != null;', '', '        if (shouldTrackColdStartupMetrics) {', '            getActivityTabStartupMetricsTracker().trackStartupMetrics(STARTUP_UMA_HISTOGRAM_SUFFIX);', '        } else {', '            getActivityTabStartupMetricsTracker().cancelTrackingStartupMetrics();', '        }', '', '        // Paint Preview should follow the same logic as startup UMA histograms as the feature', '        // should only run on cold startup of Chrome when the user is unable to interact before', '        // entering a tab.', '        StartupPaintPreviewHelper.setShouldShowOnRestore(shouldTrackColdStartupMetrics);', '    }', '', '    private void setInitialOverviewState() {', '        if (mHasDeterminedOverviewStateForCurrentSession) return;', '', '        mHasDeterminedOverviewStateForCurrentSession = true;', '        boolean isOverviewVisible = mOverviewModeController.overviewVisible();', '', '        if (shouldRefreshAndShowOverview(isOverviewVisible)) {', '            if (getCurrentTabModel() != null) {', '                RecordHistogram.recordCountHistogram(', '                        TAB_COUNT_ON_RETURN, getCurrentTabModel().getCount());', '            }', '            if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(this) && !isTablet()) {', '                mStartSurfaceSupplier.get().getController().enableRecordingFirstMeaningfulPaint(', '                        getOnCreateTimestampMs());', '            }', '            mOverviewShownOnStart = true;', '            // Cancel recording cold startup metrics if an overview is shown as they expect a tab to', '            // be the first thing shown after startup.', '            setTrackColdStartupMetrics(false);', '            showOverview(StartSurfaceState.SHOWING_START);', '            return;', '        }', '', '        if (getActivityTab() == null && !isOverviewVisible) {', '            mOverviewShownOnStart = true;', '            // Cancel recording cold startup metrics if an overview is shown as they expect a tab to', '            // be the first thing shown after startup.', '            setTrackColdStartupMetrics(false);', '            showOverview(StartSurfaceState.SHOWING_START);', '        }', '', '        if (IntentUtils.isMainIntentFromLauncher(getIntent())', '                && mOverviewModeController.overviewVisible()) {', '            RecordUserAction.record(""MobileStartup.UserEnteredTabSwitcher"");', '        }', '    }', '', '    private boolean shouldRefreshAndShowOverview(boolean isOverviewVisible) {', '        // If StartSurfaceConfiguration.NEW_SURFACE_FROM_HOME_BUTTON is turned on, MV tiles and', '        // carousels may be hidden before Chrome is brought to the background. If overview should be', '        // shown, no matter overview was already visible or not, we should call', '        // showOverview(StartSurfaceState.SHOWING_START) to show MV tiles and carousels again.', '        return shouldShowOverviewPageOnStart()', '                && (!isOverviewVisible', '                        || StartSurfaceConfiguration.shouldShowNewSurfaceFromHomeButton());', '    }', '', '    /**', '     * Returns whether grid Tab switcher or the Start surface should be shown at startup.', '     */', '    private boolean shouldShowOverviewPageOnStart() {', '        return ReturnToChromeExperimentsUtil.shouldShowOverviewPageOnStart(', '                this, getIntent(), getTabModelSelector(), mInactivityTracker);', '    }', '', '    private void logMainIntentBehavior(Intent intent) {', '        assert IntentUtils.isMainIntentFromLauncher(intent);', '        // TODO(tedchoc): We should cache the last visible time and reuse it to avoid different', '        //                values of this depending on when it is called after the activity was', '        //                shown.', '', '        // Temporary safety check to make sure none of this code runs if the feature is', '        // disabled.', '        if (ReengagementNotificationController.isEnabled()) {', '            if (mCallbackController != null) {', '                new OneShotCallback<>(', '                        mTabModelProfileSupplier, mCallbackController.makeCancelable(profile -> {', '                            assert profile != null : ""Unexpectedly null profile from TabModel."";', '                            if (profile == null) return;', '', '                            TrackerFactory.getTrackerForProfile(profile).notifyEvent(', '                                    EventConstants.STARTED_FROM_MAIN_INTENT);', '                        }));', '            }', '        }', '', '        mMainIntentMetrics.onMainIntentWithNative(', '                mInactivityTracker.getTimeSinceLastBackgroundedMs());', '    }', '', '    /** Access the main intent metrics for test validation. */', '    @VisibleForTesting', '    public MainIntentBehaviorMetrics getMainIntentBehaviorMetricsForTesting() {', '        return mMainIntentMetrics;', '    }', '', '    @VisibleForTesting', '    public ChromeInactivityTracker getInactivityTrackerForTesting() {', '        return mInactivityTracker;', '    }', '', '    @Override', '    public void initializeState() {', '        // This method goes through 3 steps:', ""        // 1. Load the saved tab state (but don't start restoring the tabs yet)."", '        // 2. Process the Intent that this activity received and if that should result in any', '        //    new tabs, create them.  This is done after step 1 so that the new tab gets', '        //    created after previous tab state was restored.', '        // 3. If no tabs were created in any of the above steps, create an NTP, otherwise', '        //    start asynchronous tab restore (loading the previously active tab synchronously', '        //    if no new tabs created in step 2).', '', '        // Only look at the original intent if this is not a ""restoration"" and we are allowed to', '        // process intents. Any subsequent intents are carried through onNewIntent.', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.initializeState"");', '', '            super.initializeState();', '            Log.i(TAG, ""#initializeState"");', '            Intent intent = getIntent();', '', '            boolean hadCipherData =', '                    CipherFactory.getInstance().restoreFromBundle(getSavedInstanceState());', '', '            boolean noRestoreState =', '                    CommandLine.getInstance().hasSwitch(ChromeSwitches.NO_RESTORE_STATE);', '            if (noRestoreState) {', '                // Clear the state files because they are inconsistent and useless from now on.', '                mTabModelOrchestrator.clearState();', '            } else {', '                // State should be clear when we start first run and hence we do not need to load', '                // a previous state. This may change the current Model, watch out for initialization', '                // based on the model.', '                // Never attempt to restore incognito tabs when this activity was previously swiped', '                // away in Recents. http://crbug.com/626629', '                boolean ignoreIncognitoFiles = !hadCipherData;', '                mTabModelOrchestrator.loadState(ignoreIncognitoFiles);', '            }', '', '            mInactivityTracker.register(this.getLifecycleDispatcher());', '            boolean isIntentWithEffect = false;', '            boolean isMainIntentFromLauncher = false;', '            if (getSavedInstanceState() == null && intent != null) {', '                if (!shouldIgnoreIntent()) {', '                    isIntentWithEffect = mIntentHandler.onNewIntent(intent);', '                }', '', '                if (IntentUtils.isMainIntentFromLauncher(intent)) {', '                    isMainIntentFromLauncher = true;', '                    logMainIntentBehavior(intent);', '                }', '            }', '', '            mIntentMetadataOneshotSupplier.set(', '                    new ToolbarIntentMetadata(isMainIntentFromLauncher, isIntentWithEffect));', '', '            // If we have tabs to reparent and getSavedInstanceState() is non-null, then the tabs', '            // are coming from night mode tab reparenting. In this case, reparenting happens', '            // synchronously along with tab restoration so there are no tabs waiting for', '            // reparenting like there are for other tab reparenting operations.', '            boolean hasTabWaitingForReparenting =', '                    AsyncTabParamsManagerSingleton.getInstance().hasParamsWithTabToReparent()', '                    && getSavedInstanceState() == null;', '            mCreatedTabOnStartup = getCurrentTabModel().getCount() > 0', '                    || mTabModelOrchestrator.getRestoredTabCount() > 0 || isIntentWithEffect', '                    || hasTabWaitingForReparenting;', '', '            // We always need to try to restore tabs. The set of tabs might be empty, but at least', '            // it will trigger the notification that tab restore is complete which is needed by', '            // other parts of Chrome such as sync.', '            boolean activeTabBeingRestored = !isIntentWithEffect', '                    || (shouldShowOverviewPageOnStart()', '                            && !mTabModelSelector.isIncognitoSelected());', '', '            mTabModelOrchestrator.restoreTabs(activeTabBeingRestored);', '', '            // Only create an initial tab if no tabs were restored and no intent was handled.', '            // Also, check whether the active tab was supposed to be restored and that the total', '            // tab count is now non zero.  If this is not the case, tab restore failed and we need', '            // to create a new tab as well.', '            if (!mCreatedTabOnStartup', '                    || (!hasTabWaitingForReparenting && activeTabBeingRestored', '                            && getTabModelSelector().getTotalTabCount() == 0)) {', '                // If homepage URI is not determined, due to PartnerBrowserCustomizations provider', '                // async reading, then create a tab at the async reading finished. If it takes', '                // too long, just create NTP.', '', '                mPendingInitialTabCreation = true;', '                PartnerBrowserCustomizations.getInstance().setOnInitializeAsyncFinished(() -> {', '                    if (!isActivityFinishingOrDestroyed()) {', '                        createInitialTab();', '                    }', '                }, INITIAL_TAB_CREATION_TIMEOUT_MS);', '            }', '', '            // If initial tab creation is pending, this will instead be handled when we create the', '            // initial tab in #createInitialTab.', '            if (!mPendingInitialTabCreation) {', '                mAppLaunchDrawBlocker.onActiveTabAvailable(isTabRegularNtp(getActivityTab()));', '            }', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.initializeState"");', '        }', '    }', '', '    private boolean hasStartWithNativeBeenCalled() {', '        int activity_state = getLifecycleDispatcher().getCurrentActivityState();', '        return activity_state == ActivityLifecycleDispatcher.ActivityState.STARTED_WITH_NATIVE', '                || activity_state == ActivityLifecycleDispatcher.ActivityState.RESUMED_WITH_NATIVE;', '    }', '', '    /**', '     * Create an initial tab for cold start without restored tabs.', '     */', '    private void createInitialTab() {', '        Log.i(TAG, ""#createInitialTab executed."");', '        mPendingInitialTabCreation = false;', '', '        // If the start surface or grid tab switcher will be shown on start, do not create a new', '        // tab.', '        if (!shouldShowOverviewPageOnStart()) {', '            String url = HomepageManager.getHomepageUri();', '            if (TextUtils.isEmpty(url)) {', '                url = UrlConstants.NTP_URL;', '            } else {', '                // Migrate legacy NTP URLs (chrome://newtab) to the newer format', '                // (chrome-native://newtab)', '                if (UrlUtilities.isNTPUrl(url)) {', '                    url = UrlConstants.NTP_URL;', '                }', '            }', '', '            getTabCreator(false).launchUrl(url, TabLaunchType.FROM_STARTUP);', '        }', '', ""        // If we didn't call setInitialOverviewState() in onStartWithNative() because"", '        // mPendingInitialTabCreation was true then do so now.', '        if (hasStartWithNativeBeenCalled()) {', '            setInitialOverviewState();', '        }', '', '        mAppLaunchDrawBlocker.onActiveTabAvailable(isTabRegularNtp(getActivityTab()));', '    }', '', '    @Override', '    public void onAccessibilityModeChanged(boolean enabled) {', '        onAccessibilityTabSwitcherModeChanged();', '    }', '', '    private void onAccessibilityTabSwitcherModeChanged() {', '        if (!mUIWithNativeInitialized) return;', '', '        boolean accessibilityTabSwitcherEnabled =', '                DeviceClassManager.enableAccessibilityLayout(this);', '        if (mOverviewModeController != null && mOverviewModeController.overviewVisible()', '                && (mIsAccessibilityTabSwitcherEnabled == null', '                        || mIsAccessibilityTabSwitcherEnabled', '                                != DeviceClassManager.enableAccessibilityLayout(this))) {', '            /**', '             * If Start surface homepage is showing and launching NTP will show the Start surface', '             * again, skips the calls of hideOverview() and launchNTP(). We need to check', '             * {@link ReturnToChromeExperimentsUtil#shouldShowStartSurfaceHomeAsNTP(Context,', '             * boolean, boolean)} to see whether Start surface can be shown when accessibility is', '             * enabled.', '             */', '            if (mStartSurfaceSupplier.get() == null', '                    || mStartSurfaceSupplier.get().getController().getStartSurfaceState()', '                            != StartSurfaceState.SHOWN_HOMEPAGE', '                    || !ReturnToChromeExperimentsUtil.shouldShowStartSurfaceHomeAsNTP(', '                            this, getCurrentTabModel().isIncognito(), isTablet())) {', '                mOverviewModeController.hideOverview(true);', '                if (getTabModelSelector().getCurrentModel().getCount() == 0) {', '                    getCurrentTabCreator().launchNTP();', '                }', '            }', '        }', '        mIsAccessibilityTabSwitcherEnabled = accessibilityTabSwitcherEnabled;', '', '        if (ChromeAccessibilityUtil.get().isAccessibilityEnabled()) {', '            RecordHistogram.recordBooleanHistogram(', '                    ""Accessibility.Android.TabSwitcherPreferenceEnabled"",', '                    mIsAccessibilityTabSwitcherEnabled);', '        }', '    }', '', '    /**', '     * Internal class which performs the intent handling operations delegated by IntentHandler.', '     */', '    private class InternalIntentDelegate implements IntentHandler.IntentHandlerDelegate {', '        /**', '         * Processes a url view intent.', '         *', '         * @param url The url from the intent.', '         */', '        @Override', '        public void processUrlViewIntent(LoadUrlParams loadUrlParams, @TabOpenType int tabOpenType,', '                String externalAppId, int tabIdToBringToFront, Intent intent) {', '            if (isActivityFinishingOrDestroyed()) {', '                return;', '            }', '            if (isFromChrome(intent, externalAppId)) {', '                RecordUserAction.record(""MobileTabbedModeViewIntentFromChrome"");', '            } else {', '                RecordUserAction.record(""MobileTabbedModeViewIntentFromApp"");', '            }', '', '            final String url = loadUrlParams.getUrl();', '            boolean fromLauncherShortcut = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_INVOKED_FROM_SHORTCUT, false);', '            boolean fromAppWidget = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_INVOKED_FROM_APP_WIDGET, false);', '            boolean focus = false;', '', '            TabModel tabModel = getCurrentTabModel();', '            switch (tabOpenType) {', '                case TabOpenType.REUSE_URL_MATCHING_TAB_ELSE_NEW_TAB:', '                    mTabModelOrchestrator.tryToRestoreTabStateForUrl(url);', '                    int tabToBeClobberedIndex = TabModelUtils.getTabIndexByUrl(tabModel, url);', '                    Tab tabToBeClobbered = tabModel.getTabAt(tabToBeClobberedIndex);', '                    if (tabToBeClobbered != null) {', '                        TabModelUtils.setIndex(tabModel, tabToBeClobberedIndex);', '                        tabToBeClobbered.reload();', '                    } else {', '                        launchIntent(loadUrlParams, externalAppId, true, intent);', '                    }', '                    int shortcutSource = intent.getIntExtra(', '                            WebappConstants.EXTRA_SOURCE, ShortcutSource.UNKNOWN);', '                    LaunchMetrics.recordHomeScreenLaunchIntoTab(url, shortcutSource);', '                    if (fromAppWidget && url.startsWith(UrlConstants.CHROME_DINO_URL)) {', '                        RecordUserAction.record(""QuickActionSearchWidget.StartDinoGame"");', '                    }', '                    break;', '                case TabOpenType.BRING_TAB_TO_FRONT:', '                    mTabModelOrchestrator.tryToRestoreTabStateForId(tabIdToBringToFront);', '', '                    int tabIndex = TabModelUtils.getTabIndexById(tabModel, tabIdToBringToFront);', '                    if (tabIndex == TabModel.INVALID_TAB_INDEX) {', '                        TabModel otherModel =', '                                getTabModelSelector().getModel(!tabModel.isIncognito());', '                        tabIndex = TabModelUtils.getTabIndexById(otherModel, tabIdToBringToFront);', '                        if (tabIndex != TabModel.INVALID_TAB_INDEX) {', '                            getTabModelSelector().selectModel(otherModel.isIncognito());', '                            TabModelUtils.setIndex(otherModel, tabIndex);', '                        } else {', '                            Log.e(TAG, ""Failed to bring tab to front because it doesn\'t exist."");', '                            return;', '                        }', '                    } else {', '                        TabModelUtils.setIndex(tabModel, tabIndex);', '                    }', '                    break;', '                case TabOpenType.CLOBBER_CURRENT_TAB:', '                    // The browser triggered the intent. This happens when clicking links which', '                    // can be handled by other applications (e.g. www.youtube.com links).', '                    Tab currentTab = getActivityTab();', '                    if (currentTab != null) {', '                        RedirectHandlerTabHelper.updateIntentInTab(currentTab, intent);', '                        currentTab.loadUrl(loadUrlParams);', '                    } else {', '                        launchIntent(loadUrlParams, externalAppId, true, intent);', '                    }', '                    break;', '                case TabOpenType.REUSE_APP_ID_MATCHING_TAB_ELSE_NEW_TAB:', '                    launchIntent(loadUrlParams, externalAppId, false, intent);', '                    break;', '                case TabOpenType.REUSE_TAB_MATCHING_ID_ELSE_NEW_TAB:', '                    int tabId = IntentUtils.safeGetIntExtra(', '                            intent, TabOpenType.REUSE_TAB_MATCHING_ID_STRING, Tab.INVALID_TAB_ID);', '                    if (tabId != Tab.INVALID_TAB_ID) {', '                        mTabModelOrchestrator.tryToRestoreTabStateForId(tabId);', '                        int matchingTabIndex = TabModelUtils.getTabIndexById(tabModel, tabId);', '                        boolean loaded = false;', '                        if (matchingTabIndex != TabModel.INVALID_TAB_INDEX) {', '                            Tab tab = tabModel.getTabAt(matchingTabIndex);', '                            if (tab.getUrl().getSpec().equals(url)', '                                    || tab.getUrl().getSpec().equals(IntentUtils.safeGetStringExtra(', '                                            intent, TabOpenType.REUSE_TAB_ORIGINAL_URL_STRING))) {', '                                tabModel.setIndex(matchingTabIndex, TabSelectionType.FROM_USER);', '                                tab.loadUrl(loadUrlParams);', '                                loaded = true;', '                            }', '                        }', '                        if (!loaded) {', '                            launchIntent(loadUrlParams, externalAppId, false, intent);', '                        }', '                    }', '                    break;', '                case TabOpenType.OPEN_NEW_TAB:', '                    if (fromLauncherShortcut) {', '                        recordLauncherShortcutAction(false);', '                        reportNewTabShortcutUsed(false);', '                    }', '', '                    launchIntent(loadUrlParams, externalAppId, true, intent);', '                    break;', '                case TabOpenType.OPEN_NEW_INCOGNITO_TAB:', '                    if (!TextUtils.equals(externalAppId, getPackageName())) {', '                        assert false : ""Only Chrome is allowed to open incognito tabs"";', '                        Log.e(TAG, ""Only Chrome is allowed to open incognito tabs"");', '                        return;', '                    }', '', '                    if (!IncognitoUtils.isIncognitoModeEnabled()) {', '                        // The incognito launcher shortcut is manipulated in #onDeferredStartup(),', ""                        // so it's possible for a user to invoke the shortcut before it's disabled."", '                        // Quick actions search widget is installed on the home screen and may', '                        // need to be updated before the incognito button is removed.', '                        // Opening an incognito tab while incognito mode is disabled from somewhere', '                        // besides the launcher shortcut of from quick action search widget is an', '                        // error.', '                        if (fromAppWidget || fromLauncherShortcut) {', '                            // We are using the message introduced for quick action search widget', '                            // for both the widget and the launcher shortcut here.', '                            Toast.makeText(ChromeTabbedActivity.this,', '                                         R.string.quick_action_search_widget_message_no_incognito,', '                                         Toast.LENGTH_LONG)', '                                    .show();', '                        } else {', '                            assert false : ""Tried to open incognito tab while incognito disabled"";', '                            Log.e(TAG, ""Tried to open incognito tab while incognito disabled"");', '                        }', '', '                        return;', '                    }', '', '                    if (url == null || url.equals(UrlConstants.NTP_URL)) {', '                        if (fromLauncherShortcut) {', '                            getTabCreator(true).launchUrl(', '                                    UrlConstants.NTP_URL, TabLaunchType.FROM_LAUNCHER_SHORTCUT);', '                            recordLauncherShortcutAction(true);', '                            reportNewTabShortcutUsed(true);', '                        } else if (fromAppWidget) {', '                            RecordUserAction.record(""QuickActionSearchWidget.StartIncognito"");', '                            getTabCreator(true).launchUrl(', '                                    UrlConstants.NTP_URL, TabLaunchType.FROM_APP_WIDGET);', '                        } else if (IncognitoTabLauncher.didCreateIntent(intent)) {', '                            Tab tab = getTabCreator(true).launchUrl(UrlConstants.NTP_URL,', '                                    TabLaunchType.FROM_LAUNCH_NEW_INCOGNITO_TAB);', '                            if (IncognitoTabLauncher.shouldFocusOmnibox(intent)) {', '                                // Since the Tab is created in the foreground, its View will gain', '                                // focus, and since the Tab and the URL bar are not yet in the same', ""                                // View hierarchy, setting the URL bar's focus here won't clear the"", ""                                // Tab's focus. When the Tab is added to the hierarchy, we want the"", ""                                // URL bar to retain focus, so we clear the Tab's focus here."", '                                tab.getView().clearFocus();', '                                focus = true;', '                            }', '', '                            IncognitoTabLauncher.recordUse();', '                        } else {', '                            // Used by the Account management screen to open a new incognito tab.', '                            // Account management screen collects its metrics separately.', '                            getTabCreator(true).launchUrl(UrlConstants.NTP_URL,', '                                    TabLaunchType.FROM_CHROME_UI, intent, mIntentHandlingTimeMs);', '                        }', '                    } else {', '                        @TabLaunchType', '                        Integer launchType = IntentHandler.getTabLaunchType(intent);', '                        if (launchType == null) launchType = TabLaunchType.FROM_LINK;', '                        getTabCreator(true).launchUrl(', '                                url, launchType, intent, mIntentHandlingTimeMs);', '                    }', '                    break;', '                default:', '                    assert false : ""Unknown TabOpenType: "" + tabOpenType;', '                    break;', '            }', '', '            getToolbarManager().setUrlBarFocusOnceNativeInitialized(focus,', '                    focus ? OmniboxFocusReason.LAUNCH_NEW_INCOGNITO_TAB', '                          : OmniboxFocusReason.UNFOCUS);', '', '            if (tabModel.getCount() > 0 && isInOverviewMode() && !isTablet()', '                    && !shouldShowOverviewPageOnStart()) {', '                mOverviewModeController.hideOverview(true);', '            }', '        }', '', '        @Override', '        public long getIntentHandlingTimeMs() {', '            return mIntentHandlingTimeMs;', '        }', '', '        @Override', '        public void processWebSearchIntent(String query) {', '            assert false;', '        }', '', '        @Override', '        public void processTranslateTabIntent(', '                @Nullable String targetLanguageCode, @Nullable String expectedUrl) {', '            TranslateIntentHandler.translateTab(getActivityTab(), targetLanguageCode, expectedUrl);', '        }', '', '        private boolean isFromChrome(Intent intent, String externalAppId) {', '            // To determine if the processed intent is from Chrome, check for any of the following:', '            // 1.) The authentication token that will be added to trusted intents.', '            // 2.) The app ID matches Chrome.  This value can be spoofed by other applications, but', '            //     in cases where we were not able to add the authentication token this is our only', '            //     indication the intent was from Chrome.', '            return IntentHandler.wasIntentSenderChrome(intent)', '                    || TextUtils.equals(externalAppId, getPackageName());', '        }', '    }', '', '    @Override', '    public void performPreInflationStartup() {', '        // Create JankTracker before invoking super, because the parent class will invoke', '        // createRootUiCoordinator(...), which in our case requires the JankTracker to already have', '        // been created.', '        mJankTracker = new JankTrackerImpl(this);', '', '        super.performPreInflationStartup();', '', '        // Decide whether to record startup UMA histograms. This is done  early in the main', '        // Activity.onCreate() to avoid recording navigation delays when they require user input to', '        // proceed. For example, FRE (First Run Experience) happens before the activity is created,', '        // and triggers initialization of the native library.', '        //', '        // An uninitialized native library is an indication of an application start that is followed', '        // by navigation immediately without user input.', '        if (!LibraryLoader.getInstance().isInitialized()) {', '            setTrackColdStartupMetrics(true);', '        }', '', '        supportRequestWindowFeature(Window.FEATURE_ACTION_MODE_OVERLAY);', '', '        IncognitoTabHostRegistry.getInstance().register(mIncognitoTabHost);', '', '        mStartupPaintPreviewHelperSupplier.attach(getWindowAndroid().getUnownedUserDataHost());', '    }', '', '    @Override', '    protected RootUiCoordinator createRootUiCoordinator() {', '        return new TabbedRootUiCoordinator(this, this::onOmniboxFocusChanged,', '                getShareDelegateSupplier(), getActivityTabProvider(), mTabModelProfileSupplier,', '                mBookmarkBridgeSupplier, this::getContextualSearchManager,', '                getTabModelSelectorSupplier(), mStartSurfaceSupplier,', '                mIntentMetadataOneshotSupplier, mLayoutStateProviderOneshotSupplier,', '                mStartSurfaceParentTabSupplier, getBrowserControlsManager(), getWindowAndroid(),', '                mJankTracker, getLifecycleDispatcher(), getLayoutManagerSupplier(),', '                /* menuOrKeyboardActionController= */ this, this::getActivityThemeColor,', '                getModalDialogManagerSupplier(), /* appMenuBlocker= */ this, this::supportsAppMenu,', '                this::supportsFindInPage, getTabCreatorManagerSupplier(), getFullscreenManager(),', '                getCompositorViewHolderSupplier(), getTabContentManagerSupplier(),', '                getOverviewModeBehaviorSupplier(), this::getSnackbarManager, getActivityType(),', '                this::isInOverviewMode, this::isWarmOnResume,', '                /* appMenuDelegate= */ this, /* statusBarColorProvider= */ this,', '                mEphemeralTabCoordinatorSupplier, getIntentRequestTracker(),', '                getControlContainerHeightResource(), this::getInsetObserverView,', '                this::backShouldCloseTab);', '    }', '', '    @Override', '    protected int getControlContainerLayoutId() {', '        return R.layout.control_container;', '    }', '', '    @Override', '    public int getControlContainerHeightResource() {', '        return R.dimen.control_container_height;', '    }', '', '    @Override', '    protected int getToolbarLayoutId() {', '        return isTablet() ? R.layout.toolbar_tablet : R.layout.toolbar_phone;', '    }', '', '    @Override', '    protected int getToolbarShadowResource() {', '        final boolean themeRefactorEnabled =', '                CachedFeatureFlags.isEnabled(ChromeFeatureList.THEME_REFACTOR_ANDROID);', '        return themeRefactorEnabled ? R.drawable.toolbar_hairline', '                                    : R.drawable.modern_toolbar_shadow;', '    }', '', '    @Override', '    protected int getToolbarShadowLayoutHeight() {', '        final int res = CachedFeatureFlags.isEnabled(ChromeFeatureList.THEME_REFACTOR_ANDROID)', '                ? R.dimen.toolbar_hairline_height', '                : R.dimen.toolbar_shadow_height;', '        return getResources().getDimensionPixelSize(res);', '    }', '', '    @Override', '    public void performPostInflationStartup() {', '        super.performPostInflationStartup();', '', '        FontPreloader.getInstance().onPostInflationStartupTabbedActivity();', '', '        TabModelSelector tabModelSelector = getTabModelSelector();', '        IncognitoProfileDestroyer.observeTabModelSelector(tabModelSelector);', '        IncognitoNotificationPresenceController.observeTabModelSelector(tabModelSelector);', '', '        // Critical path for startup. Create the minimum objects needed', '        // to allow a blank screen draw (without depending on any native code)', '        // and then yield ASAP.', '        if (isFinishing()) return;', '', ""        // Don't show the keyboard until user clicks in."", '        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN', '                | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);', '', '        mContentContainer = (ViewGroup) findViewById(android.R.id.content);', '        mControlContainer = (ToolbarControlContainer) findViewById(R.id.control_container);', '', '        Supplier<Boolean> dialogVisibilitySupplier = null;', '        if (TabUiFeatureUtilities.isTabGroupsAndroidEnabled(this)) {', '            dialogVisibilitySupplier = () -> {', '                assert mStartSurfaceSupplier.get() != null;', '                assert getToolbarManager().getTabGroupUi() != null;', '                // Return true if dialog from either tab switcher or tab strip is visible.', '', '                ToolbarManager toolbarManager = getToolbarManager();', '                TabGroupUi tabGroupUi = toolbarManager.getTabGroupUi();', '                boolean isDialogVisible = tabGroupUi.isTabGridDialogVisible();', '', '                Supplier<Boolean> tabSwitcherDialogVisibilitySupplier =', '                        mStartSurfaceSupplier.get().getTabGridDialogVisibilitySupplier();', '', '                if (tabSwitcherDialogVisibilitySupplier != null) {', '                    isDialogVisible = isDialogVisible || tabSwitcherDialogVisibilitySupplier.get();', '                }', '                return isDialogVisible;', '            };', '        }', '', '        mUndoBarPopupController = new UndoBarController(this, mTabModelSelector,', '                this::getSnackbarManager, mOverviewModeBehaviorSupplier, dialogVisibilitySupplier);', '', '        mInactivityTracker = new ChromeInactivityTracker(', '                ChromePreferenceKeys.TABBED_ACTIVITY_LAST_BACKGROUNDED_TIME_MS_PREF);', '', '        assert getActivityTabStartupMetricsTracker() != null;', '        if (StartupPaintPreviewHelper.isEnabled()) {', '            StartupPaintPreviewHelper paintPreviewHelper = new StartupPaintPreviewHelper(', '                    getWindowAndroid(), getOnCreateTimestampMs(), getBrowserControlsManager(),', '                    getTabModelSelector(), shouldShowOverviewPageOnStart(), () -> {', '                        return getToolbarManager() == null', '                                ? null', '                                : getToolbarManager().getProgressBarCoordinator();', '                    });', '            mStartupPaintPreviewHelperSupplier.set(paintPreviewHelper);', '            getActivityTabStartupMetricsTracker().registerPaintPreviewObserver(paintPreviewHelper);', '        }', '    }', '', '    private boolean shouldIgnoreIntent() {', '        if (mShouldIgnoreIntent == null) {', '            // We call this only once because mIntentHandler#shouldIgnoreIntent has side effects.', '            mShouldIgnoreIntent =', '                    mIntentHandler.shouldIgnoreIntent(getIntent(), /*startedActivity=*/true);', '        }', '        return mShouldIgnoreIntent;', '    }', '', '    @Override', '    protected final void dispatchOnInflationComplete() {', '        super.dispatchOnInflationComplete();', '', '        // When the feature flag {@link ChromeFeatureList.INSTANT_START} turns on phones (not', '        // tablet), a view-only start page created on Java will be shown before native is', '        // initialized. The {@link prepareToShowStartPagePreNative()} is only called in a cold', '        // start.', '        if (ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()', '                && TabUiFeatureUtilities.supportInstantStart(isTablet(), this) && !hadWarmStart()) {', '            prepareToShowStartPagePreNative();', '        }', '    }', '', '    /**', '     * Prepares to show the start page before native is initialized. For example, create', '     * an LayoutManagerChrome object, add overview mode observer and so on.', '     */', '    private void prepareToShowStartPagePreNative() {', '        assert TabUiFeatureUtilities.supportInstantStart(isTablet() && !hadWarmStart(), this);', '        try (TraceEvent e =', '                        TraceEvent.scoped(""ChromeTabbedActivity.prepareToShowStartPagePreNative"")) {', '            setupCompositorContentPreNativeForPhone();', '            getCompositorViewHolderSupplier().get().setLayoutManager(mLayoutManager);', '', '            if (shouldShowOverviewPageOnStart()) {', '                mLayoutManager.setTabModelSelector(mTabModelSelector);', '                mIsAccessibilityTabSwitcherEnabled =', '                        DeviceClassManager.enableAccessibilityLayout(this);', '                assert !mHasDeterminedOverviewStateForCurrentSession;', '                setInitialOverviewState();', '            }', '        }', '    }', '', '    @Override', '    protected TabModelOrchestrator createTabModelOrchestrator() {', '        boolean tabMergingEnabled =', '                mMultiInstanceManager != null && mMultiInstanceManager.isTabModelMergingEnabled();', '        mTabModelOrchestrator = new TabbedModeTabModelOrchestrator(tabMergingEnabled);', '        return mTabModelOrchestrator;', '    }', '', '    @Override', '    protected void createTabModels() {', '        assert mTabModelSelector == null;', '        assert mWindowId != INVALID_WINDOW_ID;', '', '        Bundle savedInstanceState = getSavedInstanceState();', '', '        // We determine the model as soon as possible so every systems get initialized coherently.', '        boolean startIncognito = savedInstanceState != null', '                && savedInstanceState.getBoolean(IS_INCOGNITO_SELECTED, false);', '', '        mNextTabPolicySupplier = new ChromeNextTabPolicySupplier(mOverviewModeBehaviorSupplier);', '', '        boolean tabModelWasCreated = mTabModelOrchestrator.createTabModels(', '                this, this, mNextTabPolicySupplier, mWindowId);', '        if (!tabModelWasCreated) {', '            finish();', '            return;', '        }', '', '        if (mMultiInstanceManager != null) {', '            int assignedIndex = TabWindowManagerSingleton.getInstance().getIndexForWindow(this);', '            // The given index and the one computed by TabWindowManager should be one and the same.', '            assert !MultiWindowUtils.isMultiInstanceApi31Enabled() || assignedIndex == mWindowId;', '            mMultiInstanceManager.initialize(assignedIndex, getTaskId());', '        }', '', '        mTabModelSelector = mTabModelOrchestrator.getTabModelSelector();', '        mTabModelSelector.addObserver(new TabModelSelectorObserver() {', '            @Override', '            public void onTabStateInitialized() {', '                if (!mCreatedTabOnStartup) return;', '', '                TabModel model = mTabModelSelector.getModel(false);', '                TasksUma.recordTasksUma(model);', '            }', '        });', '', '        mTabModelSelectorTabObserver = new TabModelSelectorTabObserver(mTabModelSelector) {', '            @Override', '            public void onDidFinishNavigation(Tab tab, NavigationHandle navigation) {', '                if (!navigation.hasCommitted() || !navigation.isInPrimaryMainFrame()) {', '                    return;', '                }', '                DataReductionPromoInfoBar.maybeLaunchPromoInfoBar(ChromeTabbedActivity.this,', '                        tab.getWebContents(), navigation.getUrl(), tab.isShowingErrorPage(),', '                        navigation.isFragmentNavigation(), navigation.httpStatusCode());', '                if (SyncErrorPromptUtils.isMessageUiEnabled()) {', '                    SyncErrorMessage.maybeShowMessageUi(', '                            getWindowAndroid(), ChromeTabbedActivity.this);', '                } else {', '                    SyncErrorInfoBar.maybeLaunchSyncErrorInfoBar(tab.getWebContents());', '                }', '                SendTabToSelfAndroidBridge.updateActiveWebContents(tab.getWebContents());', '            }', '        };', '        mAppIndexingUtil = new AppIndexingUtil(mTabModelSelector);', '', '        if (startIncognito) mTabModelSelector.selectModel(true);', '    }', '', '    @Override', '    protected LaunchCauseMetrics createLaunchCauseMetrics() {', '        return new TabbedActivityLaunchCauseMetrics(this);', '    }', '', '    @Override', '    public AppMenuPropertiesDelegate createAppMenuPropertiesDelegate() {', '        return new TabbedAppMenuPropertiesDelegate(this, getActivityTabProvider(),', '                getMultiWindowModeStateDispatcher(), getTabModelSelector(), getToolbarManager(),', '                getWindow().getDecorView(), this, mOverviewModeBehaviorSupplier,', '                ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()', '                        ? mStartSurfaceSupplier', '                        : null,', '                mBookmarkBridgeSupplier,', '                ()', '                        -> getTabCreator(/*incognito=*/false)', '                                   .launchUrl(NewTabPageUtils.encodeNtpUrl(', '                                                      NewTabPageLaunchOrigin.WEB_FEED),', '                                           TabLaunchType.FROM_CHROME_UI),', '                getModalDialogManager(), getSnackbarManager());', '    }', '', '    private TabDelegateFactory getTabDelegateFactory() {', '        if (mTabDelegateFactory == null) {', '            mTabDelegateFactory = new TabbedModeTabDelegateFactory(this,', '                    getAppBrowserControlsVisibilityDelegate(), getShareDelegateSupplier(),', '                    mEphemeralTabCoordinatorSupplier,', '                    ((TabbedRootUiCoordinator) mRootUiCoordinator)::onContextMenuCopyLink,', '                    mRootUiCoordinator.getBottomSheetController(),', '                    /* ChromeActivityNativeDelegate */ this, /* isCustomTab= */ false,', '                    getBrowserControlsManager(), getFullscreenManager(),', '                    /* TabCreatorManager */ this, getTabModelSelectorSupplier(),', '                    getCompositorViewHolderSupplier(), getModalDialogManagerSupplier(),', '                    this::getSnackbarManager, getBrowserControlsManager(), getActivityTabProvider(),', '                    getLifecycleDispatcher(), getWindowAndroid(), this::getLastUserInteractionTime,', '                    this::hadWarmStart, mJankTracker, getToolbarManager()::getToolbar);', '        }', '        return mTabDelegateFactory;', '    }', '', '    @Override', '    protected Pair<ChromeTabCreator, ChromeTabCreator> createTabCreators() {', '        ChromeTabCreator.OverviewNTPCreator overviewNTPCreator = null;', '', '        if (ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '            overviewNTPCreator = new ChromeTabCreator.OverviewNTPCreator() {', '                @Override', '                public boolean handleCreateNTPIfNeeded(boolean isNTP, boolean incognito,', '                        Tab parentTab, @NewTabPageLaunchOrigin int launchOrigin) {', '                    boolean shouldShowStart =', '                            showStartSurfaceHomeForNTP(isNTP, incognito, parentTab, launchOrigin);', '                    if (shouldShowStart) {', '                        mStartSurfaceParentTabSupplier.set(parentTab);', '                    }', '                    return shouldShowStart;', '                }', '', '                @Override', '                public void preTabInitialization(Tab tab, String url) {', '                    StartSurfaceConfiguration.maySetUserDataForEmptyTab(tab, url);', '                }', '            };', '        }', '        return Pair.create(', '                new ChromeTabCreator(this, getWindowAndroid(), getStartupTabPreloader(),', '                        this::getTabDelegateFactory, false, overviewNTPCreator,', '                        AsyncTabParamsManagerSingleton.getInstance(), getTabModelSelectorSupplier(),', '                        getCompositorViewHolderSupplier()),', '                new ChromeTabCreator(this, getWindowAndroid(), getStartupTabPreloader(),', '                        this::getTabDelegateFactory, true, overviewNTPCreator,', '                        AsyncTabParamsManagerSingleton.getInstance(), getTabModelSelectorSupplier(),', '                        getCompositorViewHolderSupplier()));', '    }', '', '    @Override', '    protected void initDeferredStartupForActivity() {', '        super.initDeferredStartupForActivity();', '        DeferredStartupHandler.getInstance().addDeferredTask(() -> {', '            ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);', '            RecordHistogram.recordSparseHistogram(', '                    ""MemoryAndroid.DeviceMemoryClass"", am.getMemoryClass());', '', '            LauncherShortcutActivity.updateIncognitoShortcut(ChromeTabbedActivity.this);', '', '            ChromeSurveyController.initialize(mTabModelSelector, getLifecycleDispatcher(),', '                    ChromeTabbedActivity.this, MessageDispatcherProvider.from(getWindowAndroid()));', '', '            if (mStartSurfaceSupplier.get() != null) {', '                mStartSurfaceSupplier.get().onOverviewShownAtLaunch(', '                        mOverviewShownOnStart, getOnCreateTimestampMs());', '            }', '        });', '    }', '', '    @Override', '    protected void recordIntentToCreationTime(long timeMs) {', '        super.recordIntentToCreationTime(timeMs);', '        RecordHistogram.recordCustomTimesHistogram(""MobileStartup.IntentToCreationTime.TabbedMode"",', '                timeMs, 1, DateUtils.SECOND_IN_MILLIS * 30, 50);', '    }', '', '    @Override', '    protected boolean isStartedUpCorrectly(Intent intent) {', '        mWindowId = 0;', '        Bundle savedInstanceState = getSavedInstanceState();', '        int windowId = getExtraWindowIdFromIntent(intent);', '        if (savedInstanceState != null && savedInstanceState.containsKey(WINDOW_INDEX)) {', '            // Activity is recreated after destruction. |windowId| must not be valid in this case.', '            assert windowId == INVALID_WINDOW_ID;', '            mWindowId = savedInstanceState.getInt(WINDOW_INDEX, 0);', '        } else if (mMultiInstanceManager != null) {', ""            // |allocInstanceId| doesn't do any disk I/O that would add a long-running task"", '            // to pre-inflation startup.', '            boolean preferNew = getExtraPreferNewFromIntent(intent);', '            mWindowId = mMultiInstanceManager.allocInstanceId(windowId, getTaskId(), preferNew);', '        }', '        if (mWindowId == INVALID_WINDOW_ID) {', '            Log.i(TAG, ""Window ID not allocated. Finishing the activity"");', '            Toast.makeText(this, R.string.max_number_of_windows, Toast.LENGTH_LONG).show();', '            return false;', '        }', '', '        if (mMultiInstanceManager != null', '                && !mMultiInstanceManager.isStartedUpCorrectly(getTaskId())) {', '            return false;', '        }', '', '        return super.isStartedUpCorrectly(intent);', '    }', '', '    private static int getExtraWindowIdFromIntent(Intent intent) {', '        int windowId = IntentUtils.safeGetIntExtra(', '                intent, IntentHandler.EXTRA_WINDOW_ID, INVALID_WINDOW_ID);', '        return IntentUtils.isTrustedIntentFromSelf(intent) ? windowId : INVALID_WINDOW_ID;', '    }', '', '    private static boolean getExtraPreferNewFromIntent(Intent intent) {', '        return IntentUtils.safeGetBooleanExtra(intent, IntentHandler.EXTRA_PREFER_NEW, false);', '    }', '', '    @Override', '    public void terminateIncognitoSession() {', '        getTabModelSelector().getModel(true).closeAllTabs();', '    }', '', '    @Override', '    public boolean onMenuOrKeyboardAction(final int id, boolean fromMenu) {', '        final Tab currentTab = getActivityTab();', '        boolean currentTabIsNtp = isTabNtp(currentTab);', '        if (id == R.id.new_tab_menu_id) {', '            getTabModelSelector().getModel(false).commitAllTabClosures();', '            RecordUserAction.record(""MobileMenuNewTab"");', '            RecordUserAction.record(""MobileNewTabOpened"");', '            ReturnToChromeExperimentsUtil.onNewTabOpened();', '            reportNewTabShortcutUsed(false);', '            if (fromMenu) RecordUserAction.record(""MobileMenuNewTab.AppMenu"");', '', '            getTabCreator(false).launchNTP();', '', '            mLocaleManager.showSearchEnginePromoIfNeeded(this, null);', '        } else if (id == R.id.new_incognito_tab_menu_id) {', '            if (IncognitoUtils.isIncognitoModeEnabled()) {', '                getTabModelSelector().getModel(false).commitAllTabClosures();', '                // This action must be recorded before opening the incognito tab since UMA actions', '                // are dropped when an incognito tab is open.', '                RecordUserAction.record(""MobileMenuNewIncognitoTab"");', '                RecordUserAction.record(""MobileNewTabOpened"");', '                ReturnToChromeExperimentsUtil.onNewTabOpened();', '                reportNewTabShortcutUsed(true);', '                if (fromMenu) RecordUserAction.record(""MobileMenuNewIncognitoTab.AppMenu"");', '                getTabCreator(true).launchNTP();', '            }', '        } else if (id == R.id.all_bookmarks_menu_id) {', ""            // Note that 'currentTab' could be null in overview mode when start surface is"", '            // enabled.', '            getCompositorViewHolderSupplier().get().hideKeyboard(() -> {', '                BookmarkUtils.showBookmarkManager(', '                        ChromeTabbedActivity.this, getCurrentTabModel().isIncognito());', '            });', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_BOOKMARKS_MANAGER);', '            }', '', '            @BrowserProfileType', '            int type = getCurrentTabModel().isIncognito() ? BrowserProfileType.INCOGNITO', '                                                          : BrowserProfileType.REGULAR;', '            RecordHistogram.recordEnumeratedHistogram(', '                    ""Bookmarks.OpenBookmarkManager.PerProfileType"", type,', '                    BrowserProfileType.MAX_VALUE + 1);', '', '            RecordUserAction.record(""MobileMenuAllBookmarks"");', '        } else if (id == R.id.recent_tabs_menu_id) {', '            LoadUrlParams params =', '                    new LoadUrlParams(UrlConstants.RECENT_TABS_URL, PageTransition.AUTO_BOOKMARK);', '            boolean isInOverviewMode = isInOverviewMode();', '            if (isInOverviewMode && !isTablet()', '                    && ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '                // When tapping the ""Recent tabs"" menu item from the overview page (Start surface or', '                // GTS), we will create the tab with the launch type FROM_START_SURFACE. Thus, if', '                // the back button is tapped on this ""Recent tabs"" page, it can go back to the', '                // overview page.', '                ReturnToChromeExperimentsUtil.handleLoadUrlFromStartSurface(', '                        params, getCurrentTabModel().isIncognito(), null);', '            } else if (currentTab != null) {', '                currentTab.loadUrl(params);', '            } else {', '                getTabCreator(getCurrentTabModel().isIncognito())', '                        .createNewTab(params, TabLaunchType.FROM_CHROME_UI, null);', '            }', '            if (isInOverviewMode) {', '                mOverviewModeController.hideOverview(true);', '            }', '', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_RECENT_TABS_MANAGER);', '            }', '            RecordUserAction.record(""MobileMenuRecentTabs"");', '            ReturnToChromeExperimentsUtil.onRecentTabsOpened();', '        } else if (id == R.id.close_tab) {', '            getCurrentTabModel().closeTab(currentTab, true, false, true);', '            RecordUserAction.record(""MobileTabClosed"");', '        } else if (id == R.id.close_all_tabs_menu_id) {', '            // Close both incognito and normal tabs', '            getTabModelSelector().closeAllTabs();', '            RecordUserAction.record(""MobileMenuCloseAllTabs"");', '        } else if (id == R.id.close_all_incognito_tabs_menu_id) {', '            // Close only incognito tabs', '            getTabModelSelector().getModel(true).closeAllTabs();', '            RecordUserAction.record(""MobileMenuCloseAllIncognitoTabs"");', '        } else if (id == R.id.focus_url_bar) {', '            boolean isUrlBarVisible = !mOverviewModeController.overviewVisible()', '                    && (!isTablet() || getCurrentTabModel().getCount() != 0);', '            if (isUrlBarVisible) {', '                getToolbarManager().setUrlBarFocus(', '                        true, OmniboxFocusReason.MENU_OR_KEYBOARD_ACTION);', '            }', '        } else if (id == R.id.downloads_menu_id) {', '            OTRProfileID otrProfileID = null;', '            if (currentTab != null && currentTab.getWebContents() != null) {', '                Profile profile = Profile.fromWebContents(currentTab.getWebContents());', '                otrProfileID = profile != null ? profile.getOTRProfileID() : null;', '            }', '            DownloadUtils.showDownloadManager(', '                    this, currentTab, otrProfileID, DownloadOpenSource.MENU);', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_DOWNLOADS_MANAGER);', '            }', '            RecordUserAction.record(""MobileMenuDownloadManager"");', '        } else if (id == R.id.open_recently_closed_tab) {', '            TabModel currentModel = mTabModelSelector.getCurrentModel();', '            if (!currentModel.isIncognito()) currentModel.openMostRecentlyClosedTab();', '            RecordUserAction.record(""MobileTabClosedUndoShortCut"");', '        } else if (id == R.id.enter_vr_id) {', '            VrModuleProvider.getDelegate().enterVrIfNecessary();', '        } else {', '            return super.onMenuOrKeyboardAction(id, fromMenu);', '        }', '        return true;', '    }', '', '    private boolean isTabNtp(Tab tab) {', '        return tab != null && UrlUtilities.isNTPUrl(tab.getUrl());', '    }', '', '    private boolean isTabRegularNtp(Tab tab) {', '        return isTabNtp(tab) && !tab.isIncognito();', '    }', '', '    private void onOmniboxFocusChanged(boolean hasFocus) {', '        mTabModalHandler.onOmniboxFocusChanged(hasFocus);', '    }', '', '    private void recordLauncherShortcutAction(boolean isIncognito) {', '        if (isIncognito) {', '            RecordUserAction.record(""Android.LauncherShortcut.NewIncognitoTab"");', '        } else {', '            RecordUserAction.record(""Android.LauncherShortcut.NewTab"");', '        }', '    }', '', '    @Override', '    public boolean handleBackPressed() {', '        if (!mUIWithNativeInitialized) return false;', '', '        if (getManualFillingComponent().handleBackPress()) return true;', '', '        if (exitFullscreenIfShowing()) {', '            return true;', '        }', '', '        // TODO(1091411): Find a better mechanism for back-press handling for features.', '        if (mRootUiCoordinator.getBottomSheetController().handleBackPress()) return true;', '', '        if (mTabModalHandler.handleBackPress()) return true;', '', '        final Tab currentTab = getActivityTab();', '        if (currentTab == null) {', '            moveTaskToBack(true);', '            return true;', '        }', '', '        // If we are in the tab switcher mode (not in the Start surface homepage) and not a tablet,', '        // then leave tab switcher mode on back.', '        if (mOverviewModeController.overviewVisible() && !isTablet()', '                && (mStartSurfaceSupplier.get() == null', '                        || mStartSurfaceSupplier.get().getController().getStartSurfaceState()', '                                == StartSurfaceState.SHOWN_TABSWITCHER)) {', '            mOverviewModeController.hideOverview(true);', '            return true;', '        }', '', '        final WebContents webContents = currentTab.getWebContents();', '        if (webContents != null) {', '            RenderFrameHost focusedFrame = webContents.getFocusedFrame();', '            if (focusedFrame != null && focusedFrame.signalCloseWatcherIfActive()) return true;', '        }', '', '        if (getToolbarManager().back()) return true;', '', '        // If the current tab url is HELP_URL, then the back button should close the tab to', '        // get back to the previous state. The reason for startsWith check is that the', '        // actual redirected URL is a different system language based help url.', '        final @TabLaunchType int type = currentTab.getLaunchType();', '        final boolean helpUrl = currentTab.getUrl().getSpec().startsWith(HELP_URL_PREFIX);', '        if (type == TabLaunchType.FROM_CHROME_UI && helpUrl) {', '            getCurrentTabModel().closeTab(currentTab);', '            return true;', '        }', '', ""        // If we aren't in the overview mode, we handle the Tab with launchType"", '        // TabLaunchType.FROM_START_SURFACE or has ""OpenedFromStart"" property.', '        if (!mOverviewModeController.overviewVisible()', '                && (type == TabLaunchType.FROM_START_SURFACE', '                        || StartSurfaceUserData.isOpenedFromStart(currentTab))) {', '            if (StartSurfaceUserData.getKeepTab(currentTab)', '                    || StartSurfaceUserData.isOpenedFromStart(currentTab)) {', '                // If the current tab is created from the start surface with the keepTab property,', '                // shows the Start surface Homepage to prevent a loop between the current tab and', '                // previous overview mode. Once in the Start surface, it will close Chrome if back', '                // button is tapped again.', '                showOverview(StartSurfaceState.SHOWING_HOMEPAGE);']}, {'a': ['                if (type == TabLaunchType.FROM_LONGPRESS_BACKGROUND', '                        && !StartSurfaceUserData.getKeepTab(currentTab)) {'], 'b': ['                if (type == TabLaunchType.FROM_LONGPRESS_BACKGROUND) {']}, {'ab': ['                    getCurrentTabModel().closeTab(currentTab);', '                }', '            } else {', '                // Otherwise, clicking the back button should close the tab and go back to the', '                // previous overview mode.', '                showOverview(StartSurfaceState.SHOWING_PREVIOUS);', '                if (!currentTab.isClosing()) {', '                    getCurrentTabModel().closeTab(currentTab);', '                }', '            }', '            return true;', '        }', '', '        final boolean shouldCloseTab = backShouldCloseTab(currentTab);', '', '        // Minimize the app if either:', '        // - we decided not to close the tab', '        // - we decided to close the tab, but it was opened by an external app, so we will go', '        //   exit Chrome on top of closing the tab', '        final boolean minimizeApp =', '                !shouldCloseTab || TabAssociatedApp.isOpenedFromExternalApp(currentTab);', '        if (minimizeApp) {', '            if (shouldCloseTab) {', '                sendToBackground(currentTab);', '                return true;', '            } else {', '                sendToBackground(null);', '                return true;', '            }', '        } else if (shouldCloseTab) {', '            currentTab.getWebContents().dispatchBeforeUnload(false);', '            return true;', '        }', '', '        assert false : ""The back button should have already been handled by this point"";', '        return false;', '    }', '', '    /**', '     * [true]: Reached the bottom of the back stack on a tab the user did not explicitly', '     * create (i.e. it was created by an external app or opening a link in background, etc).', '     * [false]: Reached the bottom of the back stack on a tab that the user explicitly', '     * created (e.g. selecting ""new tab"" from menu).', '     *', '     * @return Whether pressing the back button on the provided Tab should close the Tab.', '     */', '    @Override', '    public boolean backShouldCloseTab(Tab tab) {', '        if (!tab.isInitialized()) {', '            return false;', '        }', '        @TabLaunchType', '        int type = tab.getLaunchType();', '', '        return type == TabLaunchType.FROM_LINK || type == TabLaunchType.FROM_EXTERNAL_APP', '                || type == TabLaunchType.FROM_LONGPRESS_FOREGROUND', '                || type == TabLaunchType.FROM_LONGPRESS_BACKGROUND', '                || (type == TabLaunchType.FROM_RESTORE', '                        && CriticalPersistedTabData.from(tab).getParentId() != Tab.INVALID_TAB_ID);', '    }', '', '    /**', '     * Sends this Activity to the background.', '     *', '     * @param tabToClose Tab that will be closed once the app is not visible.', '     */', '    private void sendToBackground(@Nullable final Tab tabToClose) {', '        Log.i(TAG, ""sendToBackground(): "" + tabToClose);', '        moveTaskToBack(true);', '        if (tabToClose != null) {', ""            // In the case of closing a tab upon minimization, don't allow the close action to"", ""            // happen until after our app is minimized to make sure we don't get a brief glimpse of"", '            // the newly active tab before we exit Chrome.', '            //', ""            // If the runnable doesn't run before the Activity dies, Chrome won't crash but the tab"", ""            // won't be closed (crbug.com/587565)."", '            mHandler.postDelayed(() -> {', '                boolean hasNextTab =', '                        getCurrentTabModel().getNextTabIfClosed(tabToClose.getId()) != null;', '                getCurrentTabModel().closeTab(tabToClose, false, true, false);', '', '                // If there is no next tab to open, enter overview mode.', '                if (!hasNextTab) showOverview(StartSurfaceState.SHOWING_START);', '            }, CLOSE_TAB_ON_MINIMIZE_DELAY_MS);', '        }', '    }', '', '    @Override', '    public boolean moveTaskToBack(boolean nonRoot) {', '        try {', '            return super.moveTaskToBack(nonRoot);', '        } catch (NullPointerException e) {', '            // Work around framework bug described in https://crbug.com/817567.', '            finish();', '            return true;', '        }', '    }', '', '    /**', '     * Launch a URL from an intent.', '     *', '     * @param url           The url from the intent.', '     * @param referer       Optional referer URL to be used.', '     * @param headers       Optional headers to be sent when opening the URL.', '     * @param externalAppId External app id.', '     * @param forceNewTab   Whether to force the URL to be launched in a new tab or to fall', '     *                      back to the default behavior for making that determination.', '     * @param isRendererInitiated Whether the intent is originally from browser renderer process.', '     * @param initiatorOrigin Origin that initiates the intent.', '     * @param intent        The original intent.', '     */', '    private Tab launchIntent(', '            LoadUrlParams loadUrlParams, String externalAppId, boolean forceNewTab, Intent intent) {', '        if (mUIWithNativeInitialized && !UrlUtilities.isNTPUrl(loadUrlParams.getUrl())) {', '            mOverviewModeController.hideOverview(false);', '            getToolbarManager().finishAnimations();', '        }', '        if (IntentHandler.wasIntentSenderChrome(intent)) {', '            // If the intent was launched by chrome, open the new tab in the appropriate model.', '            boolean isIncognito = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_OPEN_NEW_INCOGNITO_TAB, false);', '            @TabLaunchType', '            Integer launchType = IntentHandler.getTabLaunchType(intent);', '            if (launchType == null) {', '                if (IntentUtils.safeGetBooleanExtra(', '                            intent, IntentHandler.EXTRA_INVOKED_FROM_SHORTCUT, false)) {', '                    launchType = TabLaunchType.FROM_LAUNCHER_SHORTCUT;', '                } else if (IntentUtils.safeGetBooleanExtra(', '                                   intent, IntentHandler.EXTRA_INVOKED_FROM_APP_WIDGET, false)) {', '                    launchType = TabLaunchType.FROM_APP_WIDGET;', '                } else if (IncognitoTabLauncher.didCreateIntent(intent)) {', '                    launchType = TabLaunchType.FROM_LAUNCH_NEW_INCOGNITO_TAB;', '                } else {', '                    // Using FROM_LINK ensures the tab is parented to the current tab, which allows', '                    // the back button to close these tabs and restore selection to the previous', '                    // tab.', '                    launchType = TabLaunchType.FROM_LINK;', '                }', '            }', '            return getTabCreator(isIncognito).createNewTab(loadUrlParams, launchType, null, intent);', '        }', '', '        // Check if the tab is being created from a Reader Mode navigation.', '        if (ReaderModeManager.isEnabled() && ReaderModeManager.isReaderModeCreatedIntent(intent)) {', '            Bundle extras = intent.getExtras();', '            int readerParentId = IntentUtils.safeGetInt(', '                    extras, ReaderModeManager.EXTRA_READER_MODE_PARENT, Tab.INVALID_TAB_ID);', '            extras.remove(ReaderModeManager.EXTRA_READER_MODE_PARENT);', '            // Set the parent tab to the tab that Reader Mode started from.', '            if (readerParentId != Tab.INVALID_TAB_ID && mTabModelSelector != null) {', '                return getCurrentTabCreator().createNewTab(', '                        new LoadUrlParams(loadUrlParams.getUrl(), PageTransition.LINK),', '                        TabLaunchType.FROM_LINK, mTabModelSelector.getTabById(readerParentId));', '            }', '        }', '', '        return getTabCreator(false).launchUrlFromExternalApp(', '                loadUrlParams, externalAppId, forceNewTab, intent);', '    }', '', '    private void showOverview(@StartSurfaceState int state) {', '        showOverview(state, NewTabPageLaunchOrigin.UNKNOWN);', '    }', '', '    // TODO(crbug.com/1115757): After crrev.com/c/2315823, Overview state and Startsurface state are', '    // two different things, we actual can split this into two methods: showOverview() and', ""    // showStartSurface(state). Let's do some auditing and clean up before perform the actual split."", '    private void showOverview(', '            @StartSurfaceState int state, @NewTabPageLaunchOrigin int launchOrigin) {', '        assert (state == StartSurfaceState.SHOWING_TABSWITCHER', '                || state == StartSurfaceState.SHOWING_HOMEPAGE', '                || state == StartSurfaceState.SHOWING_PREVIOUS', '                || state == StartSurfaceState.SHOWING_START);', '        if (mIsAccessibilityTabSwitcherEnabled != null && mIsAccessibilityTabSwitcherEnabled', '                && mOverviewModeController != null) {', '            // TODO(1200727): This is a temporary fix that should be removed once grid tab switcher', '            //                is completely launched. The ""start surface"" is now created regardless', '            //                of the state of accessibility, so we check that mode first and try', '            //                showing the overview list before going to the start surface.', '            mOverviewModeController.showOverview(false);', '        } else if (mStartSurfaceSupplier.get() != null) {', '            if (ReturnToChromeExperimentsUtil.shouldHideStartSurfaceWithAccessibilityOn(this)', '                    || !HomepageManager.isHomepageEnabled()) {', '                state = StartSurfaceState.SHOWING_TABSWITCHER;', '            }', '            mStartSurfaceSupplier.get().getController().setOverviewState(state, launchOrigin);', '        }', '', '        if (mOverviewModeController == null) return;', '', '        if (mOverviewModeController.overviewVisible()) {', '            if (didFinishNativeInitialization()) {', '                getCompositorViewHolderSupplier().get().hideKeyboard(() -> {});', '            }', '            return;', '        }', '', '        Tab currentTab = getActivityTab();', ""        // If we don't have a current tab, show the overview mode."", '        if (currentTab == null) {', '            mOverviewModeController.showOverview(false);', '        } else {', '            getCompositorViewHolderSupplier().get().hideKeyboard(', '                    () -> mOverviewModeController.showOverview(true));', '            updateAccessibilityState(false);', '            TasksUma.recordTabLaunchType(getCurrentTabModel());', '        }', '    }', '', '    private void hideOverview() {', '        assert (mOverviewModeController.overviewVisible());', '        if (getCurrentTabModel().getCount() != 0) {', ""            // Don't hide overview if current tab stack is empty()"", '            mOverviewModeController.hideOverview(true);', '            updateAccessibilityState(true);', '        }', '    }', '', '    /**', '     * @return Whether opening a new tab is handled by the Start surface. It may show the Start', '     * surface, or open a new tab with the omnibox get focused, depending on the value of', '     * {@link StartSurfaceConfiguration.OMNIBOX_FOCUSED_ON_NEW_TAB}.', '     */', '    private boolean showStartSurfaceHomeForNTP(boolean isNTP, boolean incognito, Tab parentTab,', '            @NewTabPageLaunchOrigin int launchOrigin) {', '        if (!isNTP', '                || !ReturnToChromeExperimentsUtil.shouldShowStartSurfaceHomeAsNTP(', '                        this, incognito, isTablet())) {', '            return false;', '        }', '', '        getTabModelSelector().selectModel(incognito);', '        if (StartSurfaceConfiguration.OMNIBOX_FOCUSED_ON_NEW_TAB.getValue()', '                && launchOrigin != NewTabPageLaunchOrigin.WEB_FEED) {', '            Runnable emptyTabCloseCallback = isInOverviewMode() ? () -> {', '                showOverview(StartSurfaceState.SHOWING_PREVIOUS, launchOrigin);', '            } : null;', '            ReturnToChromeExperimentsUtil.handleLoadUrlFromStartSurfaceAsNewTab(null,', '                    PageTransition.AUTO_TOPLEVEL, incognito, parentTab, getCurrentTabModel(),', '                    emptyTabCloseCallback);', '        } else if (TabUiFeatureUtilities.supportInstantStart(isTablet(), this)', '                || (getTabModelSelector().isTabStateInitialized() && isLayoutManagerCreated())) {', '            showOverview(StartSurfaceState.SHOWING_HOMEPAGE, launchOrigin);', '        }', '        return true;', '    }', '', '    private void updateAccessibilityState(boolean enabled) {', '        Tab currentTab = getActivityTab();', '        WebContents webContents = currentTab != null ? currentTab.getWebContents() : null;', '        if (webContents != null) {', '            WebContentsAccessibility.fromWebContents(webContents).setState(enabled);', '        }', '    }', '', '    @Override', '    public void onSaveInstanceState(Bundle outState) {', '        super.onSaveInstanceState(outState);', '        CipherFactory.getInstance().saveToBundle(outState);', '        outState.putInt(', '                WINDOW_INDEX, TabWindowManagerSingleton.getInstance().getIndexForWindow(this));', '        Boolean is_incognito = getCurrentTabModel().isIncognito();', '        outState.putBoolean(IS_INCOGNITO_SELECTED, is_incognito);', ""        // If it's Incognito and native is initialized and profile exists, serialize duration"", '        // service state.', '        if (is_incognito && ProfileManager.isInitialized()) {', '            AndroidSessionDurationsServiceState.serializeFromNative(', '                    outState, getCurrentTabModel().getProfile());', '        }', '    }', '', '    @Override', '    public void onDestroyInternal() {', '        if (mCallbackController != null) {', '            mCallbackController.destroy();', '            mCallbackController = null;', '        }', '', '        if (mTabModelSelectorTabObserver != null) {', '            mTabModelSelectorTabObserver.destroy();', '            mTabModelSelectorTabObserver = null;', '        }', '', '        if (mTabModelObserver != null) mTabModelObserver.destroy();', '', '        if (mUndoBarPopupController != null) {', '            mUndoBarPopupController.destroy();', '            mUndoBarPopupController = null;', '        }', '', '        if (mAppIndexingUtil != null) {', '            mAppIndexingUtil.destroy();', '            mAppIndexingUtil = null;', '        }', '', '        if (mStartSurfaceSupplier.get() != null) {', '            mStartSurfaceSupplier.get().destroy();', '        }', '', '        if (mStartupPaintPreviewHelperSupplier != null) {', '            mStartupPaintPreviewHelperSupplier.destroy();', '        }', '', '        if (mJankTracker != null) {', '            mJankTracker.destroy();', '            mJankTracker = null;', '        }', '', '        IncognitoTabHostRegistry.getInstance().unregister(mIncognitoTabHost);', '', '        TabObscuringHandler tabObscuringHandler = getTabObscuringHandler();', '        if (tabObscuringHandler != null) {', '            getTabObscuringHandler().removeObserver(mCompositorViewHolder);', '            getTabObscuringHandler().removeObserver(mOverviewListLayout);', '        }', '', '        if (isTablet()) ChromeAccessibilityUtil.get().removeObserver(mCompositorViewHolder);', '        ChromeAccessibilityUtil.get().removeObserver(this);', '        ChromeAccessibilityUtil.get().removeObserver(mLayoutManager);', '', '        if (mTabDelegateFactory != null) mTabDelegateFactory.destroy();', '', '        mAppLaunchDrawBlocker.destroy();', '', '        super.onDestroyInternal();', '    }', '', '    @Override', '    protected void destroyTabModels() {', '        if (mTabModelOrchestrator != null) {', '            mTabModelOrchestrator.destroy();', '        }', '    }', '', '    @Override', '    public void onTrimMemory(int level) {', '        super.onTrimMemory(level);', '        if (ChromeApplicationImpl.isSevereMemorySignal(level)) {', '            NativePageAssassin.getInstance().freezeAllHiddenPages();', '        }', '    }', '', '    @Override', '    public boolean dispatchKeyEvent(KeyEvent event) {', '        Boolean result = KeyboardShortcuts.dispatchKeyEvent(event, mUIWithNativeInitialized,', '                getFullscreenManager(), /* menuOrKeyboardActionController= */ this);', '        return result != null ? result : super.dispatchKeyEvent(event);', '    }', '', '    @Override', '    public boolean onKeyDown(int keyCode, KeyEvent event) {', '        if (!mUIWithNativeInitialized) {', '            return super.onKeyDown(keyCode, event);', '        }', '        // Detecting a long press of the back button via onLongPress is broken in Android N.', '        // To work around this, use a postDelayed, which is supported in all versions.', '        if (keyCode == KeyEvent.KEYCODE_BACK && !isTablet()', '                && !getFullscreenManager().getPersistentFullscreenMode()) {', '            if (mShowHistoryRunnable == null) mShowHistoryRunnable = this::showFullHistorySheet;', '            mHandler.postDelayed(mShowHistoryRunnable, ViewConfiguration.getLongPressTimeout());', '            return super.onKeyDown(keyCode, event);', '        }', '        boolean isCurrentTabVisible = !mOverviewModeController.overviewVisible()', '                && (!isTablet() || getCurrentTabModel().getCount() != 0);', '        return KeyboardShortcuts.onKeyDown(event, isCurrentTabVisible, true, getTabModelSelector(),', '                       /* menuOrKeyboardActionController= */ this, getToolbarManager())', '                || super.onKeyDown(keyCode, event);', '    }', '', '    private void showFullHistorySheet() {', '        ((TabbedRootUiCoordinator) mRootUiCoordinator).showFullHistorySheet();', '    }', '', '    @Override', '    public boolean onKeyUp(int keyCode, KeyEvent event) {', '        if (keyCode == KeyEvent.KEYCODE_BACK && !isTablet()) {', '            mHandler.removeCallbacks(mShowHistoryRunnable);', '            mShowHistoryRunnable = null;', '            if (event.getEventTime() - event.getDownTime()', '                            >= ViewConfiguration.getLongPressTimeout()', '                    && NavigationSheet.isInstanceShowing(', '                            mRootUiCoordinator.getBottomSheetController())) {', '                // If tab history popup is showing, do not process the keyUp event', '                // which will dismiss it immediately.', '                return true;', '            }', '        }', '        return super.onKeyUp(keyCode, event);', '    }', '', '    @VisibleForTesting', '    public boolean hasPendingNavigationRunnableForTesting() {', '        ThreadUtils.assertOnUiThread();', '        return mShowHistoryRunnable != null;', '    }', '', '    @Override', '    public void onProvideKeyboardShortcuts(', '            List<KeyboardShortcutGroup> data, Menu menu, int deviceId) {', '        data.addAll(KeyboardShortcuts.createShortcutGroup(this));', '    }', '', '    @VisibleForTesting', '    public View getTabsView() {', '        return getCompositorViewHolderSupplier().get();', '    }', '', '    @VisibleForTesting', '    public LayoutManagerChrome getLayoutManager() {', '        return (LayoutManagerChrome) getCompositorViewHolderSupplier().get().getLayoutManager();', '    }', '', '    @VisibleForTesting', '    public Layout getOverviewListLayout() {', '        return getLayoutManager().getOverviewListLayout();', '    }', '', '    @VisibleForTesting', '    public StartSurface getStartSurface() {', '        return mStartSurfaceSupplier.get();', '    }', '', '    private ComposedBrowserControlsVisibilityDelegate getAppBrowserControlsVisibilityDelegate() {', '        // TODO(jinsukkim): Move this to RootUiCoordinator.', '        return ((TabbedRootUiCoordinator) mRootUiCoordinator)', '                .getAppBrowserControlsVisibilityDelegate();', '    }', '', '    @Override', '    protected ModalDialogManager createModalDialogManager() {', '        ModalDialogManager manager = super.createModalDialogManager();', '        // TODO(crbug.com/1157310): Transition this::method refs to dedicated suppliers.', '        mTabModalHandler = new TabModalLifetimeHandler(this, getLifecycleDispatcher(), manager,', '                this::getAppBrowserControlsVisibilityDelegate, this::getTabObscuringHandler,', '                this::getToolbarManager, this::getContextualSearchManager,', '                getTabModelSelectorSupplier(), this::getBrowserControlsManager,', '                this::getFullscreenManager);', '        return manager;', '    }', '', '    // App Menu related code -----------------------------------------------------------------------', '', '    @Override', '    public boolean canShowAppMenu() {', '        // The popup menu relies on the model created during the full UI initialization, so do not', '        // attempt to show the menu until the UI creation has finished.', '        if (!mUIWithNativeInitialized) return false;', '', ""        // If the current active tab is showing a tab modal dialog, an app menu shouldn't be shown"", '        // in any cases, e.g. when a hardware menu button is clicked.', '        Tab tab = getActivityTab();', '        if (tab != null && ChromeTabModalPresenter.isDialogShowing(tab)) return false;', '', '        return super.canShowAppMenu();', '    }', '', '    @Override', '    public boolean isInOverviewMode() {', '        return mOverviewModeController != null && mOverviewModeController.overviewVisible();', '    }', '', '    @Override', '    protected IntentHandlerDelegate createIntentHandlerDelegate() {', '        return new InternalIntentDelegate();', '    }', '', '    @Override', '    public void onSceneChange(Layout layout) {', '        super.onSceneChange(layout);', '        if (!layout.shouldDisplayContentOverlay()) mTabModelSelector.onTabsViewShown();', '    }', '', '    /**', '     * Writes the tab state to disk.', '     */', '    @VisibleForTesting', '    public void saveState() {', '        mTabModelOrchestrator.saveState();', '    }', '', '    @Override', '    public void onEnterVr() {', '        super.onEnterVr();', '        mControlContainer.setVisibility(View.INVISIBLE);', '        if (mVrBrowserControlsVisibilityDelegate == null) {', '            mVrBrowserControlsVisibilityDelegate =', '                    new BrowserControlsVisibilityDelegate(BrowserControlsState.BOTH);', '            getAppBrowserControlsVisibilityDelegate().addDelegate(', '                    mVrBrowserControlsVisibilityDelegate);', '        }', '        mVrBrowserControlsVisibilityDelegate.set(BrowserControlsState.HIDDEN);', '    }', '', '    @Override', '    public void onExitVr() {', '        super.onExitVr();', '        mControlContainer.setVisibility(View.VISIBLE);', '        if (mVrBrowserControlsVisibilityDelegate != null) {', '            mVrBrowserControlsVisibilityDelegate.set(BrowserControlsState.BOTH);', '        }', '    }', '', '    @Override', '    protected void applyThemeOverlays() {', '        super.applyThemeOverlays();', '', '        if (TabManagementModuleProvider.getDelegate() != null) {', '            TabManagementModuleProvider.getDelegate().applyThemeOverlays(this);', '        }', '    }', '', '    @Override', '    protected boolean supportsDynamicColors() {', '        return CachedFeatureFlags.isEnabled(ChromeFeatureList.DYNAMIC_COLOR_ANDROID);', '    }', '', '    /**', '     * Reports that a new tab launcher shortcut was selected or an action equivalent to a shortcut', '     * was performed.', '     * @param isIncognito Whether the shortcut or action created a new incognito tab.', '     */', '    @TargetApi(Build.VERSION_CODES.N_MR1)', '    private void reportNewTabShortcutUsed(boolean isIncognito) {', '        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N_MR1) return;', '', '        ShortcutManager shortcutManager = getSystemService(ShortcutManager.class);', '        shortcutManager.reportShortcutUsed(', '                isIncognito ? ""new-incognito-tab-shortcut"" : ""new-tab-shortcut"");', '    }', '', '    @VisibleForTesting', '    public MultiInstanceManager getMultiInstanceMangerForTesting() {', '        return mMultiInstanceManager;', '    }', '', '    @VisibleForTesting', '    public ChromeNextTabPolicySupplier getNextTabPolicySupplier() {', '        return (ChromeNextTabPolicySupplier) mNextTabPolicySupplier;', '    }', '}', '']}]",chromium%2Fsrc~main~Ib8e4eafef2405d982bc64a050f47a12c26242ec2,18d923c044f261448f485740f8bb60731b5e9be5,chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java,4ddf1150_88a6e516_before.java,4ddf1150_88a6e516_after.java,ChromeTabbedActivity::handleBackPressed,True,True
73,343e0792_12916045,2171.0,"> just want to make sure that you really want to delete this tab in such a case.

Yes, I would intend for the tab to be closed in that case. That's what currently happens if the tab is created from the New Tab Page feed.

> StartSurfaceUserData.setKeepTab() is called when user taps either home button or tab switcher button on the tab. It distinguishes the cases that tapping the back button directly after opening the tab from the cases that user does multiple other steps. Wdyt?

I see, sounds like I should check ""KeepTab"" before closing the tab.",2169.0,2171.0,"[{'ab': ['// Copyright 2015 The Chromium Authors. All rights reserved.', '// Use of this source code is governed by a BSD-style license that can be', '// found in the LICENSE file.', '', 'package org.chromium.chrome.browser;', '', 'import android.annotation.TargetApi;', 'import android.app.ActivityManager;', 'import android.content.ComponentName;', 'import android.content.Context;', 'import android.content.Intent;', 'import android.content.pm.ApplicationInfo;', 'import android.content.pm.ShortcutManager;', 'import android.os.Build;', 'import android.os.Bundle;', 'import android.os.SystemClock;', 'import android.text.TextUtils;', 'import android.text.format.DateUtils;', 'import android.util.Pair;', 'import android.view.KeyEvent;', 'import android.view.KeyboardShortcutGroup;', 'import android.view.Menu;', 'import android.view.View;', 'import android.view.View.OnClickListener;', 'import android.view.ViewConfiguration;', 'import android.view.ViewGroup;', 'import android.view.Window;', 'import android.view.WindowManager;', '', 'import androidx.annotation.IntDef;', 'import androidx.annotation.Nullable;', 'import androidx.annotation.VisibleForTesting;', 'import androidx.lifecycle.Lifecycle;', 'import androidx.lifecycle.LifecycleObserver;', 'import androidx.lifecycle.LifecycleRegistry;', '', 'import org.chromium.base.CallbackController;', 'import org.chromium.base.CommandLine;', 'import org.chromium.base.ContextUtils;', 'import org.chromium.base.IntentUtils;', 'import org.chromium.base.Log;', 'import org.chromium.base.MemoryPressureListener;', 'import org.chromium.base.ThreadUtils;', 'import org.chromium.base.TraceEvent;', 'import org.chromium.base.annotations.UsedByReflection;', 'import org.chromium.base.jank_tracker.JankTrackerImpl;', 'import org.chromium.base.library_loader.LibraryLoader;', 'import org.chromium.base.metrics.RecordHistogram;', 'import org.chromium.base.metrics.RecordUserAction;', 'import org.chromium.base.supplier.ObservableSupplierImpl;', 'import org.chromium.base.supplier.OneShotCallback;', 'import org.chromium.base.supplier.OneshotSupplier;', 'import org.chromium.base.supplier.OneshotSupplierImpl;', 'import org.chromium.base.supplier.Supplier;', 'import org.chromium.base.supplier.UnownedUserDataSupplier;', 'import org.chromium.base.task.PostTask;', 'import org.chromium.cc.input.BrowserControlsState;', 'import org.chromium.chrome.R;', 'import org.chromium.chrome.browser.IntentHandler.IntentHandlerDelegate;', 'import org.chromium.chrome.browser.IntentHandler.TabOpenType;', 'import org.chromium.chrome.browser.accessibility_tab_switcher.OverviewListLayout;', 'import org.chromium.chrome.browser.app.ChromeActivity;', 'import org.chromium.chrome.browser.app.metrics.LaunchCauseMetrics;', 'import org.chromium.chrome.browser.app.metrics.TabbedActivityLaunchCauseMetrics;', 'import org.chromium.chrome.browser.app.tabmodel.AsyncTabParamsManagerSingleton;', 'import org.chromium.chrome.browser.app.tabmodel.ChromeNextTabPolicySupplier;', 'import org.chromium.chrome.browser.app.tabmodel.TabModelOrchestrator;', 'import org.chromium.chrome.browser.app.tabmodel.TabWindowManagerSingleton;', 'import org.chromium.chrome.browser.app.tabmodel.TabbedModeTabModelOrchestrator;', 'import org.chromium.chrome.browser.bookmarks.BookmarkUtils;', 'import org.chromium.chrome.browser.browserservices.intents.WebappConstants;', 'import org.chromium.chrome.browser.compositor.CompositorViewHolder;', 'import org.chromium.chrome.browser.compositor.bottombar.ephemeraltab.EphemeralTabCoordinator;', 'import org.chromium.chrome.browser.compositor.layouts.Layout;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChrome;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChromePhone;', 'import org.chromium.chrome.browser.compositor.layouts.LayoutManagerChromeTablet;', 'import org.chromium.chrome.browser.compositor.layouts.OverviewModeBehavior;', 'import org.chromium.chrome.browser.compositor.layouts.OverviewModeController;', 'import org.chromium.chrome.browser.cookies.CookiesFetcher;', 'import org.chromium.chrome.browser.crypto.CipherFactory;', 'import org.chromium.chrome.browser.dependency_injection.ChromeActivityComponent;', 'import org.chromium.chrome.browser.device.DeviceClassManager;', 'import org.chromium.chrome.browser.dom_distiller.ReaderModeManager;', 'import org.chromium.chrome.browser.download.DownloadNotificationService;', 'import org.chromium.chrome.browser.download.DownloadOpenSource;', 'import org.chromium.chrome.browser.download.DownloadUtils;', 'import org.chromium.chrome.browser.feature_engagement.TrackerFactory;', 'import org.chromium.chrome.browser.feed.FeedSurfaceTracker;', 'import org.chromium.chrome.browser.firstrun.FirstRunSignInProcessor;', 'import org.chromium.chrome.browser.flags.ActivityType;', 'import org.chromium.chrome.browser.flags.CachedFeatureFlags;', 'import org.chromium.chrome.browser.flags.ChromeFeatureList;', 'import org.chromium.chrome.browser.flags.ChromeSwitches;', 'import org.chromium.chrome.browser.fonts.FontPreloader;', 'import org.chromium.chrome.browser.gesturenav.NavigationSheet;', 'import org.chromium.chrome.browser.homepage.HomepageManager;', 'import org.chromium.chrome.browser.incognito.IncognitoNotificationManager;', 'import org.chromium.chrome.browser.incognito.IncognitoNotificationPresenceController;', 'import org.chromium.chrome.browser.incognito.IncognitoProfileDestroyer;', 'import org.chromium.chrome.browser.incognito.IncognitoStartup;', 'import org.chromium.chrome.browser.incognito.IncognitoTabLauncher;', 'import org.chromium.chrome.browser.incognito.IncognitoTabSnapshotController;', 'import org.chromium.chrome.browser.incognito.IncognitoUtils;', 'import org.chromium.chrome.browser.infobar.DataReductionPromoInfoBar;', 'import org.chromium.chrome.browser.infobar.SyncErrorInfoBar;', 'import org.chromium.chrome.browser.layouts.LayoutStateProvider;', 'import org.chromium.chrome.browser.lifecycle.ActivityLifecycleDispatcher;', 'import org.chromium.chrome.browser.locale.LocaleManager;', 'import org.chromium.chrome.browser.metrics.AndroidSessionDurationsServiceState;', 'import org.chromium.chrome.browser.metrics.LaunchMetrics;', 'import org.chromium.chrome.browser.metrics.MainIntentBehaviorMetrics;', 'import org.chromium.chrome.browser.modaldialog.ChromeTabModalPresenter;', 'import org.chromium.chrome.browser.modaldialog.TabModalLifetimeHandler;', 'import org.chromium.chrome.browser.multiwindow.MultiInstanceChromeTabbedActivity;', 'import org.chromium.chrome.browser.multiwindow.MultiInstanceManager;', 'import org.chromium.chrome.browser.multiwindow.MultiWindowUtils;', 'import org.chromium.chrome.browser.native_page.NativePageAssassin;', 'import org.chromium.chrome.browser.navigation_predictor.NavigationPredictorBridge;', 'import org.chromium.chrome.browser.night_mode.WebContentsDarkModeController;', 'import org.chromium.chrome.browser.ntp.NewTabPageLaunchOrigin;', 'import org.chromium.chrome.browser.ntp.NewTabPageUma;', 'import org.chromium.chrome.browser.ntp.NewTabPageUtils;', 'import org.chromium.chrome.browser.omnibox.OmniboxFocusReason;', 'import org.chromium.chrome.browser.paint_preview.StartupPaintPreviewHelper;', 'import org.chromium.chrome.browser.paint_preview.StartupPaintPreviewHelperSupplier;', 'import org.chromium.chrome.browser.partnercustomizations.PartnerBrowserCustomizations;', 'import org.chromium.chrome.browser.preferences.ChromePreferenceKeys;', 'import org.chromium.chrome.browser.profiles.OTRProfileID;', 'import org.chromium.chrome.browser.profiles.Profile;', 'import org.chromium.chrome.browser.profiles.ProfileManager;', 'import org.chromium.chrome.browser.reengagement.ReengagementNotificationController;', 'import org.chromium.chrome.browser.search_engines.SearchEngineChoiceNotification;', 'import org.chromium.chrome.browser.settings.SettingsLauncherImpl;', 'import org.chromium.chrome.browser.share.send_tab_to_self.SendTabToSelfAndroidBridge;', 'import org.chromium.chrome.browser.suggestions.SuggestionsMetrics;', 'import org.chromium.chrome.browser.survey.ChromeSurveyController;', 'import org.chromium.chrome.browser.sync.ui.SyncErrorMessage;', 'import org.chromium.chrome.browser.sync.ui.SyncErrorPromptUtils;', 'import org.chromium.chrome.browser.tab.RedirectHandlerTabHelper;', 'import org.chromium.chrome.browser.tab.Tab;', 'import org.chromium.chrome.browser.tab.TabAssociatedApp;', 'import org.chromium.chrome.browser.tab.TabCreationState;', 'import org.chromium.chrome.browser.tab.TabDelegateFactory;', 'import org.chromium.chrome.browser.tab.TabLaunchType;', 'import org.chromium.chrome.browser.tab.TabSelectionType;', 'import org.chromium.chrome.browser.tab.state.CriticalPersistedTabData;', 'import org.chromium.chrome.browser.tabbed_mode.TabbedAppMenuPropertiesDelegate;', 'import org.chromium.chrome.browser.tabbed_mode.TabbedRootUiCoordinator;', 'import org.chromium.chrome.browser.tabmodel.ChromeTabCreator;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHost;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHostRegistry;', 'import org.chromium.chrome.browser.tabmodel.IncognitoTabHostUtils;', 'import org.chromium.chrome.browser.tabmodel.NextTabPolicy.NextTabPolicySupplier;', 'import org.chromium.chrome.browser.tabmodel.TabModel;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelector;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorBase;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorTabModelObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelSelectorTabObserver;', 'import org.chromium.chrome.browser.tabmodel.TabModelUtils;', 'import org.chromium.chrome.browser.tabmodel.TabWindowManager;', 'import org.chromium.chrome.browser.tasks.ConditionalTabStripUtils;', 'import org.chromium.chrome.browser.tasks.EngagementTimeUtil;', 'import org.chromium.chrome.browser.tasks.JourneyManager;', 'import org.chromium.chrome.browser.tasks.ReturnToChromeExperimentsUtil;', 'import org.chromium.chrome.browser.tasks.TasksUma;', 'import org.chromium.chrome.browser.tasks.tab_management.TabGroupUi;', 'import org.chromium.chrome.browser.tasks.tab_management.TabManagementDelegate;', 'import org.chromium.chrome.browser.tasks.tab_management.TabManagementModuleProvider;', 'import org.chromium.chrome.browser.tasks.tab_management.TabUiFeatureUtilities;', 'import org.chromium.chrome.browser.toolbar.ToolbarButtonInProductHelpController;', 'import org.chromium.chrome.browser.toolbar.ToolbarIntentMetadata;', 'import org.chromium.chrome.browser.toolbar.ToolbarManager;', 'import org.chromium.chrome.browser.toolbar.top.ToolbarControlContainer;', 'import org.chromium.chrome.browser.translate.TranslateIntentHandler;', 'import org.chromium.chrome.browser.ui.AppLaunchDrawBlocker;', 'import org.chromium.chrome.browser.ui.RootUiCoordinator;', 'import org.chromium.chrome.browser.ui.TabObscuringHandler;', 'import org.chromium.chrome.browser.ui.appmenu.AppMenuPropertiesDelegate;', 'import org.chromium.chrome.browser.undo_tab_close_snackbar.UndoBarController;', 'import org.chromium.chrome.browser.usage_stats.UsageStatsService;', 'import org.chromium.chrome.browser.util.ChromeAccessibilityUtil;', 'import org.chromium.chrome.browser.vr.VrModuleProvider;', 'import org.chromium.chrome.features.start_surface.StartSurface;', 'import org.chromium.chrome.features.start_surface.StartSurfaceConfiguration;', 'import org.chromium.chrome.features.start_surface.StartSurfaceState;', 'import org.chromium.chrome.features.start_surface.StartSurfaceUserData;', 'import org.chromium.components.browser_ui.settings.SettingsLauncher;', 'import org.chromium.components.browser_ui.util.BrowserControlsVisibilityDelegate;', 'import org.chromium.components.browser_ui.util.ComposedBrowserControlsVisibilityDelegate;', 'import org.chromium.components.embedder_support.util.UrlConstants;', 'import org.chromium.components.embedder_support.util.UrlUtilities;', 'import org.chromium.components.feature_engagement.EventConstants;', 'import org.chromium.components.messages.MessageDispatcherProvider;', 'import org.chromium.components.profile_metrics.BrowserProfileType;', 'import org.chromium.components.webapps.ShortcutSource;', 'import org.chromium.content_public.browser.LoadUrlParams;', 'import org.chromium.content_public.browser.NavigationHandle;', 'import org.chromium.content_public.browser.RenderFrameHost;', 'import org.chromium.content_public.browser.UiThreadTaskTraits;', 'import org.chromium.content_public.browser.WebContents;', 'import org.chromium.content_public.browser.WebContentsAccessibility;', 'import org.chromium.content_public.common.ContentSwitches;', 'import org.chromium.ui.base.PageTransition;', 'import org.chromium.ui.modaldialog.ModalDialogManager;', 'import org.chromium.ui.widget.Toast;', '', 'import java.lang.annotation.Retention;', 'import java.lang.annotation.RetentionPolicy;', 'import java.util.HashSet;', 'import java.util.List;', 'import java.util.Locale;', '', '/**', ' * This is the main activity for ChromeMobile when not running in document mode.  All the tabs', ' * are accessible via a chrome specific tab switching UI.', ' */', 'public class ChromeTabbedActivity extends ChromeActivity<ChromeActivityComponent>', '        implements ChromeAccessibilityUtil.Observer {', '    private static final String TAG = ""ChromeTabbedActivity"";', '', '    private static final String HELP_URL_PREFIX = ""https://support.google.com/chrome/"";', '', '    protected static final String WINDOW_INDEX = ""window_index"";', '', '    private static final String IS_INCOGNITO_SELECTED = ""is_incognito_selected"";', '', '    private static final int INVALID_WINDOW_ID = TabWindowManager.INVALID_WINDOW_INDEX;', '', '    // How long to delay closing the current tab when our app is minimized.  Have to delay this', ""    // so that we don't show the contents of the next tab while minimizing."", '    private static final long CLOSE_TAB_ON_MINIMIZE_DELAY_MS = 500;', '', '    // Maximum delay for initial tab creation. This is for homepage and NTP, not previous tabs', '    // restore. This is needed because we do not know when reading PartnerBrowserCustomizations', '    // provider will be finished.', '    private static final int INITIAL_TAB_CREATION_TIMEOUT_MS = 500;', '', '    /**', '     * Sending an intent with this action to Chrome will cause it to close all tabs', '     * (iff the --enable-test-intents command line flag is set). If a URL is supplied in the', '     * intent data, this will be loaded and unaffected by the close all action.', '     */', '    private static final String ACTION_CLOSE_TABS =', '            ""com.google.android.apps.chrome.ACTION_CLOSE_TABS"";', '', '    @VisibleForTesting', '    public static final String STARTUP_UMA_HISTOGRAM_SUFFIX = "".Tabbed"";', '', '    // Name of the ChromeTabbedActivity alias that handles MAIN intents.', '    public static final String MAIN_LAUNCHER_ACTIVITY_NAME = ""com.google.android.apps.chrome.Main"";', '', '    public static final SettingsLauncher SETTINGS_LAUNCHER = new SettingsLauncherImpl();', '', '    public static final HashSet<String> TABBED_MODE_COMPONENT_NAMES = new HashSet<String>() {', '        {', '            add(ChromeTabbedActivity.class.getName());', '            add(MultiInstanceChromeTabbedActivity.class.getName());', '            add(ChromeTabbedActivity2.class.getName());', '            add(MAIN_LAUNCHER_ACTIVITY_NAME);', '        }', '    };', '', '    /**', '     * Identifies a histogram to use in {@link #maybeDispatchExplicitMainViewIntent(Intent, int)}.', '     */', '    @IntDef({DispatchedBy.ON_CREATE, DispatchedBy.ON_NEW_INTENT})', '    @Retention(RetentionPolicy.SOURCE)', '    private @interface DispatchedBy {', '        int ON_CREATE = 1;', '        int ON_NEW_INTENT = 2;', '    }', '', '    // Count histogram used to track number of tabs when we show the Overview on Return to Chrome.', '    private static final String TAB_COUNT_ON_RETURN = ""Tabs.TabCountOnStartScreenShown"";', '', '    private final MainIntentBehaviorMetrics mMainIntentMetrics;', '    private @Nullable MultiInstanceManager mMultiInstanceManager;', '', '    private UndoBarController mUndoBarPopupController;', '', '    private LayoutManagerChrome mLayoutManager;', '', '    private ViewGroup mContentContainer;', '', '    private ToolbarControlContainer mControlContainer;', '', '    private TabbedModeTabModelOrchestrator mTabModelOrchestrator;', '    private TabModelSelectorBase mTabModelSelector;', '    private TabModelSelectorTabObserver mTabModelSelectorTabObserver;', '    private TabModelSelectorTabModelObserver mTabModelObserver;', '', '    private BrowserControlsVisibilityDelegate mVrBrowserControlsVisibilityDelegate;', '    private TabModalLifetimeHandler mTabModalHandler;', '', '    private boolean mUIWithNativeInitialized;', '', '    private Boolean mIsAccessibilityTabSwitcherEnabled;', '', '    private LocaleManager mLocaleManager;', '', '    private AppIndexingUtil mAppIndexingUtil;', '', '    private Runnable mShowHistoryRunnable;', '', '    private CompositorViewHolder mCompositorViewHolder;', '    private OverviewListLayout mOverviewListLayout;', '    /**', '     * Keeps track of whether or not a specific tab was created based on the startup intent.', '     */', '    private boolean mCreatedTabOnStartup;', '', '    // Whether or not the initial tab is being created.', '    private boolean mPendingInitialTabCreation;', '', '    // Whether {@link setInitialOverviewState()} has been called within the current onStart/onStop', '    // session.', '    private boolean mHasDeterminedOverviewStateForCurrentSession;', '    /**', '     *  Keeps track of the pref for the last time since this activity was stopped.', '     */', '    private ChromeInactivityTracker mInactivityTracker;', '', ""    // This is the cached value of mIntentHandler#shouldIgnoreIntent and shouldn't be read directly."", '    // Use #shouldIgnoreIntent instead.', '    private Boolean mShouldIgnoreIntent;', '    /*', '     *  Listens to FrameMetrics and records jank metrics.', '     */', '    private JankTrackerImpl mJankTracker;', '', '    // Supplier for a dependency to inform about the type of intent used to launch Chrome.', '    private OneshotSupplierImpl<ToolbarIntentMetadata> mIntentMetadataOneshotSupplier =', '            new OneshotSupplierImpl<>();', '', '    // Time at which an intent was received and handled.', '    private long mIntentHandlingTimeMs;', '', '    /**', '     * Whether the StartSurface is shown when Chrome is launched.', '     */', '    private boolean mOverviewShownOnStart;', '', '    private NextTabPolicySupplier mNextTabPolicySupplier;', '', '    private final UnownedUserDataSupplier<StartupPaintPreviewHelper>', '            mStartupPaintPreviewHelperSupplier = new StartupPaintPreviewHelperSupplier();', '', '    private final OneshotSupplierImpl<LayoutStateProvider> mLayoutStateProviderOneshotSupplier =', '            new OneshotSupplierImpl<>();', '    // TODO(crbug.com/1108496): Removed after all usages has been migrated to LayoutStateProvider.', '    private final OneshotSupplierImpl<OverviewModeBehavior> mOverviewModeBehaviorSupplier =', '            new OneshotSupplierImpl<>();', '    private OverviewModeController mOverviewModeController;', '', '    private ObservableSupplierImpl<EphemeralTabCoordinator> mEphemeralTabCoordinatorSupplier =', '            new ObservableSupplierImpl<>();', '    private final OneshotSupplierImpl<StartSurface> mStartSurfaceSupplier =', '            new OneshotSupplierImpl<>();', '    private ObservableSupplierImpl<Tab> mStartSurfaceParentTabSupplier =', '            new ObservableSupplierImpl<>();', '', '    private CallbackController mCallbackController = new CallbackController();', '    private TabbedModeTabDelegateFactory mTabDelegateFactory;', '', '    private final AppLaunchDrawBlocker mAppLaunchDrawBlocker;', '', '    // ID assigned to each ChromeTabbedActivity instance in Android S+ where multi-instance feature', '    // is supported. This can be explicitly set in the incoming Intent or internally assigned.', '    private int mWindowId;', '', '    private final IncognitoTabHost mIncognitoTabHost = new IncognitoTabHost() {', '        @Override', '        public boolean hasIncognitoTabs() {', '            return getTabModelSelector().getModel(true).getCount() > 0;', '        }', '', '        @Override', '        public void closeAllIncognitoTabs() {', '            if (isActivityFinishingOrDestroyed()) return;', '', '            // If the tabbed activity has not yet initialized, then finish the activity to avoid', '            // timing issues with clearing the incognito tab state in the background.', '            if (!areTabModelsInitialized() || !didFinishNativeInitialization()) {', '                finish();', '                return;', '            }', '', '            getTabModelSelector().getModel(true).closeAllTabs(false, false);', '        }', '', '        @Override', '        public boolean isActiveModel() {', '            return getTabModelSelector().getModel(true).isActiveModel();', '        }', '    };', '', '    /**', '     * This class is used to warm up the chrome split ClassLoader. See SplitChromeApplication for', '     * more info', '     */', '    @UsedByReflection(""SplitChromeApplication.java"")', '    public static class Preload extends ChromeTabbedActivity {', '        private LifecycleRegistry mLifecycleRegistry;', '', '        @UsedByReflection(""SplitChromeApplication.java"")', '        public Preload() {}', '', '        @Override', '        public Lifecycle getLifecycle() {', '            if (mLifecycleRegistry == null) {', '                // LifecycleRegistry normally enforces it is called on the main thread, but this', '                // class will be preloaded in a background thread. The only method that gets called', '                // in the activity constructor is addObserver(), so just override that.', '                mLifecycleRegistry = new LifecycleRegistry(null) {', '                    @Override', '                    public void addObserver(LifecycleObserver observer) {}', '                };', '            }', '            return mLifecycleRegistry;', '        }', '    }', '', '    /**', '     * Specify the proper non-.Main-aliased Chrome Activity for the given component.', '     *', '     * @param intent The intent to set the component for.', '     * @param component The client generated component to be validated.', '     */', '    public static void setNonAliasedComponent(Intent intent, ComponentName component) {', '        assert component != null;', '        Context appContext = ContextUtils.getApplicationContext();', '        if (!TextUtils.equals(component.getPackageName(), appContext.getPackageName())) {', '            return;', '        }', '        if (component.getClassName() != null', '                && TextUtils.equals(component.getClassName(),', '                        ChromeTabbedActivity.MAIN_LAUNCHER_ACTIVITY_NAME)) {', '            // Keep in sync with the activities that the .Main alias points to in', '            // AndroidManifest.xml.', '            intent.setClass(appContext, ChromeTabbedActivity.class);', '        } else {', '            intent.setComponent(component);', '        }', '    }', '', '    /**', '     * Constructs a ChromeTabbedActivity.', '     */', '    public ChromeTabbedActivity() {', '        mMainIntentMetrics = new MainIntentBehaviorMetrics();', '', '        // AppLaunchDrawBlocker may block drawing the Activity content until the initial tab is', '        // available.', '        // clang-format off', '        mAppLaunchDrawBlocker = new AppLaunchDrawBlocker(getLifecycleDispatcher(),', '                () -> findViewById(android.R.id.content),', '                this::getIntent, this::shouldIgnoreIntent, this::isTablet,', '                this::shouldShowOverviewPageOnStart);', '        // clang-format on', '    }', '', '    @Override', '    protected void onPreCreate() {', '        super.onPreCreate();', '        mMultiInstanceManager = MultiInstanceManager.create(this, getTabModelOrchestratorSupplier(),', '                getMultiWindowModeStateDispatcher(), getLifecycleDispatcher(),', '                getModalDialogManagerSupplier(), this);', '    }', '', '    @Override', '    protected @LaunchIntentDispatcher.Action int maybeDispatchLaunchIntent(', '            Intent intent, Bundle savedInstanceState) {', '        // Detect if incoming intent is a result of Chrome recreating itself. For now, restrict this', ""        // path to reparenting to ensure the launching logic isn't disrupted."", ""        // TODO(crbug.com/1065491): Unlock this codepath for all incoming intents once it's"", '        // confirmed working and stable.', '        if (savedInstanceState != null', '                && AsyncTabParamsManagerSingleton.getInstance().hasParamsWithTabToReparent()) {', '            return LaunchIntentDispatcher.Action.CONTINUE;', '        }', '', '        if (getClass().equals(ChromeTabbedActivity.class)', '                && Intent.ACTION_MAIN.equals(intent.getAction())) {', '            // Call dispatchToTabbedActivity() for MAIN intents to activate proper multi-window', '            // TabbedActivity (i.e. if CTA2 is currently running and Chrome is started, CTA2', ""            // should be brought to front). Don't call dispatchToTabbedActivity() for non-MAIN"", '            // intents to avoid breaking cases where CTA is started explicitly (e.g. to handle', ""            // 'Move to other window' command from CTA2)."", '            return LaunchIntentDispatcher.dispatchToTabbedActivity(this, intent);', '        }', '        @LaunchIntentDispatcher.Action', '        int action = maybeDispatchExplicitMainViewIntent(intent, DispatchedBy.ON_CREATE);', '        if (action != LaunchIntentDispatcher.Action.CONTINUE) {', '            return action;', '        }', '        return super.maybeDispatchLaunchIntent(intent, savedInstanceState);', '    }', '', '    // We know of at least one app that explicitly specifies .Main activity in custom tab', ""    // intents. The app shouldn't be doing that, but until it's updated, we need to support"", '    // such use case.', '    //', '    // This method attempts to treat VIEW intents explicitly sent to .Main as custom tab', '    // intents, and dispatch them accordingly. If the intent was not dispatched, the method', '    // returns Action.CONTINUE.', '    //', '    // The method also updates the supplied boolean histogram with the dispatching result,', '    // but only if the intent is a VIEW intent sent explicitly to .Main activity.', '    private @LaunchIntentDispatcher.Action int maybeDispatchExplicitMainViewIntent(', '            Intent intent, @DispatchedBy int dispatchedBy) {', ""        // The first check ensures that this is .Main activity alias (we can't check exactly, but"", '        // this gets us sufficiently close).', '        if (getClass().equals(ChromeTabbedActivity.class)', '                && Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getComponent() != null', '                && MAIN_LAUNCHER_ACTIVITY_NAME.equals(intent.getComponent().getClassName())) {', '            @LaunchIntentDispatcher.Action', '            int action = LaunchIntentDispatcher.dispatchToCustomTabActivity(this, intent);', '            switch (dispatchedBy) {', '                case DispatchedBy.ON_CREATE:', '                    RecordHistogram.recordBooleanHistogram(', '                            ""Android.MainActivity.ExplicitMainViewIntentDispatched.OnCreate"",', '                            action != LaunchIntentDispatcher.Action.CONTINUE);', '                    break;', '                case DispatchedBy.ON_NEW_INTENT:', '', '                    RecordHistogram.recordBooleanHistogram(', '                            ""Android.MainActivity.ExplicitMainViewIntentDispatched.OnNewIntent"",', '                            action != LaunchIntentDispatcher.Action.CONTINUE);', '                    break;', '                default:', '                    assert false : ""Unknown dispatchedBy value "" + dispatchedBy;', '            }', '            if (action == LaunchIntentDispatcher.Action.CONTINUE) {', '                // Intent was not dispatched, record its source.', '                @IntentHandler.ExternalAppId', '                int externalId = IntentHandler.determineExternalIntentSource(intent);', '                RecordHistogram.recordEnumeratedHistogram(', '                        ""Android.MainActivity.UndispatchedExplicitMainViewIntentSource"", externalId,', '                        IntentHandler.ExternalAppId.NUM_ENTRIES);', '', ""                // Crash if intent came from us, but only in debug builds and only if we weren't"", ""                // explicitly told not to. Hopefully we'll get enough reports to find where"", '                // these intents come from.', '                if (externalId == IntentHandler.ExternalAppId.CHROME', '                        && 0 != (getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE)', '                        && !CommandLine.getInstance().hasSwitch(', '                                ChromeSwitches.DONT_CRASH_ON_VIEW_MAIN_INTENTS)) {', '                    String intentInfo = intent.toString();', '                    Bundle extras = intent.getExtras();', '                    if (extras != null) {', '                        intentInfo +=', '                                "", extras.keySet = ["" + TextUtils.join("", "", extras.keySet()) + ""]"";', '                    }', '                    String message = String.format((Locale) null,', '                            ""VIEW intent sent to .Main activity alias was not dispatched. PLEASE ""', '                                    + ""report the following info to crbug.com/789732: \\""%s\\"". Use ""', '                                    + ""--%s flag to disable this check."",', '                            intentInfo, ChromeSwitches.DONT_CRASH_ON_VIEW_MAIN_INTENTS);', '                    throw new IllegalStateException(message);', '                }', '            }', '            return action;', '        }', '        return LaunchIntentDispatcher.Action.CONTINUE;', '    }', '', '    @Override', '    public void initializeCompositor() {', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.initializeCompositor"");', '            super.initializeCompositor();', '', '            // LocaleManager can only function after the native library is loaded.', '            mLocaleManager = LocaleManager.getInstance();', '            mLocaleManager.setSettingsLauncher(SETTINGS_LAUNCHER);', '            mLocaleManager.showSearchEnginePromoIfNeeded(this, null);', '', '            mTabModelOrchestrator.onNativeLibraryReady(getTabContentManager());', '', '            mTabModelObserver = new TabModelSelectorTabModelObserver(mTabModelSelector) {', '                @Override', '                public void didCloseTab(int tabId, boolean incognito) {', '                    closeIfNoTabsAndHomepageEnabled(false);', '                }', '', '                @Override', '                public void tabPendingClosure(Tab tab) {', '                    closeIfNoTabsAndHomepageEnabled(true);', '                }', '', '                @Override', '                public void tabRemoved(Tab tab) {', '                    closeIfNoTabsAndHomepageEnabled(false);', '                }', '', '                private void closeIfNoTabsAndHomepageEnabled(boolean isPendingClosure) {', '                    if (getTabModelSelector().getTotalTabCount() == 0) {', '                        // If the last tab is closed, and homepage is enabled, then exit Chrome.', '                        if (HomepageManager.shouldCloseAppWithZeroTabs()) {', '                            finish();', '                        } else if (isPendingClosure) {', '                            NewTabPageUma.recordNTPImpression(', '                                    NewTabPageUma.NTP_IMPESSION_POTENTIAL_NOTAB);', '                        }', '                    }', '', '                    // TODO(960196) : remove this when the associated bug fix. This is a band-aid', '                    //  fix for TabGrid and closing tabs with TabGroupUi.', '                    //  If one of the following is true, then exit Chrome when TabGroupsAndroid is', '                    //  enabled, and tab switcher is not shown:', '                    //   1. If the very last tab is closed.', '                    //   2. If normal tab model is selected and no normal tabs.', '                    if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(ChromeTabbedActivity.this)', '                            && !mOverviewModeController.overviewVisible()) {', '                        if (getTabModelSelector().getTotalTabCount() == 0', '                                || (!getTabModelSelector().isIncognitoSelected()', '                                        && getTabModelSelector().getModel(false).getCount() == 0)) {', '                            finish();', '                        }', '                    }', '                }', '', '                @Override', '                public void didAddTab(', '                        Tab tab, @TabLaunchType int type, @TabCreationState int creationState) {', '                    if (type == TabLaunchType.FROM_LONGPRESS_BACKGROUND', '                            && !DeviceClassManager.enableAnimations()) {', '                        Toast.makeText(ChromeTabbedActivity.this, R.string.open_in_new_tab_toast,', '                                     Toast.LENGTH_SHORT)', '                                .show();', '                    }', '                }', '', '                @Override', '                public void multipleTabsPendingClosure(List<Tab> tabs, boolean isAllTabs) {', '                    if (!isAllTabs) return;', '                    NewTabPageUma.recordNTPImpression(NewTabPageUma.NTP_IMPESSION_POTENTIAL_NOTAB);', '                }', '            };', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.initializeCompositor"");', '        }', '    }', '', '    private void refreshSignIn() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.refreshSignIn"")) {', '            FirstRunSignInProcessor.start(this);', '        }', '    }', '', '    private void setupCompositorContentPreNativeForPhone() {', '        if (isTablet()) return;', '', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPreNativeForPhone"")) {', '            CompositorViewHolder compositorViewHolder = getCompositorViewHolderSupplier().get();', '', '            // TODO(1169205): Remove all GTS enabled checks after M5 is default.', '            if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(this)) {', '                TabManagementDelegate tabManagementDelegate =', '                        TabManagementModuleProvider.getDelegate();', '                if (tabManagementDelegate != null) {', '                    StartSurface startSurface = tabManagementDelegate.createStartSurface(this,', '                            mRootUiCoordinator.getScrimCoordinator(),', '                            mRootUiCoordinator.getBottomSheetController(), mStartSurfaceSupplier,', '                            mStartSurfaceParentTabSupplier, hadWarmStart(), getWindowAndroid(),', '                            compositorViewHolder, compositorViewHolder::getDynamicResourceLoader,', '                            getTabModelSelector(), getBrowserControlsManager(),', '                            getSnackbarManager(), getShareDelegateSupplier(),', '                            getToolbarManager()::getOmniboxStub, getTabContentManager(),', '                            getModalDialogManager(),', '                            /* chromeActivityNativeDelegate= */ this, getLifecycleDispatcher(),', '                            getTabCreatorManagerSupplier().get(),', '                            getMenuOrKeyboardActionController(),', '                            getMultiWindowModeStateDispatcher(), mJankTracker,', '                            getToolbarManager()::getToolbar);', '                }', '            }', '', '            // clang-format off', '            mLayoutManager = new LayoutManagerChromePhone(compositorViewHolder, mContentContainer,', '                    mStartSurfaceSupplier.get(), getTabContentManagerSupplier(),', '                    () -> {', '                        if (!getCompositorViewHolderSupplier().hasValue()) return null;', '                        return getCompositorViewHolderSupplier().get().getLayerTitleCache();', '                    },', '                    mOverviewModeBehaviorSupplier,', '                    mRootUiCoordinator::getTopUiThemeColorProvider, mJankTracker);', '            mLayoutStateProviderOneshotSupplier.set(mLayoutManager);', '            // clang-format on', '            mOverviewModeController = mLayoutManager;', '        }', '    }', '', '    private void setupCompositorContentPreNativeForTablet() {', '        if (!isTablet()) return;', '', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPreNativeForTablet"")) {', '            // clang-format off', '            mLayoutManager = new LayoutManagerChromeTablet(getCompositorViewHolderSupplier().get(),', '                    mContentContainer, getTabContentManagerSupplier(),', '                    () -> {', '                        if (!getCompositorViewHolderSupplier().hasValue()) return null;', '                        return getCompositorViewHolderSupplier().get().getLayerTitleCache();', '                    },', '                    mOverviewModeBehaviorSupplier,', '                    mRootUiCoordinator::getTopUiThemeColorProvider, mJankTracker);', '            mLayoutStateProviderOneshotSupplier.set(mLayoutManager);', '            // clang-format on', '            mOverviewModeController = mLayoutManager;', '        }', '    }', '', '    private void setupCompositorContentPostNative() {', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.setupCompositorContentPostNative"")) {', '            if (!isLayoutManagerCreated()) {', '                if (isTablet()) {', '                    setupCompositorContentPreNativeForTablet();', '                } else {', '                    setupCompositorContentPreNativeForPhone();', '                }', '            }', '', '            mLayoutManager.setEnableAnimations(DeviceClassManager.enableAnimations());', '', '            // TODO(yusufo): get rid of findViewById(R.id.url_bar).', '            initializeCompositorContent(mLayoutManager, findViewById(R.id.url_bar),', '                    mContentContainer, mControlContainer);', '        }', '    }', '', '    private boolean isLayoutManagerCreated() {', '        return mLayoutManager != null;', '    }', '', '    private void initializeToolbarManager() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.initializeToolbarManager"")) {', '            mUndoBarPopupController.initialize();', '', '            OnClickListener tabSwitcherClickHandler = v -> {', '                if (ChromeFeatureList.isEnabled(ChromeFeatureList.TOOLBAR_IPH_ANDROID)) {', '                    Profile profile = mTabModelProfileSupplier.get();', '                    if (profile != null) {', '                        TrackerFactory.getTrackerForProfile(profile).notifyEvent(', '                                EventConstants.TAB_SWITCHER_BUTTON_CLICKED);', '                    }', '                }', '', '                if (getFullscreenManager().getPersistentFullscreenMode()) {', '                    return;', '                }', '', '                if (isInOverviewMode()', '                        && !ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '                    hideOverview();', '                } else {', '                    showOverview(StartSurfaceState.SHOWING_TABSWITCHER);', '                }', '            };', '            OnClickListener newTabClickHandler = v -> {', '                getTabModelSelector().getModel(false).commitAllTabClosures();', '                // This assumes that the keyboard can not be seen at the same time as the', '                // newtab button on the toolbar.', '                getCurrentTabCreator().launchNTP();', '                mLocaleManager.showSearchEnginePromoIfNeeded(ChromeTabbedActivity.this, null);', '                if (getTabModelSelector().isIncognitoSelected()) {', '                    RecordUserAction.record(""MobileToolbarStackViewNewIncognitoTab"");', '                } else {', '                    RecordUserAction.record(""MobileToolbarStackViewNewTab"");', '                }', '                RecordUserAction.record(""MobileTopToolbarNewTabButton"");', '', '                RecordUserAction.record(""MobileNewTabOpened"");', '                ReturnToChromeExperimentsUtil.onNewTabOpened();', '            };', '            OnClickListener bookmarkClickHandler = v -> addOrEditBookmark(getActivityTab());', '', '            Supplier<Boolean> showStartSurfaceSupplier = () -> {', '                // If incognito is selected, tapping the home button stays on the current incognito', '                // tab.', '                if (ReturnToChromeExperimentsUtil.shouldShowStartSurfaceAsTheHomePageOnPhone(', '                            this, isTablet())', '                        && !mTabModelSelector.isIncognitoSelected()) {', '                    StartSurfaceUserData.setKeepTab(getActivityTab(), true);', '                    showOverview(StartSurfaceState.SHOWING_HOMEPAGE);', '                    return true;', '                }', '                return false;', '            };', '', '            getToolbarManager().initializeWithNative(mLayoutManager, tabSwitcherClickHandler,', '                    newTabClickHandler, bookmarkClickHandler, null, showStartSurfaceSupplier);', '', '            if (!TabUiFeatureUtilities.supportInstantStart(isTablet(), this)) {', '                assert !(mOverviewModeController != null', '                        && mOverviewModeController.overviewVisible());', '            }', '        }', '    }', '', '    private void maybeCreateIncognitoTabSnapshotController() {', '        try (TraceEvent e = TraceEvent.scoped(', '                     ""ChromeTabbedActivity.maybeCreateIncognitoTabSnapshotController"")) {', '            if (!CommandLine.getInstance().hasSwitch(', '                        ChromeSwitches.ENABLE_INCOGNITO_SNAPSHOTS_IN_ANDROID_RECENTS)) {', '                IncognitoTabSnapshotController.createIncognitoTabSnapshotController(', '                        this, getWindow(), mLayoutManager, mTabModelSelector);', '            }', '', '            mUIWithNativeInitialized = true;', '            onAccessibilityTabSwitcherModeChanged();', '', '            // The dataset has already been created, we need to initialize our state.', '            mTabModelSelector.notifyChanged();', '', '            // Check for incognito tabs to handle the case where Chrome was swiped away in the', '            // background.', '            if (!IncognitoTabHostUtils.doIncognitoTabsExist()) {', '                IncognitoNotificationManager.dismissIncognitoNotification();', '                DownloadNotificationService.getInstance().cancelOffTheRecordDownloads();', '            }', '        }', '    }', '', '    private void maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.""', '                     + ""maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver"")) {', '            FeedSurfaceTracker.getInstance().startup();', '', '            if (UsageStatsService.isEnabled()) {', '                UsageStatsService.getInstance().createPageViewObserver(', '                        this, getActivityTabProvider(), getTabContentManagerSupplier());', '            }', '        }', '    }', '', '    private void initJourneyManager() {', '        assert mOverviewModeController != null;', '', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.initJourneyManager"")) {', '            if (ChromeFeatureList.isEnabled(ChromeFeatureList.TAB_ENGAGEMENT_REPORTING_ANDROID)) {', '                // The lifecycle of this object is managed by the lifecycle dispatcher.', '                new JourneyManager(getTabModelSelector(), getLifecycleDispatcher(),', '                        mOverviewModeController, new EngagementTimeUtil());', '            }', '        }', '    }', '', '    @Override', '    public void onNewIntent(Intent intent) {', ""        // The intent to use in maybeDispatchExplicitMainViewIntent(). We're explicitly"", '        // adding NEW_TASK flag to make sure backing from CCT brings up the caller activity,', '        // and not Chrome', '        Intent intentForDispatching = new Intent(intent);', '        intentForDispatching.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);', '        @LaunchIntentDispatcher.Action', '        int action = maybeDispatchExplicitMainViewIntent(', '                intentForDispatching, DispatchedBy.ON_NEW_INTENT);', '        if (action != LaunchIntentDispatcher.Action.CONTINUE) {', '            // Pressing back button in CCT should bring user to the caller activity.', '            moveTaskToBack(true);', '            // Intent was dispatched to CustomTabActivity, consume it.', '            return;', '        }', '', '        mIntentHandlingTimeMs = SystemClock.uptimeMillis();', '        super.onNewIntent(intent);', '    }', '', '    @Override', '    public void startNativeInitialization() {', '        try (TraceEvent e = TraceEvent.scoped(""ChromeTabbedActivity.startNativeInitialization"")) {', ""            // This is on the critical path so don't delay."", '            if (ChromeFeatureList.isEnabled(', '                        ChromeFeatureList.DARKEN_WEBSITES_CHECKBOX_IN_THEMES_SETTING)) {', '                WebContentsDarkModeController.createInstance();', '            }', '            setupCompositorContentPostNative();', '', ""            // All this initialization can be expensive so it's split into multiple tasks."", '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::refreshSignIn));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::initializeToolbarManager));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::maybeCreateIncognitoTabSnapshotController));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::onAccessibilityTabSwitcherModeChanged));', '', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(', '                            this::maybeGetFeedAppLifecycleAndMaybeCreatePageViewObserver));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::initJourneyManager));', '            PostTask.postTask(UiThreadTaskTraits.DEFAULT,', '                    mCallbackController.makeCancelable(this::finishNativeInitialization));', '            ChromeAccessibilityUtil.get().addObserver(this);', '        }', '    }', '', '    @Override', '    public void finishNativeInitialization() {', '        super.finishNativeInitialization();', '', '        // TODO(jinsukkim): Let these classes handle the registration by themselves.', '        mCompositorViewHolder = getCompositorViewHolderSupplier().get();', '        mOverviewListLayout = (OverviewListLayout) mLayoutManager.getOverviewListLayout();', '        getTabObscuringHandler().addObserver(mCompositorViewHolder);', '        getTabObscuringHandler().addObserver(mOverviewListLayout);', '', '        ChromeAccessibilityUtil.get().addObserver(mLayoutManager);', '        if (isTablet()) ChromeAccessibilityUtil.get().addObserver(mCompositorViewHolder);', '    }', '', '    @Override', '    public void onResumeWithNative() {', '        super.onResumeWithNative();', '', '        IncognitoStartup.onResumeWithNative(', '                getTabModelSelectorSupplier(), TABBED_MODE_COMPONENT_NAMES);', '', '        mLocaleManager.setSnackbarManager(getSnackbarManager());', '        mLocaleManager.startObservingPhoneChanges();', '', '        if (isWarmOnResume()) {', '            NavigationPredictorBridge.onActivityWarmResumed();', '        } else {', '            NavigationPredictorBridge.onColdStart();', '        }', '', '        // This call is not guarded by a feature flag.', '        SearchEngineChoiceNotification.handleSearchEngineChoice(', '                this, getSnackbarManager(), SETTINGS_LAUNCHER);', '', '        if (!isWarmOnResume()) {', '            SuggestionsMetrics.recordArticlesListVisible();', '        }', '    }', '', '    @Override', '    public void onPauseWithNative() {', '        mTabModelSelector.commitAllTabClosures();', '        CookiesFetcher.persistCookies();', '', '        mLocaleManager.setSnackbarManager(null);', '        mLocaleManager.stopObservingPhoneChanges();', '', '        NavigationPredictorBridge.onPause();', '', '        super.onPauseWithNative();', '    }', '', '    @Override', '    public void onStopWithNative() {', '        super.onStopWithNative();', '', '        mTabModelOrchestrator.saveState();', '        mHasDeterminedOverviewStateForCurrentSession = false;', '    }', '', '    @Override', '    public void onStartWithNative() {', '        mMainIntentMetrics.logLaunchBehavior();', '        super.onStartWithNative();', '', ""        // Don't call setInitialOverviewState if we're waiting for the tab's creation or we risk"", '        // showing a glimpse of the tab selector during start up.', '        if (!mPendingInitialTabCreation) {', '            setInitialOverviewState();', '        }', '', '        if (TabUiFeatureUtilities.isConditionalTabStripEnabled()', '                || ConditionalTabStripUtils.getOptOutIndicator()) {', '            ConditionalTabStripUtils.updateFeatureExpiration(', '                    mInactivityTracker.getLastBackgroundedTimeMs());', '        }', '', '        Bundle savedInstanceState = getSavedInstanceState();', '        if (savedInstanceState != null', '                && savedInstanceState.getBoolean(IS_INCOGNITO_SELECTED, false)) {', '            // This will be executed only once since SavedInstanceState will be reset a few lines', '            // later.', '            AndroidSessionDurationsServiceState.restoreNativeFromSerialized(savedInstanceState,', '                    getCurrentTabModel().getProfile().getPrimaryOTRProfile(', '                            /* createIfNeeded= */ true));', '        }', '', '        resetSavedInstanceState();', '        StartSurfaceConfiguration.addFeedVisibilityObserver();', '        BookmarkUtils.maybeExpireLastBookmarkLocationForReadLater(', '                mInactivityTracker.getTimeSinceLastBackgroundedMs());', '    }', '', '    @Override', '    public void onNewIntentWithNative(Intent intent) {', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.onNewIntentWithNative"");', '', '            super.onNewIntentWithNative(intent);', '            if (IntentUtils.isMainIntentFromLauncher(intent)) {', '                logMainIntentBehavior(intent);', '            }', '', '            if (CommandLine.getInstance().hasSwitch(ContentSwitches.ENABLE_TEST_INTENTS)) {', '                handleDebugIntent(intent);', '            }', '', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.onNewIntentWithNative"");', '        }', '    }', '', '    @Override', '    public @ActivityType int getActivityType() {', '        return ActivityType.TABBED;', '    }', '', '    @Override', '    public ChromeTabCreator getTabCreator(boolean incognito) {', '        return (ChromeTabCreator) super.getTabCreator(incognito);', '    }', '', '    @Override', '    public ChromeTabCreator getCurrentTabCreator() {', '        return (ChromeTabCreator) super.getCurrentTabCreator();', '    }', '', '    @Override', '    public OverviewModeBehavior getOverviewModeBehavior() {', '        return mOverviewModeController;', '    }', '', '    @Override', '    public @Nullable OneshotSupplier<OverviewModeBehavior> getOverviewModeBehaviorSupplier() {', '        return mOverviewModeBehaviorSupplier;', '    }', '', '    /**', '     * @return The toolbar button in-product help controller for this activity.', '     * TODO(pnoland, https://crbug.com/865801): remove this in favor', ""     *        of injecting the controller directly where it's needed."", '     */', '    public ToolbarButtonInProductHelpController getToolbarButtonInProductHelpController() {', '        return ((TabbedRootUiCoordinator) mRootUiCoordinator)', '                .getToolbarButtonInProductHelpController();', '    }', '', '    private void handleDebugIntent(Intent intent) {', '        if (ACTION_CLOSE_TABS.equals(intent.getAction())) {', '            getTabModelSelector().closeAllTabs();', '        } else if (MemoryPressureListener.handleDebugIntent(', '                           ChromeTabbedActivity.this, intent.getAction())) {', '            // Handled.', '        }', '    }', '', '    private void setTrackColdStartupMetrics(boolean shouldTrackColdStartupMetrics) {', '        assert getActivityTabStartupMetricsTracker() != null;', '', '        if (shouldTrackColdStartupMetrics) {', '            getActivityTabStartupMetricsTracker().trackStartupMetrics(STARTUP_UMA_HISTOGRAM_SUFFIX);', '        } else {', '            getActivityTabStartupMetricsTracker().cancelTrackingStartupMetrics();', '        }', '', '        // Paint Preview should follow the same logic as startup UMA histograms as the feature', '        // should only run on cold startup of Chrome when the user is unable to interact before', '        // entering a tab.', '        StartupPaintPreviewHelper.setShouldShowOnRestore(shouldTrackColdStartupMetrics);', '    }', '', '    private void setInitialOverviewState() {', '        if (mHasDeterminedOverviewStateForCurrentSession) return;', '', '        mHasDeterminedOverviewStateForCurrentSession = true;', '        boolean isOverviewVisible = mOverviewModeController.overviewVisible();', '', '        if (shouldRefreshAndShowOverview(isOverviewVisible)) {', '            if (getCurrentTabModel() != null) {', '                RecordHistogram.recordCountHistogram(', '                        TAB_COUNT_ON_RETURN, getCurrentTabModel().getCount());', '            }', '            if (TabUiFeatureUtilities.isGridTabSwitcherEnabled(this) && !isTablet()) {', '                mStartSurfaceSupplier.get().getController().enableRecordingFirstMeaningfulPaint(', '                        getOnCreateTimestampMs());', '            }', '            mOverviewShownOnStart = true;', '            // Cancel recording cold startup metrics if an overview is shown as they expect a tab to', '            // be the first thing shown after startup.', '            setTrackColdStartupMetrics(false);', '            showOverview(StartSurfaceState.SHOWING_START);', '            return;', '        }', '', '        if (getActivityTab() == null && !isOverviewVisible) {', '            mOverviewShownOnStart = true;', '            // Cancel recording cold startup metrics if an overview is shown as they expect a tab to', '            // be the first thing shown after startup.', '            setTrackColdStartupMetrics(false);', '            showOverview(StartSurfaceState.SHOWING_START);', '        }', '', '        if (IntentUtils.isMainIntentFromLauncher(getIntent())', '                && mOverviewModeController.overviewVisible()) {', '            RecordUserAction.record(""MobileStartup.UserEnteredTabSwitcher"");', '        }', '    }', '', '    private boolean shouldRefreshAndShowOverview(boolean isOverviewVisible) {', '        // If StartSurfaceConfiguration.NEW_SURFACE_FROM_HOME_BUTTON is turned on, MV tiles and', '        // carousels may be hidden before Chrome is brought to the background. If overview should be', '        // shown, no matter overview was already visible or not, we should call', '        // showOverview(StartSurfaceState.SHOWING_START) to show MV tiles and carousels again.', '        return shouldShowOverviewPageOnStart()', '                && (!isOverviewVisible', '                        || StartSurfaceConfiguration.shouldShowNewSurfaceFromHomeButton());', '    }', '', '    /**', '     * Returns whether grid Tab switcher or the Start surface should be shown at startup.', '     */', '    private boolean shouldShowOverviewPageOnStart() {', '        return ReturnToChromeExperimentsUtil.shouldShowOverviewPageOnStart(', '                this, getIntent(), getTabModelSelector(), mInactivityTracker);', '    }', '', '    private void logMainIntentBehavior(Intent intent) {', '        assert IntentUtils.isMainIntentFromLauncher(intent);', '        // TODO(tedchoc): We should cache the last visible time and reuse it to avoid different', '        //                values of this depending on when it is called after the activity was', '        //                shown.', '', '        // Temporary safety check to make sure none of this code runs if the feature is', '        // disabled.', '        if (ReengagementNotificationController.isEnabled()) {', '            if (mCallbackController != null) {', '                new OneShotCallback<>(', '                        mTabModelProfileSupplier, mCallbackController.makeCancelable(profile -> {', '                            assert profile != null : ""Unexpectedly null profile from TabModel."";', '                            if (profile == null) return;', '', '                            TrackerFactory.getTrackerForProfile(profile).notifyEvent(', '                                    EventConstants.STARTED_FROM_MAIN_INTENT);', '                        }));', '            }', '        }', '', '        mMainIntentMetrics.onMainIntentWithNative(', '                mInactivityTracker.getTimeSinceLastBackgroundedMs());', '    }', '', '    /** Access the main intent metrics for test validation. */', '    @VisibleForTesting', '    public MainIntentBehaviorMetrics getMainIntentBehaviorMetricsForTesting() {', '        return mMainIntentMetrics;', '    }', '', '    @VisibleForTesting', '    public ChromeInactivityTracker getInactivityTrackerForTesting() {', '        return mInactivityTracker;', '    }', '', '    @Override', '    public void initializeState() {', '        // This method goes through 3 steps:', ""        // 1. Load the saved tab state (but don't start restoring the tabs yet)."", '        // 2. Process the Intent that this activity received and if that should result in any', '        //    new tabs, create them.  This is done after step 1 so that the new tab gets', '        //    created after previous tab state was restored.', '        // 3. If no tabs were created in any of the above steps, create an NTP, otherwise', '        //    start asynchronous tab restore (loading the previously active tab synchronously', '        //    if no new tabs created in step 2).', '', '        // Only look at the original intent if this is not a ""restoration"" and we are allowed to', '        // process intents. Any subsequent intents are carried through onNewIntent.', '        try {', '            TraceEvent.begin(""ChromeTabbedActivity.initializeState"");', '', '            super.initializeState();', '            Log.i(TAG, ""#initializeState"");', '            Intent intent = getIntent();', '', '            boolean hadCipherData =', '                    CipherFactory.getInstance().restoreFromBundle(getSavedInstanceState());', '', '            boolean noRestoreState =', '                    CommandLine.getInstance().hasSwitch(ChromeSwitches.NO_RESTORE_STATE);', '            if (noRestoreState) {', '                // Clear the state files because they are inconsistent and useless from now on.', '                mTabModelOrchestrator.clearState();', '            } else {', '                // State should be clear when we start first run and hence we do not need to load', '                // a previous state. This may change the current Model, watch out for initialization', '                // based on the model.', '                // Never attempt to restore incognito tabs when this activity was previously swiped', '                // away in Recents. http://crbug.com/626629', '                boolean ignoreIncognitoFiles = !hadCipherData;', '                mTabModelOrchestrator.loadState(ignoreIncognitoFiles);', '            }', '', '            mInactivityTracker.register(this.getLifecycleDispatcher());', '            boolean isIntentWithEffect = false;', '            boolean isMainIntentFromLauncher = false;', '            if (getSavedInstanceState() == null && intent != null) {', '                if (!shouldIgnoreIntent()) {', '                    isIntentWithEffect = mIntentHandler.onNewIntent(intent);', '                }', '', '                if (IntentUtils.isMainIntentFromLauncher(intent)) {', '                    isMainIntentFromLauncher = true;', '                    logMainIntentBehavior(intent);', '                }', '            }', '', '            mIntentMetadataOneshotSupplier.set(', '                    new ToolbarIntentMetadata(isMainIntentFromLauncher, isIntentWithEffect));', '', '            // If we have tabs to reparent and getSavedInstanceState() is non-null, then the tabs', '            // are coming from night mode tab reparenting. In this case, reparenting happens', '            // synchronously along with tab restoration so there are no tabs waiting for', '            // reparenting like there are for other tab reparenting operations.', '            boolean hasTabWaitingForReparenting =', '                    AsyncTabParamsManagerSingleton.getInstance().hasParamsWithTabToReparent()', '                    && getSavedInstanceState() == null;', '            mCreatedTabOnStartup = getCurrentTabModel().getCount() > 0', '                    || mTabModelOrchestrator.getRestoredTabCount() > 0 || isIntentWithEffect', '                    || hasTabWaitingForReparenting;', '', '            // We always need to try to restore tabs. The set of tabs might be empty, but at least', '            // it will trigger the notification that tab restore is complete which is needed by', '            // other parts of Chrome such as sync.', '            boolean activeTabBeingRestored = !isIntentWithEffect', '                    || (shouldShowOverviewPageOnStart()', '                            && !mTabModelSelector.isIncognitoSelected());', '', '            mTabModelOrchestrator.restoreTabs(activeTabBeingRestored);', '', '            // Only create an initial tab if no tabs were restored and no intent was handled.', '            // Also, check whether the active tab was supposed to be restored and that the total', '            // tab count is now non zero.  If this is not the case, tab restore failed and we need', '            // to create a new tab as well.', '            if (!mCreatedTabOnStartup', '                    || (!hasTabWaitingForReparenting && activeTabBeingRestored', '                            && getTabModelSelector().getTotalTabCount() == 0)) {', '                // If homepage URI is not determined, due to PartnerBrowserCustomizations provider', '                // async reading, then create a tab at the async reading finished. If it takes', '                // too long, just create NTP.', '', '                mPendingInitialTabCreation = true;', '                PartnerBrowserCustomizations.getInstance().setOnInitializeAsyncFinished(() -> {', '                    if (!isActivityFinishingOrDestroyed()) {', '                        createInitialTab();', '                    }', '                }, INITIAL_TAB_CREATION_TIMEOUT_MS);', '            }', '', '            // If initial tab creation is pending, this will instead be handled when we create the', '            // initial tab in #createInitialTab.', '            if (!mPendingInitialTabCreation) {', '                mAppLaunchDrawBlocker.onActiveTabAvailable(isTabRegularNtp(getActivityTab()));', '            }', '        } finally {', '            TraceEvent.end(""ChromeTabbedActivity.initializeState"");', '        }', '    }', '', '    private boolean hasStartWithNativeBeenCalled() {', '        int activity_state = getLifecycleDispatcher().getCurrentActivityState();', '        return activity_state == ActivityLifecycleDispatcher.ActivityState.STARTED_WITH_NATIVE', '                || activity_state == ActivityLifecycleDispatcher.ActivityState.RESUMED_WITH_NATIVE;', '    }', '', '    /**', '     * Create an initial tab for cold start without restored tabs.', '     */', '    private void createInitialTab() {', '        Log.i(TAG, ""#createInitialTab executed."");', '        mPendingInitialTabCreation = false;', '', '        // If the start surface or grid tab switcher will be shown on start, do not create a new', '        // tab.', '        if (!shouldShowOverviewPageOnStart()) {', '            String url = HomepageManager.getHomepageUri();', '            if (TextUtils.isEmpty(url)) {', '                url = UrlConstants.NTP_URL;', '            } else {', '                // Migrate legacy NTP URLs (chrome://newtab) to the newer format', '                // (chrome-native://newtab)', '                if (UrlUtilities.isNTPUrl(url)) {', '                    url = UrlConstants.NTP_URL;', '                }', '            }', '', '            getTabCreator(false).launchUrl(url, TabLaunchType.FROM_STARTUP);', '        }', '', ""        // If we didn't call setInitialOverviewState() in onStartWithNative() because"", '        // mPendingInitialTabCreation was true then do so now.', '        if (hasStartWithNativeBeenCalled()) {', '            setInitialOverviewState();', '        }', '', '        mAppLaunchDrawBlocker.onActiveTabAvailable(isTabRegularNtp(getActivityTab()));', '    }', '', '    @Override', '    public void onAccessibilityModeChanged(boolean enabled) {', '        onAccessibilityTabSwitcherModeChanged();', '    }', '', '    private void onAccessibilityTabSwitcherModeChanged() {', '        if (!mUIWithNativeInitialized) return;', '', '        boolean accessibilityTabSwitcherEnabled =', '                DeviceClassManager.enableAccessibilityLayout(this);', '        if (mOverviewModeController != null && mOverviewModeController.overviewVisible()', '                && (mIsAccessibilityTabSwitcherEnabled == null', '                        || mIsAccessibilityTabSwitcherEnabled', '                                != DeviceClassManager.enableAccessibilityLayout(this))) {', '            /**', '             * If Start surface homepage is showing and launching NTP will show the Start surface', '             * again, skips the calls of hideOverview() and launchNTP(). We need to check', '             * {@link ReturnToChromeExperimentsUtil#shouldShowStartSurfaceHomeAsNTP(Context,', '             * boolean, boolean)} to see whether Start surface can be shown when accessibility is', '             * enabled.', '             */', '            if (mStartSurfaceSupplier.get() == null', '                    || mStartSurfaceSupplier.get().getController().getStartSurfaceState()', '                            != StartSurfaceState.SHOWN_HOMEPAGE', '                    || !ReturnToChromeExperimentsUtil.shouldShowStartSurfaceHomeAsNTP(', '                            this, getCurrentTabModel().isIncognito(), isTablet())) {', '                mOverviewModeController.hideOverview(true);', '                if (getTabModelSelector().getCurrentModel().getCount() == 0) {', '                    getCurrentTabCreator().launchNTP();', '                }', '            }', '        }', '        mIsAccessibilityTabSwitcherEnabled = accessibilityTabSwitcherEnabled;', '', '        if (ChromeAccessibilityUtil.get().isAccessibilityEnabled()) {', '            RecordHistogram.recordBooleanHistogram(', '                    ""Accessibility.Android.TabSwitcherPreferenceEnabled"",', '                    mIsAccessibilityTabSwitcherEnabled);', '        }', '    }', '', '    /**', '     * Internal class which performs the intent handling operations delegated by IntentHandler.', '     */', '    private class InternalIntentDelegate implements IntentHandler.IntentHandlerDelegate {', '        /**', '         * Processes a url view intent.', '         *', '         * @param url The url from the intent.', '         */', '        @Override', '        public void processUrlViewIntent(LoadUrlParams loadUrlParams, @TabOpenType int tabOpenType,', '                String externalAppId, int tabIdToBringToFront, Intent intent) {', '            if (isActivityFinishingOrDestroyed()) {', '                return;', '            }', '            if (isFromChrome(intent, externalAppId)) {', '                RecordUserAction.record(""MobileTabbedModeViewIntentFromChrome"");', '            } else {', '                RecordUserAction.record(""MobileTabbedModeViewIntentFromApp"");', '            }', '', '            final String url = loadUrlParams.getUrl();', '            boolean fromLauncherShortcut = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_INVOKED_FROM_SHORTCUT, false);', '            boolean fromAppWidget = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_INVOKED_FROM_APP_WIDGET, false);', '            boolean focus = false;', '', '            TabModel tabModel = getCurrentTabModel();', '            switch (tabOpenType) {', '                case TabOpenType.REUSE_URL_MATCHING_TAB_ELSE_NEW_TAB:', '                    mTabModelOrchestrator.tryToRestoreTabStateForUrl(url);', '                    int tabToBeClobberedIndex = TabModelUtils.getTabIndexByUrl(tabModel, url);', '                    Tab tabToBeClobbered = tabModel.getTabAt(tabToBeClobberedIndex);', '                    if (tabToBeClobbered != null) {', '                        TabModelUtils.setIndex(tabModel, tabToBeClobberedIndex);', '                        tabToBeClobbered.reload();', '                    } else {', '                        launchIntent(loadUrlParams, externalAppId, true, intent);', '                    }', '                    int shortcutSource = intent.getIntExtra(', '                            WebappConstants.EXTRA_SOURCE, ShortcutSource.UNKNOWN);', '                    LaunchMetrics.recordHomeScreenLaunchIntoTab(url, shortcutSource);', '                    if (fromAppWidget && url.startsWith(UrlConstants.CHROME_DINO_URL)) {', '                        RecordUserAction.record(""QuickActionSearchWidget.StartDinoGame"");', '                    }', '                    break;', '                case TabOpenType.BRING_TAB_TO_FRONT:', '                    mTabModelOrchestrator.tryToRestoreTabStateForId(tabIdToBringToFront);', '', '                    int tabIndex = TabModelUtils.getTabIndexById(tabModel, tabIdToBringToFront);', '                    if (tabIndex == TabModel.INVALID_TAB_INDEX) {', '                        TabModel otherModel =', '                                getTabModelSelector().getModel(!tabModel.isIncognito());', '                        tabIndex = TabModelUtils.getTabIndexById(otherModel, tabIdToBringToFront);', '                        if (tabIndex != TabModel.INVALID_TAB_INDEX) {', '                            getTabModelSelector().selectModel(otherModel.isIncognito());', '                            TabModelUtils.setIndex(otherModel, tabIndex);', '                        } else {', '                            Log.e(TAG, ""Failed to bring tab to front because it doesn\'t exist."");', '                            return;', '                        }', '                    } else {', '                        TabModelUtils.setIndex(tabModel, tabIndex);', '                    }', '                    break;', '                case TabOpenType.CLOBBER_CURRENT_TAB:', '                    // The browser triggered the intent. This happens when clicking links which', '                    // can be handled by other applications (e.g. www.youtube.com links).', '                    Tab currentTab = getActivityTab();', '                    if (currentTab != null) {', '                        RedirectHandlerTabHelper.updateIntentInTab(currentTab, intent);', '                        currentTab.loadUrl(loadUrlParams);', '                    } else {', '                        launchIntent(loadUrlParams, externalAppId, true, intent);', '                    }', '                    break;', '                case TabOpenType.REUSE_APP_ID_MATCHING_TAB_ELSE_NEW_TAB:', '                    launchIntent(loadUrlParams, externalAppId, false, intent);', '                    break;', '                case TabOpenType.REUSE_TAB_MATCHING_ID_ELSE_NEW_TAB:', '                    int tabId = IntentUtils.safeGetIntExtra(', '                            intent, TabOpenType.REUSE_TAB_MATCHING_ID_STRING, Tab.INVALID_TAB_ID);', '                    if (tabId != Tab.INVALID_TAB_ID) {', '                        mTabModelOrchestrator.tryToRestoreTabStateForId(tabId);', '                        int matchingTabIndex = TabModelUtils.getTabIndexById(tabModel, tabId);', '                        boolean loaded = false;', '                        if (matchingTabIndex != TabModel.INVALID_TAB_INDEX) {', '                            Tab tab = tabModel.getTabAt(matchingTabIndex);', '                            if (tab.getUrl().getSpec().equals(url)', '                                    || tab.getUrl().getSpec().equals(IntentUtils.safeGetStringExtra(', '                                            intent, TabOpenType.REUSE_TAB_ORIGINAL_URL_STRING))) {', '                                tabModel.setIndex(matchingTabIndex, TabSelectionType.FROM_USER);', '                                tab.loadUrl(loadUrlParams);', '                                loaded = true;', '                            }', '                        }', '                        if (!loaded) {', '                            launchIntent(loadUrlParams, externalAppId, false, intent);', '                        }', '                    }', '                    break;', '                case TabOpenType.OPEN_NEW_TAB:', '                    if (fromLauncherShortcut) {', '                        recordLauncherShortcutAction(false);', '                        reportNewTabShortcutUsed(false);', '                    }', '', '                    launchIntent(loadUrlParams, externalAppId, true, intent);', '                    break;', '                case TabOpenType.OPEN_NEW_INCOGNITO_TAB:', '                    if (!TextUtils.equals(externalAppId, getPackageName())) {', '                        assert false : ""Only Chrome is allowed to open incognito tabs"";', '                        Log.e(TAG, ""Only Chrome is allowed to open incognito tabs"");', '                        return;', '                    }', '', '                    if (!IncognitoUtils.isIncognitoModeEnabled()) {', '                        // The incognito launcher shortcut is manipulated in #onDeferredStartup(),', ""                        // so it's possible for a user to invoke the shortcut before it's disabled."", '                        // Quick actions search widget is installed on the home screen and may', '                        // need to be updated before the incognito button is removed.', '                        // Opening an incognito tab while incognito mode is disabled from somewhere', '                        // besides the launcher shortcut of from quick action search widget is an', '                        // error.', '                        if (fromAppWidget || fromLauncherShortcut) {', '                            // We are using the message introduced for quick action search widget', '                            // for both the widget and the launcher shortcut here.', '                            Toast.makeText(ChromeTabbedActivity.this,', '                                         R.string.quick_action_search_widget_message_no_incognito,', '                                         Toast.LENGTH_LONG)', '                                    .show();', '                        } else {', '                            assert false : ""Tried to open incognito tab while incognito disabled"";', '                            Log.e(TAG, ""Tried to open incognito tab while incognito disabled"");', '                        }', '', '                        return;', '                    }', '', '                    if (url == null || url.equals(UrlConstants.NTP_URL)) {', '                        if (fromLauncherShortcut) {', '                            getTabCreator(true).launchUrl(', '                                    UrlConstants.NTP_URL, TabLaunchType.FROM_LAUNCHER_SHORTCUT);', '                            recordLauncherShortcutAction(true);', '                            reportNewTabShortcutUsed(true);', '                        } else if (fromAppWidget) {', '                            RecordUserAction.record(""QuickActionSearchWidget.StartIncognito"");', '                            getTabCreator(true).launchUrl(', '                                    UrlConstants.NTP_URL, TabLaunchType.FROM_APP_WIDGET);', '                        } else if (IncognitoTabLauncher.didCreateIntent(intent)) {', '                            Tab tab = getTabCreator(true).launchUrl(UrlConstants.NTP_URL,', '                                    TabLaunchType.FROM_LAUNCH_NEW_INCOGNITO_TAB);', '                            if (IncognitoTabLauncher.shouldFocusOmnibox(intent)) {', '                                // Since the Tab is created in the foreground, its View will gain', '                                // focus, and since the Tab and the URL bar are not yet in the same', ""                                // View hierarchy, setting the URL bar's focus here won't clear the"", ""                                // Tab's focus. When the Tab is added to the hierarchy, we want the"", ""                                // URL bar to retain focus, so we clear the Tab's focus here."", '                                tab.getView().clearFocus();', '                                focus = true;', '                            }', '', '                            IncognitoTabLauncher.recordUse();', '                        } else {', '                            // Used by the Account management screen to open a new incognito tab.', '                            // Account management screen collects its metrics separately.', '                            getTabCreator(true).launchUrl(UrlConstants.NTP_URL,', '                                    TabLaunchType.FROM_CHROME_UI, intent, mIntentHandlingTimeMs);', '                        }', '                    } else {', '                        @TabLaunchType', '                        Integer launchType = IntentHandler.getTabLaunchType(intent);', '                        if (launchType == null) launchType = TabLaunchType.FROM_LINK;', '                        getTabCreator(true).launchUrl(', '                                url, launchType, intent, mIntentHandlingTimeMs);', '                    }', '                    break;', '                default:', '                    assert false : ""Unknown TabOpenType: "" + tabOpenType;', '                    break;', '            }', '', '            getToolbarManager().setUrlBarFocusOnceNativeInitialized(focus,', '                    focus ? OmniboxFocusReason.LAUNCH_NEW_INCOGNITO_TAB', '                          : OmniboxFocusReason.UNFOCUS);', '', '            if (tabModel.getCount() > 0 && isInOverviewMode() && !isTablet()', '                    && !shouldShowOverviewPageOnStart()) {', '                mOverviewModeController.hideOverview(true);', '            }', '        }', '', '        @Override', '        public long getIntentHandlingTimeMs() {', '            return mIntentHandlingTimeMs;', '        }', '', '        @Override', '        public void processWebSearchIntent(String query) {', '            assert false;', '        }', '', '        @Override', '        public void processTranslateTabIntent(', '                @Nullable String targetLanguageCode, @Nullable String expectedUrl) {', '            TranslateIntentHandler.translateTab(getActivityTab(), targetLanguageCode, expectedUrl);', '        }', '', '        private boolean isFromChrome(Intent intent, String externalAppId) {', '            // To determine if the processed intent is from Chrome, check for any of the following:', '            // 1.) The authentication token that will be added to trusted intents.', '            // 2.) The app ID matches Chrome.  This value can be spoofed by other applications, but', '            //     in cases where we were not able to add the authentication token this is our only', '            //     indication the intent was from Chrome.', '            return IntentHandler.wasIntentSenderChrome(intent)', '                    || TextUtils.equals(externalAppId, getPackageName());', '        }', '    }', '', '    @Override', '    public void performPreInflationStartup() {', '        // Create JankTracker before invoking super, because the parent class will invoke', '        // createRootUiCoordinator(...), which in our case requires the JankTracker to already have', '        // been created.', '        mJankTracker = new JankTrackerImpl(this);', '', '        super.performPreInflationStartup();', '', '        // Decide whether to record startup UMA histograms. This is done  early in the main', '        // Activity.onCreate() to avoid recording navigation delays when they require user input to', '        // proceed. For example, FRE (First Run Experience) happens before the activity is created,', '        // and triggers initialization of the native library.', '        //', '        // An uninitialized native library is an indication of an application start that is followed', '        // by navigation immediately without user input.', '        if (!LibraryLoader.getInstance().isInitialized()) {', '            setTrackColdStartupMetrics(true);', '        }', '', '        supportRequestWindowFeature(Window.FEATURE_ACTION_MODE_OVERLAY);', '', '        IncognitoTabHostRegistry.getInstance().register(mIncognitoTabHost);', '', '        mStartupPaintPreviewHelperSupplier.attach(getWindowAndroid().getUnownedUserDataHost());', '    }', '', '    @Override', '    protected RootUiCoordinator createRootUiCoordinator() {', '        return new TabbedRootUiCoordinator(this, this::onOmniboxFocusChanged,', '                getShareDelegateSupplier(), getActivityTabProvider(), mTabModelProfileSupplier,', '                mBookmarkBridgeSupplier, this::getContextualSearchManager,', '                getTabModelSelectorSupplier(), mStartSurfaceSupplier,', '                mIntentMetadataOneshotSupplier, mLayoutStateProviderOneshotSupplier,', '                mStartSurfaceParentTabSupplier, getBrowserControlsManager(), getWindowAndroid(),', '                mJankTracker, getLifecycleDispatcher(), getLayoutManagerSupplier(),', '                /* menuOrKeyboardActionController= */ this, this::getActivityThemeColor,', '                getModalDialogManagerSupplier(), /* appMenuBlocker= */ this, this::supportsAppMenu,', '                this::supportsFindInPage, getTabCreatorManagerSupplier(), getFullscreenManager(),', '                getCompositorViewHolderSupplier(), getTabContentManagerSupplier(),', '                getOverviewModeBehaviorSupplier(), this::getSnackbarManager, getActivityType(),', '                this::isInOverviewMode, this::isWarmOnResume,', '                /* appMenuDelegate= */ this, /* statusBarColorProvider= */ this,', '                mEphemeralTabCoordinatorSupplier, getIntentRequestTracker(),', '                getControlContainerHeightResource(), this::getInsetObserverView,', '                this::backShouldCloseTab);', '    }', '', '    @Override', '    protected int getControlContainerLayoutId() {', '        return R.layout.control_container;', '    }', '', '    @Override', '    public int getControlContainerHeightResource() {', '        return R.dimen.control_container_height;', '    }', '', '    @Override', '    protected int getToolbarLayoutId() {', '        return isTablet() ? R.layout.toolbar_tablet : R.layout.toolbar_phone;', '    }', '', '    @Override', '    protected int getToolbarShadowResource() {', '        final boolean themeRefactorEnabled =', '                CachedFeatureFlags.isEnabled(ChromeFeatureList.THEME_REFACTOR_ANDROID);', '        return themeRefactorEnabled ? R.drawable.toolbar_hairline', '                                    : R.drawable.modern_toolbar_shadow;', '    }', '', '    @Override', '    protected int getToolbarShadowLayoutHeight() {', '        final int res = CachedFeatureFlags.isEnabled(ChromeFeatureList.THEME_REFACTOR_ANDROID)', '                ? R.dimen.toolbar_hairline_height', '                : R.dimen.toolbar_shadow_height;', '        return getResources().getDimensionPixelSize(res);', '    }', '', '    @Override', '    public void performPostInflationStartup() {', '        super.performPostInflationStartup();', '', '        FontPreloader.getInstance().onPostInflationStartupTabbedActivity();', '', '        TabModelSelector tabModelSelector = getTabModelSelector();', '        IncognitoProfileDestroyer.observeTabModelSelector(tabModelSelector);', '        IncognitoNotificationPresenceController.observeTabModelSelector(tabModelSelector);', '', '        // Critical path for startup. Create the minimum objects needed', '        // to allow a blank screen draw (without depending on any native code)', '        // and then yield ASAP.', '        if (isFinishing()) return;', '', ""        // Don't show the keyboard until user clicks in."", '        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN', '                | WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);', '', '        mContentContainer = (ViewGroup) findViewById(android.R.id.content);', '        mControlContainer = (ToolbarControlContainer) findViewById(R.id.control_container);', '', '        Supplier<Boolean> dialogVisibilitySupplier = null;', '        if (TabUiFeatureUtilities.isTabGroupsAndroidEnabled(this)) {', '            dialogVisibilitySupplier = () -> {', '                assert mStartSurfaceSupplier.get() != null;', '                assert getToolbarManager().getTabGroupUi() != null;', '                // Return true if dialog from either tab switcher or tab strip is visible.', '', '                ToolbarManager toolbarManager = getToolbarManager();', '                TabGroupUi tabGroupUi = toolbarManager.getTabGroupUi();', '                boolean isDialogVisible = tabGroupUi.isTabGridDialogVisible();', '', '                Supplier<Boolean> tabSwitcherDialogVisibilitySupplier =', '                        mStartSurfaceSupplier.get().getTabGridDialogVisibilitySupplier();', '', '                if (tabSwitcherDialogVisibilitySupplier != null) {', '                    isDialogVisible = isDialogVisible || tabSwitcherDialogVisibilitySupplier.get();', '                }', '                return isDialogVisible;', '            };', '        }', '', '        mUndoBarPopupController = new UndoBarController(this, mTabModelSelector,', '                this::getSnackbarManager, mOverviewModeBehaviorSupplier, dialogVisibilitySupplier);', '', '        mInactivityTracker = new ChromeInactivityTracker(', '                ChromePreferenceKeys.TABBED_ACTIVITY_LAST_BACKGROUNDED_TIME_MS_PREF);', '', '        assert getActivityTabStartupMetricsTracker() != null;', '        if (StartupPaintPreviewHelper.isEnabled()) {', '            StartupPaintPreviewHelper paintPreviewHelper = new StartupPaintPreviewHelper(', '                    getWindowAndroid(), getOnCreateTimestampMs(), getBrowserControlsManager(),', '                    getTabModelSelector(), shouldShowOverviewPageOnStart(), () -> {', '                        return getToolbarManager() == null', '                                ? null', '                                : getToolbarManager().getProgressBarCoordinator();', '                    });', '            mStartupPaintPreviewHelperSupplier.set(paintPreviewHelper);', '            getActivityTabStartupMetricsTracker().registerPaintPreviewObserver(paintPreviewHelper);', '        }', '    }', '', '    private boolean shouldIgnoreIntent() {', '        if (mShouldIgnoreIntent == null) {', '            // We call this only once because mIntentHandler#shouldIgnoreIntent has side effects.', '            mShouldIgnoreIntent =', '                    mIntentHandler.shouldIgnoreIntent(getIntent(), /*startedActivity=*/true);', '        }', '        return mShouldIgnoreIntent;', '    }', '', '    @Override', '    protected final void dispatchOnInflationComplete() {', '        super.dispatchOnInflationComplete();', '', '        // When the feature flag {@link ChromeFeatureList.INSTANT_START} turns on phones (not', '        // tablet), a view-only start page created on Java will be shown before native is', '        // initialized. The {@link prepareToShowStartPagePreNative()} is only called in a cold', '        // start.', '        if (ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()', '                && TabUiFeatureUtilities.supportInstantStart(isTablet(), this) && !hadWarmStart()) {', '            prepareToShowStartPagePreNative();', '        }', '    }', '', '    /**', '     * Prepares to show the start page before native is initialized. For example, create', '     * an LayoutManagerChrome object, add overview mode observer and so on.', '     */', '    private void prepareToShowStartPagePreNative() {', '        assert TabUiFeatureUtilities.supportInstantStart(isTablet() && !hadWarmStart(), this);', '        try (TraceEvent e =', '                        TraceEvent.scoped(""ChromeTabbedActivity.prepareToShowStartPagePreNative"")) {', '            setupCompositorContentPreNativeForPhone();', '            getCompositorViewHolderSupplier().get().setLayoutManager(mLayoutManager);', '', '            if (shouldShowOverviewPageOnStart()) {', '                mLayoutManager.setTabModelSelector(mTabModelSelector);', '                mIsAccessibilityTabSwitcherEnabled =', '                        DeviceClassManager.enableAccessibilityLayout(this);', '                assert !mHasDeterminedOverviewStateForCurrentSession;', '                setInitialOverviewState();', '            }', '        }', '    }', '', '    @Override', '    protected TabModelOrchestrator createTabModelOrchestrator() {', '        boolean tabMergingEnabled =', '                mMultiInstanceManager != null && mMultiInstanceManager.isTabModelMergingEnabled();', '        mTabModelOrchestrator = new TabbedModeTabModelOrchestrator(tabMergingEnabled);', '        return mTabModelOrchestrator;', '    }', '', '    @Override', '    protected void createTabModels() {', '        assert mTabModelSelector == null;', '        assert mWindowId != INVALID_WINDOW_ID;', '', '        Bundle savedInstanceState = getSavedInstanceState();', '', '        // We determine the model as soon as possible so every systems get initialized coherently.', '        boolean startIncognito = savedInstanceState != null', '                && savedInstanceState.getBoolean(IS_INCOGNITO_SELECTED, false);', '', '        mNextTabPolicySupplier = new ChromeNextTabPolicySupplier(mOverviewModeBehaviorSupplier);', '', '        boolean tabModelWasCreated = mTabModelOrchestrator.createTabModels(', '                this, this, mNextTabPolicySupplier, mWindowId);', '        if (!tabModelWasCreated) {', '            finish();', '            return;', '        }', '', '        if (mMultiInstanceManager != null) {', '            int assignedIndex = TabWindowManagerSingleton.getInstance().getIndexForWindow(this);', '            // The given index and the one computed by TabWindowManager should be one and the same.', '            assert !MultiWindowUtils.isMultiInstanceApi31Enabled() || assignedIndex == mWindowId;', '            mMultiInstanceManager.initialize(assignedIndex, getTaskId());', '        }', '', '        mTabModelSelector = mTabModelOrchestrator.getTabModelSelector();', '        mTabModelSelector.addObserver(new TabModelSelectorObserver() {', '            @Override', '            public void onTabStateInitialized() {', '                if (!mCreatedTabOnStartup) return;', '', '                TabModel model = mTabModelSelector.getModel(false);', '                TasksUma.recordTasksUma(model);', '            }', '        });', '', '        mTabModelSelectorTabObserver = new TabModelSelectorTabObserver(mTabModelSelector) {', '            @Override', '            public void onDidFinishNavigation(Tab tab, NavigationHandle navigation) {', '                if (!navigation.hasCommitted() || !navigation.isInPrimaryMainFrame()) {', '                    return;', '                }', '                DataReductionPromoInfoBar.maybeLaunchPromoInfoBar(ChromeTabbedActivity.this,', '                        tab.getWebContents(), navigation.getUrl(), tab.isShowingErrorPage(),', '                        navigation.isFragmentNavigation(), navigation.httpStatusCode());', '                if (SyncErrorPromptUtils.isMessageUiEnabled()) {', '                    SyncErrorMessage.maybeShowMessageUi(', '                            getWindowAndroid(), ChromeTabbedActivity.this);', '                } else {', '                    SyncErrorInfoBar.maybeLaunchSyncErrorInfoBar(tab.getWebContents());', '                }', '                SendTabToSelfAndroidBridge.updateActiveWebContents(tab.getWebContents());', '            }', '        };', '        mAppIndexingUtil = new AppIndexingUtil(mTabModelSelector);', '', '        if (startIncognito) mTabModelSelector.selectModel(true);', '    }', '', '    @Override', '    protected LaunchCauseMetrics createLaunchCauseMetrics() {', '        return new TabbedActivityLaunchCauseMetrics(this);', '    }', '', '    @Override', '    public AppMenuPropertiesDelegate createAppMenuPropertiesDelegate() {', '        return new TabbedAppMenuPropertiesDelegate(this, getActivityTabProvider(),', '                getMultiWindowModeStateDispatcher(), getTabModelSelector(), getToolbarManager(),', '                getWindow().getDecorView(), this, mOverviewModeBehaviorSupplier,', '                ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()', '                        ? mStartSurfaceSupplier', '                        : null,', '                mBookmarkBridgeSupplier,', '                ()', '                        -> getTabCreator(/*incognito=*/false)', '                                   .launchUrl(NewTabPageUtils.encodeNtpUrl(', '                                                      NewTabPageLaunchOrigin.WEB_FEED),', '                                           TabLaunchType.FROM_CHROME_UI),', '                getModalDialogManager(), getSnackbarManager());', '    }', '', '    private TabDelegateFactory getTabDelegateFactory() {', '        if (mTabDelegateFactory == null) {', '            mTabDelegateFactory = new TabbedModeTabDelegateFactory(this,', '                    getAppBrowserControlsVisibilityDelegate(), getShareDelegateSupplier(),', '                    mEphemeralTabCoordinatorSupplier,', '                    ((TabbedRootUiCoordinator) mRootUiCoordinator)::onContextMenuCopyLink,', '                    mRootUiCoordinator.getBottomSheetController(),', '                    /* ChromeActivityNativeDelegate */ this, /* isCustomTab= */ false,', '                    getBrowserControlsManager(), getFullscreenManager(),', '                    /* TabCreatorManager */ this, getTabModelSelectorSupplier(),', '                    getCompositorViewHolderSupplier(), getModalDialogManagerSupplier(),', '                    this::getSnackbarManager, getBrowserControlsManager(), getActivityTabProvider(),', '                    getLifecycleDispatcher(), getWindowAndroid(), this::getLastUserInteractionTime,', '                    this::hadWarmStart, mJankTracker, getToolbarManager()::getToolbar);', '        }', '        return mTabDelegateFactory;', '    }', '', '    @Override', '    protected Pair<ChromeTabCreator, ChromeTabCreator> createTabCreators() {', '        ChromeTabCreator.OverviewNTPCreator overviewNTPCreator = null;', '', '        if (ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '            overviewNTPCreator = new ChromeTabCreator.OverviewNTPCreator() {', '                @Override', '                public boolean handleCreateNTPIfNeeded(boolean isNTP, boolean incognito,', '                        Tab parentTab, @NewTabPageLaunchOrigin int launchOrigin) {', '                    boolean shouldShowStart =', '                            showStartSurfaceHomeForNTP(isNTP, incognito, parentTab, launchOrigin);', '                    if (shouldShowStart) {', '                        mStartSurfaceParentTabSupplier.set(parentTab);', '                    }', '                    return shouldShowStart;', '                }', '', '                @Override', '                public void preTabInitialization(Tab tab, String url) {', '                    StartSurfaceConfiguration.maySetUserDataForEmptyTab(tab, url);', '                }', '            };', '        }', '        return Pair.create(', '                new ChromeTabCreator(this, getWindowAndroid(), getStartupTabPreloader(),', '                        this::getTabDelegateFactory, false, overviewNTPCreator,', '                        AsyncTabParamsManagerSingleton.getInstance(), getTabModelSelectorSupplier(),', '                        getCompositorViewHolderSupplier()),', '                new ChromeTabCreator(this, getWindowAndroid(), getStartupTabPreloader(),', '                        this::getTabDelegateFactory, true, overviewNTPCreator,', '                        AsyncTabParamsManagerSingleton.getInstance(), getTabModelSelectorSupplier(),', '                        getCompositorViewHolderSupplier()));', '    }', '', '    @Override', '    protected void initDeferredStartupForActivity() {', '        super.initDeferredStartupForActivity();', '        DeferredStartupHandler.getInstance().addDeferredTask(() -> {', '            ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);', '            RecordHistogram.recordSparseHistogram(', '                    ""MemoryAndroid.DeviceMemoryClass"", am.getMemoryClass());', '', '            LauncherShortcutActivity.updateIncognitoShortcut(ChromeTabbedActivity.this);', '', '            ChromeSurveyController.initialize(mTabModelSelector, getLifecycleDispatcher(),', '                    ChromeTabbedActivity.this, MessageDispatcherProvider.from(getWindowAndroid()));', '', '            if (mStartSurfaceSupplier.get() != null) {', '                mStartSurfaceSupplier.get().onOverviewShownAtLaunch(', '                        mOverviewShownOnStart, getOnCreateTimestampMs());', '            }', '        });', '    }', '', '    @Override', '    protected void recordIntentToCreationTime(long timeMs) {', '        super.recordIntentToCreationTime(timeMs);', '        RecordHistogram.recordCustomTimesHistogram(""MobileStartup.IntentToCreationTime.TabbedMode"",', '                timeMs, 1, DateUtils.SECOND_IN_MILLIS * 30, 50);', '    }', '', '    @Override', '    protected boolean isStartedUpCorrectly(Intent intent) {', '        mWindowId = 0;', '        Bundle savedInstanceState = getSavedInstanceState();', '        int windowId = getExtraWindowIdFromIntent(intent);', '        if (savedInstanceState != null && savedInstanceState.containsKey(WINDOW_INDEX)) {', '            // Activity is recreated after destruction. |windowId| must not be valid in this case.', '            assert windowId == INVALID_WINDOW_ID;', '            mWindowId = savedInstanceState.getInt(WINDOW_INDEX, 0);', '        } else if (mMultiInstanceManager != null) {', ""            // |allocInstanceId| doesn't do any disk I/O that would add a long-running task"", '            // to pre-inflation startup.', '            boolean preferNew = getExtraPreferNewFromIntent(intent);', '            mWindowId = mMultiInstanceManager.allocInstanceId(windowId, getTaskId(), preferNew);', '        }', '        if (mWindowId == INVALID_WINDOW_ID) {', '            Log.i(TAG, ""Window ID not allocated. Finishing the activity"");', '            Toast.makeText(this, R.string.max_number_of_windows, Toast.LENGTH_LONG).show();', '            return false;', '        }', '', '        if (mMultiInstanceManager != null', '                && !mMultiInstanceManager.isStartedUpCorrectly(getTaskId())) {', '            return false;', '        }', '', '        return super.isStartedUpCorrectly(intent);', '    }', '', '    private static int getExtraWindowIdFromIntent(Intent intent) {', '        int windowId = IntentUtils.safeGetIntExtra(', '                intent, IntentHandler.EXTRA_WINDOW_ID, INVALID_WINDOW_ID);', '        return IntentUtils.isTrustedIntentFromSelf(intent) ? windowId : INVALID_WINDOW_ID;', '    }', '', '    private static boolean getExtraPreferNewFromIntent(Intent intent) {', '        return IntentUtils.safeGetBooleanExtra(intent, IntentHandler.EXTRA_PREFER_NEW, false);', '    }', '', '    @Override', '    public void terminateIncognitoSession() {', '        getTabModelSelector().getModel(true).closeAllTabs();', '    }', '', '    @Override', '    public boolean onMenuOrKeyboardAction(final int id, boolean fromMenu) {', '        final Tab currentTab = getActivityTab();', '        boolean currentTabIsNtp = isTabNtp(currentTab);', '        if (id == R.id.new_tab_menu_id) {', '            getTabModelSelector().getModel(false).commitAllTabClosures();', '            RecordUserAction.record(""MobileMenuNewTab"");', '            RecordUserAction.record(""MobileNewTabOpened"");', '            ReturnToChromeExperimentsUtil.onNewTabOpened();', '            reportNewTabShortcutUsed(false);', '            if (fromMenu) RecordUserAction.record(""MobileMenuNewTab.AppMenu"");', '', '            getTabCreator(false).launchNTP();', '', '            mLocaleManager.showSearchEnginePromoIfNeeded(this, null);', '        } else if (id == R.id.new_incognito_tab_menu_id) {', '            if (IncognitoUtils.isIncognitoModeEnabled()) {', '                getTabModelSelector().getModel(false).commitAllTabClosures();', '                // This action must be recorded before opening the incognito tab since UMA actions', '                // are dropped when an incognito tab is open.', '                RecordUserAction.record(""MobileMenuNewIncognitoTab"");', '                RecordUserAction.record(""MobileNewTabOpened"");', '                ReturnToChromeExperimentsUtil.onNewTabOpened();', '                reportNewTabShortcutUsed(true);', '                if (fromMenu) RecordUserAction.record(""MobileMenuNewIncognitoTab.AppMenu"");', '                getTabCreator(true).launchNTP();', '            }', '        } else if (id == R.id.all_bookmarks_menu_id) {', ""            // Note that 'currentTab' could be null in overview mode when start surface is"", '            // enabled.', '            getCompositorViewHolderSupplier().get().hideKeyboard(() -> {', '                BookmarkUtils.showBookmarkManager(', '                        ChromeTabbedActivity.this, getCurrentTabModel().isIncognito());', '            });', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_BOOKMARKS_MANAGER);', '            }', '', '            @BrowserProfileType', '            int type = getCurrentTabModel().isIncognito() ? BrowserProfileType.INCOGNITO', '                                                          : BrowserProfileType.REGULAR;', '            RecordHistogram.recordEnumeratedHistogram(', '                    ""Bookmarks.OpenBookmarkManager.PerProfileType"", type,', '                    BrowserProfileType.MAX_VALUE + 1);', '', '            RecordUserAction.record(""MobileMenuAllBookmarks"");', '        } else if (id == R.id.recent_tabs_menu_id) {', '            LoadUrlParams params =', '                    new LoadUrlParams(UrlConstants.RECENT_TABS_URL, PageTransition.AUTO_BOOKMARK);', '            boolean isInOverviewMode = isInOverviewMode();', '            if (isInOverviewMode && !isTablet()', '                    && ReturnToChromeExperimentsUtil.isStartSurfaceHomepageEnabled()) {', '                // When tapping the ""Recent tabs"" menu item from the overview page (Start surface or', '                // GTS), we will create the tab with the launch type FROM_START_SURFACE. Thus, if', '                // the back button is tapped on this ""Recent tabs"" page, it can go back to the', '                // overview page.', '                ReturnToChromeExperimentsUtil.handleLoadUrlFromStartSurface(', '                        params, getCurrentTabModel().isIncognito(), null);', '            } else if (currentTab != null) {', '                currentTab.loadUrl(params);', '            } else {', '                getTabCreator(getCurrentTabModel().isIncognito())', '                        .createNewTab(params, TabLaunchType.FROM_CHROME_UI, null);', '            }', '            if (isInOverviewMode) {', '                mOverviewModeController.hideOverview(true);', '            }', '', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_RECENT_TABS_MANAGER);', '            }', '            RecordUserAction.record(""MobileMenuRecentTabs"");', '            ReturnToChromeExperimentsUtil.onRecentTabsOpened();', '        } else if (id == R.id.close_tab) {', '            getCurrentTabModel().closeTab(currentTab, true, false, true);', '            RecordUserAction.record(""MobileTabClosed"");', '        } else if (id == R.id.close_all_tabs_menu_id) {', '            // Close both incognito and normal tabs', '            getTabModelSelector().closeAllTabs();', '            RecordUserAction.record(""MobileMenuCloseAllTabs"");', '        } else if (id == R.id.close_all_incognito_tabs_menu_id) {', '            // Close only incognito tabs', '            getTabModelSelector().getModel(true).closeAllTabs();', '            RecordUserAction.record(""MobileMenuCloseAllIncognitoTabs"");', '        } else if (id == R.id.focus_url_bar) {', '            boolean isUrlBarVisible = !mOverviewModeController.overviewVisible()', '                    && (!isTablet() || getCurrentTabModel().getCount() != 0);', '            if (isUrlBarVisible) {', '                getToolbarManager().setUrlBarFocus(', '                        true, OmniboxFocusReason.MENU_OR_KEYBOARD_ACTION);', '            }', '        } else if (id == R.id.downloads_menu_id) {', '            OTRProfileID otrProfileID = null;', '            if (currentTab != null && currentTab.getWebContents() != null) {', '                Profile profile = Profile.fromWebContents(currentTab.getWebContents());', '                otrProfileID = profile != null ? profile.getOTRProfileID() : null;', '            }', '            DownloadUtils.showDownloadManager(', '                    this, currentTab, otrProfileID, DownloadOpenSource.MENU);', '            if (currentTabIsNtp) {', '                NewTabPageUma.recordAction(NewTabPageUma.ACTION_OPENED_DOWNLOADS_MANAGER);', '            }', '            RecordUserAction.record(""MobileMenuDownloadManager"");', '        } else if (id == R.id.open_recently_closed_tab) {', '            TabModel currentModel = mTabModelSelector.getCurrentModel();', '            if (!currentModel.isIncognito()) currentModel.openMostRecentlyClosedTab();', '            RecordUserAction.record(""MobileTabClosedUndoShortCut"");', '        } else if (id == R.id.enter_vr_id) {', '            VrModuleProvider.getDelegate().enterVrIfNecessary();', '        } else {', '            return super.onMenuOrKeyboardAction(id, fromMenu);', '        }', '        return true;', '    }', '', '    private boolean isTabNtp(Tab tab) {', '        return tab != null && UrlUtilities.isNTPUrl(tab.getUrl());', '    }', '', '    private boolean isTabRegularNtp(Tab tab) {', '        return isTabNtp(tab) && !tab.isIncognito();', '    }', '', '    private void onOmniboxFocusChanged(boolean hasFocus) {', '        mTabModalHandler.onOmniboxFocusChanged(hasFocus);', '    }', '', '    private void recordLauncherShortcutAction(boolean isIncognito) {', '        if (isIncognito) {', '            RecordUserAction.record(""Android.LauncherShortcut.NewIncognitoTab"");', '        } else {', '            RecordUserAction.record(""Android.LauncherShortcut.NewTab"");', '        }', '    }', '', '    @Override', '    public boolean handleBackPressed() {', '        if (!mUIWithNativeInitialized) return false;', '', '        if (getManualFillingComponent().handleBackPress()) return true;', '', '        if (exitFullscreenIfShowing()) {', '            return true;', '        }', '', '        // TODO(1091411): Find a better mechanism for back-press handling for features.', '        if (mRootUiCoordinator.getBottomSheetController().handleBackPress()) return true;', '', '        if (mTabModalHandler.handleBackPress()) return true;', '', '        final Tab currentTab = getActivityTab();', '        if (currentTab == null) {', '            moveTaskToBack(true);', '            return true;', '        }', '', '        // If we are in the tab switcher mode (not in the Start surface homepage) and not a tablet,', '        // then leave tab switcher mode on back.', '        if (mOverviewModeController.overviewVisible() && !isTablet()', '                && (mStartSurfaceSupplier.get() == null', '                        || mStartSurfaceSupplier.get().getController().getStartSurfaceState()', '                                == StartSurfaceState.SHOWN_TABSWITCHER)) {', '            mOverviewModeController.hideOverview(true);', '            return true;', '        }', '', '        final WebContents webContents = currentTab.getWebContents();', '        if (webContents != null) {', '            RenderFrameHost focusedFrame = webContents.getFocusedFrame();', '            if (focusedFrame != null && focusedFrame.signalCloseWatcherIfActive()) return true;', '        }', '', '        if (getToolbarManager().back()) return true;', '', '        // If the current tab url is HELP_URL, then the back button should close the tab to', '        // get back to the previous state. The reason for startsWith check is that the', '        // actual redirected URL is a different system language based help url.', '        final @TabLaunchType int type = currentTab.getLaunchType();', '        final boolean helpUrl = currentTab.getUrl().getSpec().startsWith(HELP_URL_PREFIX);', '        if (type == TabLaunchType.FROM_CHROME_UI && helpUrl) {', '            getCurrentTabModel().closeTab(currentTab);', '            return true;', '        }', '', ""        // If we aren't in the overview mode, we handle the Tab with launchType"", '        // TabLaunchType.FROM_START_SURFACE or has ""OpenedFromStart"" property.', '        if (!mOverviewModeController.overviewVisible()', '                && (type == TabLaunchType.FROM_START_SURFACE', '                        || StartSurfaceUserData.isOpenedFromStart(currentTab))) {', '            if (StartSurfaceUserData.getKeepTab(currentTab)', '                    || StartSurfaceUserData.isOpenedFromStart(currentTab)) {', '                // If the current tab is created from the start surface with the keepTab property,', '                // shows the Start surface Homepage to prevent a loop between the current tab and', '                // previous overview mode. Once in the Start surface, it will close Chrome if back', '                // button is tapped again.', '                showOverview(StartSurfaceState.SHOWING_HOMEPAGE);']}, {'a': ['                if (type == TabLaunchType.FROM_LONGPRESS_BACKGROUND', '                        && !StartSurfaceUserData.getKeepTab(currentTab)) {'], 'b': ['                if (type == TabLaunchType.FROM_LONGPRESS_BACKGROUND) {']}, {'ab': ['                    getCurrentTabModel().closeTab(currentTab);', '                }', '            } else {', '                // Otherwise, clicking the back button should close the tab and go back to the', '                // previous overview mode.', '                showOverview(StartSurfaceState.SHOWING_PREVIOUS);', '                if (!currentTab.isClosing()) {', '                    getCurrentTabModel().closeTab(currentTab);', '                }', '            }', '            return true;', '        }', '', '        final boolean shouldCloseTab = backShouldCloseTab(currentTab);', '', '        // Minimize the app if either:', '        // - we decided not to close the tab', '        // - we decided to close the tab, but it was opened by an external app, so we will go', '        //   exit Chrome on top of closing the tab', '        final boolean minimizeApp =', '                !shouldCloseTab || TabAssociatedApp.isOpenedFromExternalApp(currentTab);', '        if (minimizeApp) {', '            if (shouldCloseTab) {', '                sendToBackground(currentTab);', '                return true;', '            } else {', '                sendToBackground(null);', '                return true;', '            }', '        } else if (shouldCloseTab) {', '            currentTab.getWebContents().dispatchBeforeUnload(false);', '            return true;', '        }', '', '        assert false : ""The back button should have already been handled by this point"";', '        return false;', '    }', '', '    /**', '     * [true]: Reached the bottom of the back stack on a tab the user did not explicitly', '     * create (i.e. it was created by an external app or opening a link in background, etc).', '     * [false]: Reached the bottom of the back stack on a tab that the user explicitly', '     * created (e.g. selecting ""new tab"" from menu).', '     *', '     * @return Whether pressing the back button on the provided Tab should close the Tab.', '     */', '    @Override', '    public boolean backShouldCloseTab(Tab tab) {', '        if (!tab.isInitialized()) {', '            return false;', '        }', '        @TabLaunchType', '        int type = tab.getLaunchType();', '', '        return type == TabLaunchType.FROM_LINK || type == TabLaunchType.FROM_EXTERNAL_APP', '                || type == TabLaunchType.FROM_LONGPRESS_FOREGROUND', '                || type == TabLaunchType.FROM_LONGPRESS_BACKGROUND', '                || (type == TabLaunchType.FROM_RESTORE', '                        && CriticalPersistedTabData.from(tab).getParentId() != Tab.INVALID_TAB_ID);', '    }', '', '    /**', '     * Sends this Activity to the background.', '     *', '     * @param tabToClose Tab that will be closed once the app is not visible.', '     */', '    private void sendToBackground(@Nullable final Tab tabToClose) {', '        Log.i(TAG, ""sendToBackground(): "" + tabToClose);', '        moveTaskToBack(true);', '        if (tabToClose != null) {', ""            // In the case of closing a tab upon minimization, don't allow the close action to"", ""            // happen until after our app is minimized to make sure we don't get a brief glimpse of"", '            // the newly active tab before we exit Chrome.', '            //', ""            // If the runnable doesn't run before the Activity dies, Chrome won't crash but the tab"", ""            // won't be closed (crbug.com/587565)."", '            mHandler.postDelayed(() -> {', '                boolean hasNextTab =', '                        getCurrentTabModel().getNextTabIfClosed(tabToClose.getId()) != null;', '                getCurrentTabModel().closeTab(tabToClose, false, true, false);', '', '                // If there is no next tab to open, enter overview mode.', '                if (!hasNextTab) showOverview(StartSurfaceState.SHOWING_START);', '            }, CLOSE_TAB_ON_MINIMIZE_DELAY_MS);', '        }', '    }', '', '    @Override', '    public boolean moveTaskToBack(boolean nonRoot) {', '        try {', '            return super.moveTaskToBack(nonRoot);', '        } catch (NullPointerException e) {', '            // Work around framework bug described in https://crbug.com/817567.', '            finish();', '            return true;', '        }', '    }', '', '    /**', '     * Launch a URL from an intent.', '     *', '     * @param url           The url from the intent.', '     * @param referer       Optional referer URL to be used.', '     * @param headers       Optional headers to be sent when opening the URL.', '     * @param externalAppId External app id.', '     * @param forceNewTab   Whether to force the URL to be launched in a new tab or to fall', '     *                      back to the default behavior for making that determination.', '     * @param isRendererInitiated Whether the intent is originally from browser renderer process.', '     * @param initiatorOrigin Origin that initiates the intent.', '     * @param intent        The original intent.', '     */', '    private Tab launchIntent(', '            LoadUrlParams loadUrlParams, String externalAppId, boolean forceNewTab, Intent intent) {', '        if (mUIWithNativeInitialized && !UrlUtilities.isNTPUrl(loadUrlParams.getUrl())) {', '            mOverviewModeController.hideOverview(false);', '            getToolbarManager().finishAnimations();', '        }', '        if (IntentHandler.wasIntentSenderChrome(intent)) {', '            // If the intent was launched by chrome, open the new tab in the appropriate model.', '            boolean isIncognito = IntentUtils.safeGetBooleanExtra(', '                    intent, IntentHandler.EXTRA_OPEN_NEW_INCOGNITO_TAB, false);', '            @TabLaunchType', '            Integer launchType = IntentHandler.getTabLaunchType(intent);', '            if (launchType == null) {', '                if (IntentUtils.safeGetBooleanExtra(', '                            intent, IntentHandler.EXTRA_INVOKED_FROM_SHORTCUT, false)) {', '                    launchType = TabLaunchType.FROM_LAUNCHER_SHORTCUT;', '                } else if (IntentUtils.safeGetBooleanExtra(', '                                   intent, IntentHandler.EXTRA_INVOKED_FROM_APP_WIDGET, false)) {', '                    launchType = TabLaunchType.FROM_APP_WIDGET;', '                } else if (IncognitoTabLauncher.didCreateIntent(intent)) {', '                    launchType = TabLaunchType.FROM_LAUNCH_NEW_INCOGNITO_TAB;', '                } else {', '                    // Using FROM_LINK ensures the tab is parented to the current tab, which allows', '                    // the back button to close these tabs and restore selection to the previous', '                    // tab.', '                    launchType = TabLaunchType.FROM_LINK;', '                }', '            }', '            return getTabCreator(isIncognito).createNewTab(loadUrlParams, launchType, null, intent);', '        }', '', '        // Check if the tab is being created from a Reader Mode navigation.', '        if (ReaderModeManager.isEnabled() && ReaderModeManager.isReaderModeCreatedIntent(intent)) {', '            Bundle extras = intent.getExtras();', '            int readerParentId = IntentUtils.safeGetInt(', '                    extras, ReaderModeManager.EXTRA_READER_MODE_PARENT, Tab.INVALID_TAB_ID);', '            extras.remove(ReaderModeManager.EXTRA_READER_MODE_PARENT);', '            // Set the parent tab to the tab that Reader Mode started from.', '            if (readerParentId != Tab.INVALID_TAB_ID && mTabModelSelector != null) {', '                return getCurrentTabCreator().createNewTab(', '                        new LoadUrlParams(loadUrlParams.getUrl(), PageTransition.LINK),', '                        TabLaunchType.FROM_LINK, mTabModelSelector.getTabById(readerParentId));', '            }', '        }', '', '        return getTabCreator(false).launchUrlFromExternalApp(', '                loadUrlParams, externalAppId, forceNewTab, intent);', '    }', '', '    private void showOverview(@StartSurfaceState int state) {', '        showOverview(state, NewTabPageLaunchOrigin.UNKNOWN);', '    }', '', '    // TODO(crbug.com/1115757): After crrev.com/c/2315823, Overview state and Startsurface state are', '    // two different things, we actual can split this into two methods: showOverview() and', ""    // showStartSurface(state). Let's do some auditing and clean up before perform the actual split."", '    private void showOverview(', '            @StartSurfaceState int state, @NewTabPageLaunchOrigin int launchOrigin) {', '        assert (state == StartSurfaceState.SHOWING_TABSWITCHER', '                || state == StartSurfaceState.SHOWING_HOMEPAGE', '                || state == StartSurfaceState.SHOWING_PREVIOUS', '                || state == StartSurfaceState.SHOWING_START);', '        if (mIsAccessibilityTabSwitcherEnabled != null && mIsAccessibilityTabSwitcherEnabled', '                && mOverviewModeController != null) {', '            // TODO(1200727): This is a temporary fix that should be removed once grid tab switcher', '            //                is completely launched. The ""start surface"" is now created regardless', '            //                of the state of accessibility, so we check that mode first and try', '            //                showing the overview list before going to the start surface.', '            mOverviewModeController.showOverview(false);', '        } else if (mStartSurfaceSupplier.get() != null) {', '            if (ReturnToChromeExperimentsUtil.shouldHideStartSurfaceWithAccessibilityOn(this)', '                    || !HomepageManager.isHomepageEnabled()) {', '                state = StartSurfaceState.SHOWING_TABSWITCHER;', '            }', '            mStartSurfaceSupplier.get().getController().setOverviewState(state, launchOrigin);', '        }', '', '        if (mOverviewModeController == null) return;', '', '        if (mOverviewModeController.overviewVisible()) {', '            if (didFinishNativeInitialization()) {', '                getCompositorViewHolderSupplier().get().hideKeyboard(() -> {});', '            }', '            return;', '        }', '', '        Tab currentTab = getActivityTab();', ""        // If we don't have a current tab, show the overview mode."", '        if (currentTab == null) {', '            mOverviewModeController.showOverview(false);', '        } else {', '            getCompositorViewHolderSupplier().get().hideKeyboard(', '                    () -> mOverviewModeController.showOverview(true));', '            updateAccessibilityState(false);', '            TasksUma.recordTabLaunchType(getCurrentTabModel());', '        }', '    }', '', '    private void hideOverview() {', '        assert (mOverviewModeController.overviewVisible());', '        if (getCurrentTabModel().getCount() != 0) {', ""            // Don't hide overview if current tab stack is empty()"", '            mOverviewModeController.hideOverview(true);', '            updateAccessibilityState(true);', '        }', '    }', '', '    /**', '     * @return Whether opening a new tab is handled by the Start surface. It may show the Start', '     * surface, or open a new tab with the omnibox get focused, depending on the value of', '     * {@link StartSurfaceConfiguration.OMNIBOX_FOCUSED_ON_NEW_TAB}.', '     */', '    private boolean showStartSurfaceHomeForNTP(boolean isNTP, boolean incognito, Tab parentTab,', '            @NewTabPageLaunchOrigin int launchOrigin) {', '        if (!isNTP', '                || !ReturnToChromeExperimentsUtil.shouldShowStartSurfaceHomeAsNTP(', '                        this, incognito, isTablet())) {', '            return false;', '        }', '', '        getTabModelSelector().selectModel(incognito);', '        if (StartSurfaceConfiguration.OMNIBOX_FOCUSED_ON_NEW_TAB.getValue()', '                && launchOrigin != NewTabPageLaunchOrigin.WEB_FEED) {', '            Runnable emptyTabCloseCallback = isInOverviewMode() ? () -> {', '                showOverview(StartSurfaceState.SHOWING_PREVIOUS, launchOrigin);', '            } : null;', '            ReturnToChromeExperimentsUtil.handleLoadUrlFromStartSurfaceAsNewTab(null,', '                    PageTransition.AUTO_TOPLEVEL, incognito, parentTab, getCurrentTabModel(),', '                    emptyTabCloseCallback);', '        } else if (TabUiFeatureUtilities.supportInstantStart(isTablet(), this)', '                || (getTabModelSelector().isTabStateInitialized() && isLayoutManagerCreated())) {', '            showOverview(StartSurfaceState.SHOWING_HOMEPAGE, launchOrigin);', '        }', '        return true;', '    }', '', '    private void updateAccessibilityState(boolean enabled) {', '        Tab currentTab = getActivityTab();', '        WebContents webContents = currentTab != null ? currentTab.getWebContents() : null;', '        if (webContents != null) {', '            WebContentsAccessibility.fromWebContents(webContents).setState(enabled);', '        }', '    }', '', '    @Override', '    public void onSaveInstanceState(Bundle outState) {', '        super.onSaveInstanceState(outState);', '        CipherFactory.getInstance().saveToBundle(outState);', '        outState.putInt(', '                WINDOW_INDEX, TabWindowManagerSingleton.getInstance().getIndexForWindow(this));', '        Boolean is_incognito = getCurrentTabModel().isIncognito();', '        outState.putBoolean(IS_INCOGNITO_SELECTED, is_incognito);', ""        // If it's Incognito and native is initialized and profile exists, serialize duration"", '        // service state.', '        if (is_incognito && ProfileManager.isInitialized()) {', '            AndroidSessionDurationsServiceState.serializeFromNative(', '                    outState, getCurrentTabModel().getProfile());', '        }', '    }', '', '    @Override', '    public void onDestroyInternal() {', '        if (mCallbackController != null) {', '            mCallbackController.destroy();', '            mCallbackController = null;', '        }', '', '        if (mTabModelSelectorTabObserver != null) {', '            mTabModelSelectorTabObserver.destroy();', '            mTabModelSelectorTabObserver = null;', '        }', '', '        if (mTabModelObserver != null) mTabModelObserver.destroy();', '', '        if (mUndoBarPopupController != null) {', '            mUndoBarPopupController.destroy();', '            mUndoBarPopupController = null;', '        }', '', '        if (mAppIndexingUtil != null) {', '            mAppIndexingUtil.destroy();', '            mAppIndexingUtil = null;', '        }', '', '        if (mStartSurfaceSupplier.get() != null) {', '            mStartSurfaceSupplier.get().destroy();', '        }', '', '        if (mStartupPaintPreviewHelperSupplier != null) {', '            mStartupPaintPreviewHelperSupplier.destroy();', '        }', '', '        if (mJankTracker != null) {', '            mJankTracker.destroy();', '            mJankTracker = null;', '        }', '', '        IncognitoTabHostRegistry.getInstance().unregister(mIncognitoTabHost);', '', '        TabObscuringHandler tabObscuringHandler = getTabObscuringHandler();', '        if (tabObscuringHandler != null) {', '            getTabObscuringHandler().removeObserver(mCompositorViewHolder);', '            getTabObscuringHandler().removeObserver(mOverviewListLayout);', '        }', '', '        if (isTablet()) ChromeAccessibilityUtil.get().removeObserver(mCompositorViewHolder);', '        ChromeAccessibilityUtil.get().removeObserver(this);', '        ChromeAccessibilityUtil.get().removeObserver(mLayoutManager);', '', '        if (mTabDelegateFactory != null) mTabDelegateFactory.destroy();', '', '        mAppLaunchDrawBlocker.destroy();', '', '        super.onDestroyInternal();', '    }', '', '    @Override', '    protected void destroyTabModels() {', '        if (mTabModelOrchestrator != null) {', '            mTabModelOrchestrator.destroy();', '        }', '    }', '', '    @Override', '    public void onTrimMemory(int level) {', '        super.onTrimMemory(level);', '        if (ChromeApplicationImpl.isSevereMemorySignal(level)) {', '            NativePageAssassin.getInstance().freezeAllHiddenPages();', '        }', '    }', '', '    @Override', '    public boolean dispatchKeyEvent(KeyEvent event) {', '        Boolean result = KeyboardShortcuts.dispatchKeyEvent(event, mUIWithNativeInitialized,', '                getFullscreenManager(), /* menuOrKeyboardActionController= */ this);', '        return result != null ? result : super.dispatchKeyEvent(event);', '    }', '', '    @Override', '    public boolean onKeyDown(int keyCode, KeyEvent event) {', '        if (!mUIWithNativeInitialized) {', '            return super.onKeyDown(keyCode, event);', '        }', '        // Detecting a long press of the back button via onLongPress is broken in Android N.', '        // To work around this, use a postDelayed, which is supported in all versions.', '        if (keyCode == KeyEvent.KEYCODE_BACK && !isTablet()', '                && !getFullscreenManager().getPersistentFullscreenMode()) {', '            if (mShowHistoryRunnable == null) mShowHistoryRunnable = this::showFullHistorySheet;', '            mHandler.postDelayed(mShowHistoryRunnable, ViewConfiguration.getLongPressTimeout());', '            return super.onKeyDown(keyCode, event);', '        }', '        boolean isCurrentTabVisible = !mOverviewModeController.overviewVisible()', '                && (!isTablet() || getCurrentTabModel().getCount() != 0);', '        return KeyboardShortcuts.onKeyDown(event, isCurrentTabVisible, true, getTabModelSelector(),', '                       /* menuOrKeyboardActionController= */ this, getToolbarManager())', '                || super.onKeyDown(keyCode, event);', '    }', '', '    private void showFullHistorySheet() {', '        ((TabbedRootUiCoordinator) mRootUiCoordinator).showFullHistorySheet();', '    }', '', '    @Override', '    public boolean onKeyUp(int keyCode, KeyEvent event) {', '        if (keyCode == KeyEvent.KEYCODE_BACK && !isTablet()) {', '            mHandler.removeCallbacks(mShowHistoryRunnable);', '            mShowHistoryRunnable = null;', '            if (event.getEventTime() - event.getDownTime()', '                            >= ViewConfiguration.getLongPressTimeout()', '                    && NavigationSheet.isInstanceShowing(', '                            mRootUiCoordinator.getBottomSheetController())) {', '                // If tab history popup is showing, do not process the keyUp event', '                // which will dismiss it immediately.', '                return true;', '            }', '        }', '        return super.onKeyUp(keyCode, event);', '    }', '', '    @VisibleForTesting', '    public boolean hasPendingNavigationRunnableForTesting() {', '        ThreadUtils.assertOnUiThread();', '        return mShowHistoryRunnable != null;', '    }', '', '    @Override', '    public void onProvideKeyboardShortcuts(', '            List<KeyboardShortcutGroup> data, Menu menu, int deviceId) {', '        data.addAll(KeyboardShortcuts.createShortcutGroup(this));', '    }', '', '    @VisibleForTesting', '    public View getTabsView() {', '        return getCompositorViewHolderSupplier().get();', '    }', '', '    @VisibleForTesting', '    public LayoutManagerChrome getLayoutManager() {', '        return (LayoutManagerChrome) getCompositorViewHolderSupplier().get().getLayoutManager();', '    }', '', '    @VisibleForTesting', '    public Layout getOverviewListLayout() {', '        return getLayoutManager().getOverviewListLayout();', '    }', '', '    @VisibleForTesting', '    public StartSurface getStartSurface() {', '        return mStartSurfaceSupplier.get();', '    }', '', '    private ComposedBrowserControlsVisibilityDelegate getAppBrowserControlsVisibilityDelegate() {', '        // TODO(jinsukkim): Move this to RootUiCoordinator.', '        return ((TabbedRootUiCoordinator) mRootUiCoordinator)', '                .getAppBrowserControlsVisibilityDelegate();', '    }', '', '    @Override', '    protected ModalDialogManager createModalDialogManager() {', '        ModalDialogManager manager = super.createModalDialogManager();', '        // TODO(crbug.com/1157310): Transition this::method refs to dedicated suppliers.', '        mTabModalHandler = new TabModalLifetimeHandler(this, getLifecycleDispatcher(), manager,', '                this::getAppBrowserControlsVisibilityDelegate, this::getTabObscuringHandler,', '                this::getToolbarManager, this::getContextualSearchManager,', '                getTabModelSelectorSupplier(), this::getBrowserControlsManager,', '                this::getFullscreenManager);', '        return manager;', '    }', '', '    // App Menu related code -----------------------------------------------------------------------', '', '    @Override', '    public boolean canShowAppMenu() {', '        // The popup menu relies on the model created during the full UI initialization, so do not', '        // attempt to show the menu until the UI creation has finished.', '        if (!mUIWithNativeInitialized) return false;', '', ""        // If the current active tab is showing a tab modal dialog, an app menu shouldn't be shown"", '        // in any cases, e.g. when a hardware menu button is clicked.', '        Tab tab = getActivityTab();', '        if (tab != null && ChromeTabModalPresenter.isDialogShowing(tab)) return false;', '', '        return super.canShowAppMenu();', '    }', '', '    @Override', '    public boolean isInOverviewMode() {', '        return mOverviewModeController != null && mOverviewModeController.overviewVisible();', '    }', '', '    @Override', '    protected IntentHandlerDelegate createIntentHandlerDelegate() {', '        return new InternalIntentDelegate();', '    }', '', '    @Override', '    public void onSceneChange(Layout layout) {', '        super.onSceneChange(layout);', '        if (!layout.shouldDisplayContentOverlay()) mTabModelSelector.onTabsViewShown();', '    }', '', '    /**', '     * Writes the tab state to disk.', '     */', '    @VisibleForTesting', '    public void saveState() {', '        mTabModelOrchestrator.saveState();', '    }', '', '    @Override', '    public void onEnterVr() {', '        super.onEnterVr();', '        mControlContainer.setVisibility(View.INVISIBLE);', '        if (mVrBrowserControlsVisibilityDelegate == null) {', '            mVrBrowserControlsVisibilityDelegate =', '                    new BrowserControlsVisibilityDelegate(BrowserControlsState.BOTH);', '            getAppBrowserControlsVisibilityDelegate().addDelegate(', '                    mVrBrowserControlsVisibilityDelegate);', '        }', '        mVrBrowserControlsVisibilityDelegate.set(BrowserControlsState.HIDDEN);', '    }', '', '    @Override', '    public void onExitVr() {', '        super.onExitVr();', '        mControlContainer.setVisibility(View.VISIBLE);', '        if (mVrBrowserControlsVisibilityDelegate != null) {', '            mVrBrowserControlsVisibilityDelegate.set(BrowserControlsState.BOTH);', '        }', '    }', '', '    @Override', '    protected void applyThemeOverlays() {', '        super.applyThemeOverlays();', '', '        if (TabManagementModuleProvider.getDelegate() != null) {', '            TabManagementModuleProvider.getDelegate().applyThemeOverlays(this);', '        }', '    }', '', '    @Override', '    protected boolean supportsDynamicColors() {', '        return CachedFeatureFlags.isEnabled(ChromeFeatureList.DYNAMIC_COLOR_ANDROID);', '    }', '', '    /**', '     * Reports that a new tab launcher shortcut was selected or an action equivalent to a shortcut', '     * was performed.', '     * @param isIncognito Whether the shortcut or action created a new incognito tab.', '     */', '    @TargetApi(Build.VERSION_CODES.N_MR1)', '    private void reportNewTabShortcutUsed(boolean isIncognito) {', '        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N_MR1) return;', '', '        ShortcutManager shortcutManager = getSystemService(ShortcutManager.class);', '        shortcutManager.reportShortcutUsed(', '                isIncognito ? ""new-incognito-tab-shortcut"" : ""new-tab-shortcut"");', '    }', '', '    @VisibleForTesting', '    public MultiInstanceManager getMultiInstanceMangerForTesting() {', '        return mMultiInstanceManager;', '    }', '', '    @VisibleForTesting', '    public ChromeNextTabPolicySupplier getNextTabPolicySupplier() {', '        return (ChromeNextTabPolicySupplier) mNextTabPolicySupplier;', '    }', '}', '']}]",chromium%2Fsrc~main~Ib8e4eafef2405d982bc64a050f47a12c26242ec2,18d923c044f261448f485740f8bb60731b5e9be5,chrome/android/java/src/org/chromium/chrome/browser/ChromeTabbedActivity.java,343e0792_12916045_before.java,343e0792_12916045_after.java,ChromeTabbedActivity::handleBackPressed,True,True
